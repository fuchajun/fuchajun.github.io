

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" href="/img/favicon.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="John Doe">
  <meta name="keywords" content="">
  
    <meta name="description" content="Servlet[参考链接C语言编程网Servlet教程](Servlet教程 (biancheng.net))Http协议HTTP 协议（Hypertext Transfer Protocol, 超文本传输协议）,本质上是客户端与服务端的通行规则,这一通信规则规定了客户端发送给服务器的内容格式，也规定了服务器发送给客户端的内容格式。客户端 发送给服务器的格式叫”请求协议”；服务器发送给客户端的格式">
<meta property="og:type" content="article">
<meta property="og:title" content="Servlet学习笔记">
<meta property="og:url" content="http://example.com/2022/08/02/Servlet%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="Servlet[参考链接C语言编程网Servlet教程](Servlet教程 (biancheng.net))Http协议HTTP 协议（Hypertext Transfer Protocol, 超文本传输协议）,本质上是客户端与服务端的通行规则,这一通信规则规定了客户端发送给服务器的内容格式，也规定了服务器发送给客户端的内容格式。客户端 发送给服务器的格式叫”请求协议”；服务器发送给客户端的格式">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://gcore.jsdelivr.net/gh/fuchajun/blogImgs/img/202208020946238.png">
<meta property="og:image" content="https://gcore.jsdelivr.net/gh/fuchajun/blogImgs/img/202208020946477.png">
<meta property="og:image" content="https://gcore.jsdelivr.net/gh/fuchajun/blogImgs/img/202208020947404.png">
<meta property="og:image" content="https://gcore.jsdelivr.net/gh/fuchajun/blogImgs/img/202208021003569.png">
<meta property="og:image" content="https://gcore.jsdelivr.net/gh/fuchajun/blogImgs/img/202208021004375.png">
<meta property="og:image" content="https://gcore.jsdelivr.net/gh/fuchajun/blogImgs/img/202208021004870.png">
<meta property="og:image" content="https://gcore.jsdelivr.net/gh/fuchajun/blogImgs/img/202208021004955.png">
<meta property="og:image" content="https://gcore.jsdelivr.net/gh/fuchajun/blogImgs/img/202208021004647.png">
<meta property="og:image" content="https://gcore.jsdelivr.net/gh/fuchajun/blogImgs/img/202208021004083.jpeg">
<meta property="article:published_time" content="2022-08-02T01:59:12.000Z">
<meta property="article:modified_time" content="2022-08-02T02:04:44.854Z">
<meta property="article:author" content="John Doe">
<meta property="article:tag" content="Servlet">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://gcore.jsdelivr.net/gh/fuchajun/blogImgs/img/202208020946238.png">
  
  
  <title>Servlet学习笔记 - Hexo</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4/github-markdown.min.css" />
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hint.css@2/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.css" />
  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.8.14","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 6.1.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>浮槎菌の小栈</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/img/default.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="Servlet学习笔记">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2022-08-02 09:59" pubdate>
        2022年8月2日 上午
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      32k 字
    </span>
  

  
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      265 分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">Servlet学习笔记</h1>
            
            <div class="markdown-body">
              <h1 id="Servlet"><a href="#Servlet" class="headerlink" title="Servlet"></a>Servlet</h1><h3 id="参考链接C语言编程网Servlet教程-Servlet教程-biancheng-net"><a href="#参考链接C语言编程网Servlet教程-Servlet教程-biancheng-net" class="headerlink" title="[参考链接C语言编程网Servlet教程](Servlet教程 (biancheng.net))"></a>[参考链接C语言编程网Servlet教程](<a target="_blank" rel="noopener" href="http://c.biancheng.net/servlet2/">Servlet教程 (biancheng.net)</a>)</h3><h2 id="Http协议"><a href="#Http协议" class="headerlink" title="Http协议"></a>Http协议</h2><p>HTTP 协议（Hypertext Transfer Protocol, 超文本传输协议）,本质上是客户端与服务端的通行规则,这一通信规则规定了客户端发送给服务器的内容格式，也规定了服务器发送给客户端的内容格式。客户端 发送给服务器的格式叫”请求协议”；服务器发送给客户端的格式叫”响应协议”。</p>
<p>浏览器查看协议传输的数据内容,可以通过F12实现</p>
<p><img src="https://gcore.jsdelivr.net/gh/fuchajun/blogImgs/img/202208020946238.png" srcset="/img/loading.gif" lazyload></p>
<h3 id="Http格式"><a href="#Http格式" class="headerlink" title="Http格式"></a>Http格式</h3><p>服务器端资源需要通过浏览器进行，此时由浏览器将我们给出的请求解析为满足 HTTP 协议的格式并 发出。我们发出的请求格式需要按照浏览器规定的格式来书写，在浏览器中书写格式如下：<img src="https://gcore.jsdelivr.net/gh/fuchajun/blogImgs/img/202208020946477.png" srcset="/img/loading.gif" lazyload alt="http格式"></p>
<h3 id="Http特点"><a href="#Http特点" class="headerlink" title="Http特点"></a>Http特点</h3><p><strong>1.支持客户&#x2F;服务器模式。</strong></p>
<p><strong>2.简单快速：客户向服务器请求服务时，只需传送请求方法和路径。请求方法常用的有GT、POST。每种方法规定了客户与服务器联系的类型不同。由于HTTP协议简单，使得HTTP服务器的程序规模小，因而通信速度很快。</strong></p>
<p><strong>3.灵活：HTTP允许传输任意类型的数据对象。传输的类型由Content-Type加以标记。</strong></p>
<p><strong>4.无连接：无连接是表示每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。HTTP1.1版本后支持可持续连接。通过这种连接，就有可能在建立一个TCP连接后，发送请求并得到回应，然后发送更多的请求并得到更多的回应.通过把建立和释放TCP连接的开销分难到多个请求上，则对于每个请求而言，由于TCP而造成的相对开销被大大地降低了。而且，还可以发送流水线请求，也就是说在发送请求1之后的回应到来之前就可以发送请求2也可以认为，一次连接发送多个请求，由客户机确认是否关闭连接，而服务器会认为这些请求分别来自不同的客户端。</strong></p>
<p><strong>5.无状态：HTTP协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。</strong></p>
<h3 id="Http请求"><a href="#Http请求" class="headerlink" title="Http请求"></a>Http请求</h3><p>Http请求协议由三部分组成—请求行,请求头,请求正文(GET请求没有请求正文) </p>
<p><strong>请求头</strong>由一堆键值对组成</p>
<p>例如:</p>
<p>Accept: *&#x2F;*</p>
<p>Accept-Encoding: gzip, deflate, br </p>
<p>Accept-Language: zh-CN,zh;q&#x3D;0.9 </p>
<p>Cache-Control: no-cache </p>
<p>Connection: keep-alive </p>
<p>Host: hectorstatic.baidu.com </p>
<p>Pragma: no-cache </p>
<p>Referer: <a target="_blank" rel="noopener" href="https://www.baidu.com/">https://www.baidu.com/</a></p>
<p><strong>请求行</strong>以一个方法符号开头，以空格分开，后面跟着请求的 URI 和协议的版本。 </p>
<p>格式如下：Method Request-URI HTTP-Version CRLF </p>
<p>Method 表示请求方法； Request-URI 是一个统一资源标识符； HTTP-Version 表示请 求的 HTTP 协议版本； CRLF 表示回车和换行；</p>
<p>例如:</p>
<p>GET &#x2F;s01&#x2F;ser01?uname&#x3D;zhangsan  HTTP&#x2F;1.1</p>
<p><strong>请求正文</strong>–你需要传递给服务器的数据</p>
<p>GET请求没有请求正文,因为GET请求会直接把请求正文放在地址栏后面</p>
<p>POST请求有请求体(请求正文),如果你有参数需要传递,则会把参数放到Form Data 中(请求体的一部分)</p>
<p>例如:</p>
<p><a target="_blank" rel="noopener" href="http://localhost:8080/**myweb/servlet1/username=admin&amp;pwd=123456**,%E5%90%8E%E9%9D%A2%E8%BF%99%E4%B8%80%E6%AE%B5%E5%8F%AF%E4%BB%A5%E5%BD%93%E4%BD%9C%E8%AF%B7%E6%B1%82%E6%AD%A3%E6%96%87,%E6%90%9C%E7%B4%A2%E6%97%B6%E5%9C%B0%E5%9D%80%E6%A0%8F%E4%B8%8A%E7%9A%84%E4%B8%80%E5%A4%A7%E5%A0%86%E7%B1%BB%E4%BC%BC%E4%BA%8E%E4%B9%B1%E7%A0%81%E7%9A%84%E4%B8%9C%E8%A5%BF%E5%B0%B1%E6%98%AF%E8%AF%B7%E6%B1%82%E6%AD%A3%E6%96%87">http://localhost:8080/**myweb/servlet1/username=admin&amp;pwd=123456**,后面这一段可以当作请求正文,搜索时地址栏上的一大堆类似于乱码的东西就是请求正文</a></p>
<p>请求行也有三部分组成—请求方式   请求路径    Http协议版本</p>
<h3 id="Http响应"><a href="#Http响应" class="headerlink" title="Http响应"></a>Http响应</h3><p>在接收和解释请求消息后，服务器返回一个 HTTP 响应消息。</p>
<p>HTTP 响应也是由三个部分组成，分别 是：<strong>状态行、消息报头、响应正文。</strong></p>
<p><img src="https://gcore.jsdelivr.net/gh/fuchajun/blogImgs/img/202208020947404.png" srcset="/img/loading.gif" lazyload alt="Snipaste_2022-07-28_21-19-54"></p>
<h3 id="消息头"><a href="#消息头" class="headerlink" title="消息头"></a>消息头</h3><p>HTTP 消息由客户端到服务器的请求和服务器到客户端的响应组成。请求消息和响应消息都是由开始 行（对于请求消息，开始行就是请求行，对于响应消息，开始行就是状态行）， 消息报头（可选），空 行（只有 CRLF 的行），消息正文（可选）组成。</p>
<p>每一个报头域都是由 <strong>名字+”:”+空格+值</strong> 组成，消息报头域的名字是大小写无关的。</p>
<p><strong>请求头</strong><br>请求报头允许客户端向服务器端传递请求的附加信息以及客户端自身的信息。</p>
<p>Referer:该请求头指明请求从哪里来。<br>如果是地址栏中输入地址访问的都没有该请求头地址栏输入地址，通过请求可以看到，此时多了一个Referer的请求头，并且后面的值为该请求从哪里发出。比如：百度竞价，只能从百度来的才有效果，否则不算；通常用来做统计工作、防盗链。</p>
<p><strong>响应头</strong><br>响应报头允许服务器传递不能放在状态行中的附加响应信息，以及关于服务器的信息和对Request-URl所标识的资源进行下一步访问的信息。</p>
<p>Location：Location响应报头域用于重定向接受者到一个新的位置。</p>
<p>Location响应报头域，常用在更换域名的时候。</p>
<figure class="highlight java"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs java">response.sendRedirect(<span class="hljs-string">&quot;http://www.baidu.com&quot;</span>);<br></code></pre></td></tr></table></figure>

<p>Refresh：自动跳转（单位是秒），可以在页面通过meta标签实现，也可在后台实现。</p>
<figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jsp">&lt;meta http-equiv=<span class="hljs-string">&quot;refresh&quot;</span> content=<span class="hljs-string">&quot;3;url=http://www.baidu.com&quot;</span>&gt;<br></code></pre></td></tr></table></figure>

<h3 id="Servlet-HTTP-状态码"><a href="#Servlet-HTTP-状态码" class="headerlink" title="Servlet HTTP 状态码"></a>Servlet HTTP 状态码</h3><table>
<thead>
<tr>
<th align="left">代码</th>
<th align="left">消息</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">100</td>
<td align="left">Continue</td>
<td align="left">只有请求的一部分已经被服务器接收，但只要它没有被拒绝，客户端应继续该请求。</td>
</tr>
<tr>
<td align="left">101</td>
<td align="left">Switching Protocols</td>
<td align="left">服务器切换协议。</td>
</tr>
<tr>
<td align="left">200</td>
<td align="left">OK</td>
<td align="left">请求成功。</td>
</tr>
<tr>
<td align="left">201</td>
<td align="left">Created</td>
<td align="left">该请求是完整的，并创建一个新的资源。</td>
</tr>
<tr>
<td align="left">202</td>
<td align="left">Accepted</td>
<td align="left">该请求被接受处理，但是该处理是不完整的。</td>
</tr>
<tr>
<td align="left">203</td>
<td align="left">Non-authoritative Information</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">204</td>
<td align="left">No Content</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">205</td>
<td align="left">Reset Content</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">206</td>
<td align="left">Partial Content</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">300</td>
<td align="left">Multiple Choices</td>
<td align="left">链接列表。用户可以选择一个链接，进入到该位置。最多五个地址。</td>
</tr>
<tr>
<td align="left">301</td>
<td align="left">Moved Permanently</td>
<td align="left">所请求的页面已经转移到一个新的 URL。</td>
</tr>
<tr>
<td align="left">302</td>
<td align="left">Found</td>
<td align="left">所请求的页面已经临时转移到一个新的 URL。</td>
</tr>
<tr>
<td align="left">303</td>
<td align="left">See Other</td>
<td align="left">所请求的页面可以在另一个不同的 URL 下被找到。</td>
</tr>
<tr>
<td align="left">304</td>
<td align="left">Not Modified</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">305</td>
<td align="left">Use Proxy</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">306</td>
<td align="left"><em>Unused</em></td>
<td align="left">在以前的版本中使用该代码。现在已不再使用它，但代码仍被保留。</td>
</tr>
<tr>
<td align="left">307</td>
<td align="left">Temporary Redirect</td>
<td align="left">所请求的页面已经临时转移到一个新的 URL。</td>
</tr>
<tr>
<td align="left">400</td>
<td align="left">Bad Request</td>
<td align="left">服务器不理解请求。</td>
</tr>
<tr>
<td align="left">401</td>
<td align="left">Unauthorized</td>
<td align="left">所请求的页面需要用户名和密码。</td>
</tr>
<tr>
<td align="left">402</td>
<td align="left">Payment Required</td>
<td align="left"><em>您还不能使用该代码。</em></td>
</tr>
<tr>
<td align="left">403</td>
<td align="left">Forbidden</td>
<td align="left">禁止访问所请求的页面。</td>
</tr>
<tr>
<td align="left">404</td>
<td align="left">Not Found</td>
<td align="left">服务器无法找到所请求的页面。.</td>
</tr>
<tr>
<td align="left">405</td>
<td align="left">Method Not Allowed</td>
<td align="left">在请求中指定的方法是不允许的。</td>
</tr>
<tr>
<td align="left">406</td>
<td align="left">Not Acceptable</td>
<td align="left">服务器只生成一个不被客户端接受的响应。</td>
</tr>
<tr>
<td align="left">407</td>
<td align="left">Proxy Authentication Required</td>
<td align="left">在请求送达之前，您必须使用代理服务器的验证。</td>
</tr>
<tr>
<td align="left">408</td>
<td align="left">Request Timeout</td>
<td align="left">请求需要的时间比服务器能够等待的时间长，超时。</td>
</tr>
<tr>
<td align="left">409</td>
<td align="left">Conflict</td>
<td align="left">请求因为冲突无法完成。</td>
</tr>
<tr>
<td align="left">410</td>
<td align="left">Gone</td>
<td align="left">所请求的页面不再可用。</td>
</tr>
<tr>
<td align="left">411</td>
<td align="left">Length Required</td>
<td align="left">“Content-Length” 未定义。服务器无法处理客户端发送的不带 Content-Length 的请求信息。</td>
</tr>
<tr>
<td align="left">412</td>
<td align="left">Precondition Failed</td>
<td align="left">请求中给出的先决条件被服务器评估为 false。</td>
</tr>
<tr>
<td align="left">413</td>
<td align="left">Request Entity Too Large</td>
<td align="left">服务器不接受该请求，因为请求实体过大。</td>
</tr>
<tr>
<td align="left">414</td>
<td align="left">Request-url Too Long</td>
<td align="left">服务器不接受该请求，因为 URL 太长。当您转换一个 “post” 请求为一个带有长的查询信息的 “get” 请求时发生。</td>
</tr>
<tr>
<td align="left">415</td>
<td align="left">Unsupported Media Type</td>
<td align="left">服务器不接受该请求，因为媒体类型不被支持。</td>
</tr>
<tr>
<td align="left">417</td>
<td align="left">Expectation Failed</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">500</td>
<td align="left">Internal Server Error</td>
<td align="left">未完成的请求。服务器遇到了一个意外的情况。</td>
</tr>
<tr>
<td align="left">501</td>
<td align="left">Not Implemented</td>
<td align="left">未完成的请求。服务器不支持所需的功能。</td>
</tr>
<tr>
<td align="left">502</td>
<td align="left">Bad Gateway</td>
<td align="left">未完成的请求。服务器从上游服务器收到无效响应。</td>
</tr>
<tr>
<td align="left">503</td>
<td align="left">Service Unavailable</td>
<td align="left">未完成的请求。服务器暂时超载或死机。</td>
</tr>
<tr>
<td align="left">504</td>
<td align="left">Gateway Timeout</td>
<td align="left">网关超时。</td>
</tr>
<tr>
<td align="left">505</td>
<td align="left">HTTP Version Not Supported</td>
<td align="left">服务器不支持”HTTP协议”版本。</td>
</tr>
</tbody></table>
<h2 id="Servlet-1"><a href="#Servlet-1" class="headerlink" title="Servlet"></a>Servlet</h2><p>Servlet 是 Server 与 Applet 的缩写，是服务端小程序的意思。使用 Java 语言编写的服务器端程序， 可以生成动态的 WEB 页，Servlet 主要运行在服务器端，并由服务器调用执行， 是一种按照 Servlet 标 准来开发的类。言外之意：要实现 web 开 发，需要实现 Servlet 标准</p>
<p>Servlet 本质上也是 Java 类，但要遵循 Servlet 规范进行编写，没有 main()方法，它的创建、使用、 销毁都由 Servlet 容器进行管理(如 Tomcat)。言外之意：写自己的类，不用写 main 方法，别人自动 调用</p>
<p> Servlet 是和 HTTP 协议是紧密联系的，其可以处理 HTTP 协议相关的所有内容。这也是 Servlet 应用 广泛的原因之一。 提供了 Servlet 功能的服务器，叫做 Servlet 容器，其常见容器有很多，如 Tomcat, Jetty, WebLogic Server, WebSphere, JBoss 等等。</p>
<p> <strong>Servlet是JavaWeb的三大组件之一，它属于动态资源。Servlet的作用是处理请求，服务器会把接受到的请求交给Servlet来处理，在Servlet中通常需要：</strong></p>
<ul>
<li><p>接受请求数据；</p>
</li>
<li><p>处理请求；</p>
</li>
<li><p>完成响应。</p>
<p>例如客户端发出登录请求，或者输出注册请求，这些请求都应该有Servlet来完成处理！Servlet需要我们自己来编写，每个Servlet必须实现javax.servlet.Servlet接口。</p>
</li>
</ul>
<h3 id="实现Servlet的三种方式"><a href="#实现Servlet的三种方式" class="headerlink" title="实现Servlet的三种方式"></a>实现Servlet的三种方式</h3><p>Servlet 创有三种方式。</p>
<h4 id="1、实现-Servlet-接口"><a href="#1、实现-Servlet-接口" class="headerlink" title="1、实现 Servlet 接口"></a><strong>1、实现 Servlet 接口</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//Servlet的生命周期:从Servlet被创建到Servlet被销毁的过程</span><br><span class="hljs-comment">//一次创建，到处服务</span><br><span class="hljs-comment">//一个Servlet只会有一个对象，服务所有的请求</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 1.实例化（使用构造方法创建对象）</span><br><span class="hljs-comment"> * 2.初始化  执行init方法</span><br><span class="hljs-comment"> * 3.服务     执行service方法</span><br><span class="hljs-comment"> * 4.销毁    执行destroy方法</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ServletDemo1</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Servlet</span> &#123;<br><br>    <span class="hljs-comment">//public ServletDemo1()&#123;&#125;</span><br><br>     <span class="hljs-comment">//生命周期方法:当Servlet第一次被创建对象时执行该方法,该方法在整个生命周期中只执行一次</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">(ServletConfig arg0)</span> <span class="hljs-keyword">throws</span> ServletException &#123;<br>                System.out.println(<span class="hljs-string">&quot;=======init=========&quot;</span>);<br>        &#125;<br><br>    <span class="hljs-comment">//生命周期方法:对客户端响应的方法,该方法会被执行多次，每次请求该servlet都会执行该方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">service</span><span class="hljs-params">(ServletRequest arg0, ServletResponse arg1)</span><br>            <span class="hljs-keyword">throws</span> ServletException, IOException &#123;<br>        System.out.println(<span class="hljs-string">&quot;hehe&quot;</span>);<br><br>    &#125;<br><br>    <span class="hljs-comment">//生命周期方法:当Servlet被销毁时执行该方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">destroy</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;******destroy**********&quot;</span>);<br>    &#125;<br><span class="hljs-comment">//当停止tomcat时也就销毁的servlet。</span><br>    <span class="hljs-keyword">public</span> ServletConfig <span class="hljs-title function_">getServletConfig</span><span class="hljs-params">()</span> &#123;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getServletInfo</span><span class="hljs-params">()</span> &#123;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>因为是实现 Servlet 接口，所以我们需要实现接口里的方法。</p>
<p>下面我们也说明了 Servlet 的执行过程，也就是 Servlet 的生命周期。</p>
<h4 id="2、继承-GenericServlet-类"><a href="#2、继承-GenericServlet-类" class="headerlink" title="2、继承 GenericServlet 类"></a><strong>2、继承 GenericServlet 类</strong></h4><p>它实现了 Servlet 接口除了 service 的方法，不过这种方法我们极少用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ServletDemo2</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">GenericServlet</span> &#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">service</span><span class="hljs-params">(ServletRequest arg0, ServletResponse arg1)</span><br>            <span class="hljs-keyword">throws</span> ServletException, IOException &#123;<br>        System.out.println(<span class="hljs-string">&quot;heihei&quot;</span>);<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="3、继承-HttpServlet-方法-只需要记住这一种"><a href="#3、继承-HttpServlet-方法-只需要记住这一种" class="headerlink" title="3、继承 HttpServlet 方法(只需要记住这一种)"></a><strong>3、继承 HttpServlet 方法</strong>(只需要记住这一种)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ServletDemo3</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">HttpServlet</span> &#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doGet</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span><br>            <span class="hljs-keyword">throws</span> ServletException, IOException &#123;<br>        System.out.println(<span class="hljs-string">&quot;haha&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doPost</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span><br>            <span class="hljs-keyword">throws</span> ServletException, IOException &#123;<br>        System.out.println(<span class="hljs-string">&quot;ee&quot;</span>);<br>        doGet(req,resp);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<p>创建 Servlet 的第三种方法，也是我们经常用的方法。</p>
<p>详细讲解一下第三种方式,继承 Httpservlet的方式</p>
<h3 id="实现Servlet规范"><a href="#实现Servlet规范" class="headerlink" title="实现Servlet规范"></a>实现Servlet规范</h3><p>实现 Servlet 规范，即继承 HttpServlet 类，并到如响应的包，该类中已经完成了通信的规则，我们只 需要进行业务的实现即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@WebServlet(&quot;/ser01&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ServletDemo3</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">HttpServlet</span> &#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doGet</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span><br>            <span class="hljs-keyword">throws</span> ServletException, IOException &#123;<br>        System.out.println(<span class="hljs-string">&quot;haha&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doPost</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span><br>            <span class="hljs-keyword">throws</span> ServletException, IOException &#123;<br>        System.out.println(<span class="hljs-string">&quot;ee&quot;</span>);<br>        doGet(req,resp);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="重写Service方法"><a href="#重写Service方法" class="headerlink" title="重写Service方法"></a>重写Service方法</h3><p>满足 Servlet 规范只是让我们的类能够满足接收请求的要求，接收到请求后需要对请求进行分析，以 及进行业务逻辑处理，计算出结果，则需要添加代码，在规范中有一个叫做 service的方法，专门用来做 请求处理的操作，业务代码则可以写在该方法中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java">HttpServlet <span class="hljs-keyword">extends</span> <span class="hljs-title class_">GenderServlet</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">service</span><span class="hljs-params">(ServletRequest,ServletResponse)</span> <span class="hljs-comment">//生命周期方法</span><br>    <span class="hljs-comment">//强调两个参数为http协议相关的类型，</span><br>    <span class="hljs-comment">//调用本来的servlet(HttpServletRequest,HttpServletResponse)</span><br>        <br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">service</span><span class="hljs-params">(HttpServletRequest,HttpServletResponse)</span><span class="hljs-comment">//参数已经是Http协议相关的，使用起来更加方便。</span><br>    <span class="hljs-comment">//它会通过request得到当前请求的请求方式，例如：GET或POST</span><br>    <span class="hljs-comment">//根据请求方式再调用doGet()或doPost()方法</span><br>        <br>     <span class="hljs-keyword">void</span> <span class="hljs-title function_">doGet</span><span class="hljs-params">(...)</span>  <span class="hljs-comment">//重写</span><br>     <span class="hljs-keyword">void</span> <span class="hljs-title function_">doPsot</span><span class="hljs-params">(...)</span> <span class="hljs-comment">//重写</span><br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="设置注解"><a href="#设置注解" class="headerlink" title="设置注解"></a>设置注解</h3><p>我一般直接抛弃使用web.xml配置servlet的这一种方式,直接使用注解配置会方便很多.开发servlet项目，使用@WebServlet将一个继承于javax.servlet.http.HttpServlet 的类定义为Servlet 组件。在Servlet3.0中 ， 可以使用@WebServlet注解将一个继承于javax.servlet.http.HttpServlet的类 标注为可以处理用户请求的 Servlet。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@WebServlet(name=&quot;Servlet01&quot;,value=&quot;/ser01&quot;)</span> <span class="hljs-comment">//后面的参数代表网址(访问路径例如localhost:8080/Servlet01/ser01)</span><br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@WebServlet(name=&quot;Servlet01&quot;,urlPatterns = &quot;/ser01&quot;)</span> <span class="hljs-comment">//后面的参数代表网址(访问路径例如localhost:8080/Servlet01/ser01)</span><br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@WebServlet(name=&quot;Servlet01&quot;,value=&#123;&quot;/ser01&quot;,&#x27;/ser001&#x27;&#125;)</span> <span class="hljs-comment">//后面的参数代表网址(访问路径例如localhost:8080/Servlet01/ser01)</span><br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@WebServlet(name=&quot;Servlet01&quot;,urlPatterns=&#123;&quot;/ser01&quot;,&#x27;/ser001&#x27;&#125;)</span><span class="hljs-comment">//后面的参数代表网址(访问路径例如localhost:8080/Servlet01/ser01)</span><br></code></pre></td></tr></table></figure>

<h3 id="Servlet生命周期"><a href="#Servlet生命周期" class="headerlink" title="Servlet生命周期"></a>Servlet生命周期</h3><p><strong>Servlet 的生命周期，简单的概括这就分为四步：servlet 类加载–&gt;实例化–&gt;服务–&gt;销毁。</strong></p>
<p><strong>1.Web Client向Servlet容器(Tomcat)发出Http请求</strong></p>
<p><strong>2.Servlet容器接收Web Client的请求</strong></p>
<p><strong>3.Servlet容器创建一个HttpServletRequest对象，将Web Client请求的信息封装到这个对象中</strong></p>
<p><strong>4.Servlet容器创建一个HttpServletResponse对象</strong></p>
<p><strong>5.Servlet容器调HttpServlet对象service方法，把Request与Response作为参数，传给HttpServlet</strong></p>
<p><strong>6.HttpServlet调用HttpServletRequest对象的有关方法，获取Http请求信息</strong></p>
<p><strong>7.HttpServlet调用HttpServletResponse对象的有关方法，生成响应数据</strong></p>
<p><strong>8.Servlet容器把HttpServlet的响应结果传给Web Client</strong></p>
<ul>
<li>void init(ServletConfig)：出生之后（1次）</li>
<li>void service(ServiceRequest request,ServletResponse response)：每次处理请求时都会被调用；&#x2F;&#x2F;通常我们extends HttpServlet,参数类型也会改成HttpRequest(HttpResponse)</li>
<li>void destroy()：临死之前（1次）；</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@WebServlet(name=&quot;AServlet&quot;,value=&quot;/ser01&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AServlet</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Servlet</span> &#123;    <br><span class="hljs-comment">//它是生命周期方法</span><br>	 <span class="hljs-comment">//它会在Servlet被销毁之前调用，并且它只会被调用一次！</span><br>	<span class="hljs-meta">@Override</span><br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">destroy</span><span class="hljs-params">()</span> &#123;<br>		System.out.println(<span class="hljs-string">&quot;destory()...&quot;</span>);<br>	&#125;<br>	<span class="hljs-comment">//可以用来获取Servlet的配置信息 </span><br>	<span class="hljs-meta">@Override</span><br>	<span class="hljs-keyword">public</span> ServletConfig <span class="hljs-title function_">getServletConfig</span><span class="hljs-params">()</span> &#123;<br>		System.out.println(<span class="hljs-string">&quot;getServletConfig()...&quot;</span>);<br>		<span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>	&#125;<br>	<span class="hljs-comment">//获取Servlet的信息(用户调用，基本没用)</span><br>	<span class="hljs-meta">@Override</span><br>	<span class="hljs-keyword">public</span> String <span class="hljs-title function_">getServletInfo</span><span class="hljs-params">()</span> &#123;<br>		System.out.println(<span class="hljs-string">&quot;getServletInfo()...&quot;</span>);<br>		<span class="hljs-keyword">return</span> <span class="hljs-string">&quot;我是一个快乐的Servlet&quot;</span>;<br>	&#125;<br>	 <span class="hljs-comment">//它是生命周期方法</span><br>	 <span class="hljs-comment">//它会在Servlet对象创建之后马上执行，并且只执行一次！（出生之后）</span><br>	<span class="hljs-meta">@Override</span><br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">(ServletConfig servletConfig)</span> <span class="hljs-keyword">throws</span> ServletException &#123;<br>		System.out.println(<span class="hljs-string">&quot;init()...&quot;</span>);<br>	&#125;<br>	 <span class="hljs-comment">//它是生命周期方法</span><br>	 <span class="hljs-comment">//它会被调用多次</span><br>	 <span class="hljs-comment">//每次处理请求都是在调用这个方法</span><br>	<span class="hljs-meta">@Override</span><br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">service</span><span class="hljs-params">(ServletRequest request, ServletResponse response)</span> <span class="hljs-keyword">throws</span> ServletException, IOException &#123;<br>		System.out.println(<span class="hljs-string">&quot;service()...&quot;</span>);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--你也可以使用web.xml方式配置,我是感觉这种方式不好--&gt;</span><br><span class="hljs-comment">&lt;!--web.xml--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">servlet</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>aservlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">servlet-class</span>&gt;</span>com.edu.cn.AServlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-class</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">servlet</span>&gt;</span><br>  <br>  <span class="hljs-tag">&lt;<span class="hljs-name">servlet-mapping</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>aservlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/AServlet<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">servlet-mapping</span>&gt;</span><br><span class="hljs-comment">&lt;!--也可以在类中加@WebServlet(&quot;/AServlet&quot;)来设置--&gt;</span><br></code></pre></td></tr></table></figure>

<p><strong>特性：</strong></p>
<ul>
<li>单例，一个类只有一个对象；当然可能存在多个Servlet类</li>
<li>线程不安全的，所以它的效率是高的</li>
</ul>
<p>**注：Servlet类由我们来写，但对象由服务器来创建，并且有服务器来调用相应的方法。</p>
<h3 id="Servlet工作流程"><a href="#Servlet工作流程" class="headerlink" title="Servlet工作流程"></a>Servlet工作流程</h3><p><strong>1.通过请求头获知浏览器访问的是哪个主机</strong></p>
<p><strong>2.再通过请求行获取访问的是哪个一个web应用</strong></p>
<p><strong>3.再通过请求行中的请求路径获知访问的是哪个资源</strong></p>
<p><strong>4.通过获取的资源路径在配置中匹配到真实的路径，</strong></p>
<p><strong>5.服务器会创建servlety对象，（如果是第一次访问时，创建servlet:实例，并调用init方法进行初始化操作)</strong></p>
<p><strong>6.调用service(request,response)方法来处理请求和响应的操作</strong></p>
<p><strong>7.调用service:完毕后返回服务器由服务器讲response缓冲区的数据取出，以http响应的格式发送给浏览器</strong></p>
<h2 id="HttpServletRequset对象"><a href="#HttpServletRequset对象" class="headerlink" title="HttpServletRequset对象"></a>HttpServletRequset对象</h2><p>ttpServletRequest 对象：主要作用是用来接收客户端发送过来的请求信息，例如：请求的参数，发 送的头信息等都属于客户端发来的信息，service()方法中形参接收的是 HttpServletRequest 接口的实例 化对象，表示该对象主要应用在 HTTP 协议上，该对象是由 Tomcat 封装好传递过来。</p>
<p>HttpServletRequest 是 ServletRequest 的子接口，ServletRequest 只有一个子接口，就是 HttpServletRequest。既然只有一个子接口为什么不将两个接口合并为一个？</p>
<p>从长远上讲：现在主要用的协议是 HTTP 协议，但以后可能出现更多新的协议。若以后想要支持这种 新协议，只需要直接继承 ServletRequest 接口就行了。</p>
<p>在 HttpServletRequest 接口中，定义的方法很多，<strong>但都是围绕接收客户端参数的</strong>。但是怎么拿到该对象呢？不需要，直接在 Service 方法中由容器传入过来，而我们需要做的就是取出对象中的数据，进行 分析、处理。</p>
<h3 id="1-常用方法"><a href="#1-常用方法" class="headerlink" title="1.常用方法"></a><strong>1.常用方法</strong></h3><table>
<thead>
<tr>
<th>返回值类型</th>
<th>方法声明</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>String</td>
<td>getMethod()</td>
<td>该方法用于获取 HTTP 请求方式（如 GET、POST 等）。</td>
</tr>
<tr>
<td>String</td>
<td>getRequestURI()</td>
<td>该方法用于获取请求行中的资源名称部分，即位于 URL 的主机和端口之后，参数部分之前的部分。</td>
</tr>
<tr>
<td>String</td>
<td>getQueryString()</td>
<td>该方法用于获取请求行中的参数部分，也就是 URL 中“?”以后的所有内容。</td>
</tr>
<tr>
<td>String</td>
<td>getContextPath()</td>
<td>返回当前 Servlet 所在的应用的名字（上下文）。对于默认（ROOT）上下文中的 Servlet，此方法返回空字符串””。</td>
</tr>
<tr>
<td>String</td>
<td>getServletPath()</td>
<td>该方法用于获取 Servlet 所映射的路径。</td>
</tr>
<tr>
<td>String</td>
<td>getRemoteAddr()</td>
<td>该方法用于获取客户端的 IP 地址。</td>
</tr>
<tr>
<td>String</td>
<td>getRemoteHost()</td>
<td>该方法用于获取客户端的完整主机名，如果无法解析出客户机的完整主机名，则该方法将会返回客户端的 IP 地址。</td>
</tr>
</tbody></table>
<p><strong>示例 1</strong></p>
<p>为了更好地理解这些方法，下面通过案例演示这些方法的使用。</p>
<p>创建一个名称为 httpServletRequestDemo 的项目，在 net.biancheng.www 包中创建一个名为 RequestLine 的 Servlet 类，代码如下。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> net.biancheng.www;<br><br><span class="hljs-keyword">import</span> java.io.IOException;<br><span class="hljs-keyword">import</span> java.io.PrintWriter;<br><br><span class="hljs-keyword">import</span> javax.servlet.ServletException;<br><span class="hljs-keyword">import</span> javax.servlet.annotation.WebServlet;<br><span class="hljs-keyword">import</span> javax.servlet.http.HttpServlet;<br><span class="hljs-keyword">import</span> javax.servlet.http.HttpServletRequest;<br><span class="hljs-keyword">import</span> javax.servlet.http.HttpServletResponse;<br><br><br><span class="hljs-meta">@WebServlet(&quot;/RequestLine&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RequestLine</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">HttpServlet</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">serialVersionUID</span> <span class="hljs-operator">=</span> <span class="hljs-number">1L</span>;<br><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doGet</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="hljs-keyword">throws</span> ServletException, IOException &#123;<br>        response.setContentType(<span class="hljs-string">&quot;text/html;charset=UTF-8&quot;</span>);<br>        <span class="hljs-type">PrintWriter</span> <span class="hljs-variable">writer</span> <span class="hljs-operator">=</span> response.getWriter();<br>        writer.println(<span class="hljs-string">&quot;请求方式:&quot;</span> + request.getMethod() + <span class="hljs-string">&quot;&lt;br/&gt;&quot;</span> +<br>                <span class="hljs-string">&quot;客户端的 IP 地址:&quot;</span> + request.getRemoteAddr() + <span class="hljs-string">&quot;&lt;br/&gt;&quot;</span> +<br>                <span class="hljs-string">&quot;应用名字（上下文）:&quot;</span> + request.getContextPath() + <span class="hljs-string">&quot;&lt;br/&gt;&quot;</span> +<br>                <span class="hljs-string">&quot;URI:&quot;</span> + request.getRequestURI() + <span class="hljs-string">&quot;&lt;br/&gt;&quot;</span> +<br>                <span class="hljs-string">&quot;请求字符串:&quot;</span> + request.getQueryString() + <span class="hljs-string">&quot;&lt;br/&gt;&quot;</span> +<br>                <span class="hljs-string">&quot;Servlet所映射的路径:&quot;</span> + request.getServletPath() + <span class="hljs-string">&quot;&lt;br/&gt;&quot;</span> +<br>                <span class="hljs-string">&quot;客户端的完整主机名:&quot;</span> + request.getRemoteHost() + <span class="hljs-string">&quot;&lt;br/&gt;&quot;</span><br>        );<br>    &#125;<br><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doPost</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="hljs-keyword">throws</span> ServletException, IOException &#123;<br>        doGet(request, response);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>



<p><img src="https://gcore.jsdelivr.net/gh/fuchajun/blogImgs/img/202208021003569.png" srcset="/img/loading.gif" lazyload></p>
<h3 id="获取-form-表单的数据"><a href="#获取-form-表单的数据" class="headerlink" title="获取 form 表单的数据"></a><strong>获取 form 表单的数据</strong></h3><p>在实际开发中，我们经常需要获取用户提交的表单数据，例如用户名和密码等。为了方便获取表单中的请求参数，ServletRequest 定义了一系列获取请求参数的方法，如下表所示。</p>
<table>
<thead>
<tr>
<th>返回值类型</th>
<th>方法声明</th>
<th>功能描述</th>
</tr>
</thead>
<tbody><tr>
<td>String</td>
<td>getParameter(String name)</td>
<td>返回指定参数名的参数值。</td>
</tr>
<tr>
<td>String [ ]</td>
<td>getParameterValues (String name)</td>
<td>以字符串数组的形式返回指定参数名的所有参数值（HTTP 请求中可以有多个相同参数名的参数）。</td>
</tr>
<tr>
<td>Enumeration</td>
<td>getParameterNames()</td>
<td>以枚举集合的形式返回请求中所有参数名。</td>
</tr>
<tr>
<td>Map</td>
<td>getParameterMap()</td>
<td>用于将请求中的所有参数名和参数值装入一个 Map 对象中返回。</td>
</tr>
</tbody></table>
<p><strong>示例 3</strong></p>
<p>为了更好地理解这些方法，下面通过案例演示这些方法的使用。</p>
<p>在 httpServletRequestDemo 的 WebContent 目录下，创建 form.html，代码如下。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Insert title here<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">action</span>=<span class="hljs-string">&quot;/httpServletRequestDemo/RequestParam&quot;</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;post&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">table</span> <span class="hljs-attr">border</span>=<span class="hljs-string">&quot;1&quot;</span> <span class="hljs-attr">width</span>=<span class="hljs-string">&quot;50%&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">colspan</span>=<span class="hljs-string">&quot;2&quot;</span> <span class="hljs-attr">align</span>=<span class="hljs-string">&quot;center&quot;</span>&gt;</span>编程帮wwww.biancheng.net<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>输入姓名<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;username&quot;</span> /&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>输入密码<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;password&quot;</span> /&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>选择性别<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;radio&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;sex&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;male&quot;</span> /&gt;</span>男 <span class="hljs-tag">&lt;<span class="hljs-name">input</span></span><br><span class="hljs-tag">                    <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;radio&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;sex&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;female&quot;</span> /&gt;</span>女<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>选择使用的语言<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;checkbox&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;language&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;JAVA&quot;</span> /&gt;</span>JAVA<br>                    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;checkbox&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;language&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;C&quot;</span> /&gt;</span>C语言 <span class="hljs-tag">&lt;<span class="hljs-name">input</span></span><br><span class="hljs-tag">                    <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;checkbox&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;language&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;PHP&quot;</span> /&gt;</span>PHP <span class="hljs-tag">&lt;<span class="hljs-name">input</span></span><br><span class="hljs-tag">                    <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;checkbox&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;language&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;Python&quot;</span> /&gt;</span>Python<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>选择城市<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;city&quot;</span>&gt;</span><br>                        <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;none&quot;</span>&gt;</span>--请选择--<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span><br>                        <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;beijing&quot;</span>&gt;</span>北京<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span><br>                        <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;shanghai&quot;</span>&gt;</span>上海<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span><br>                        <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;guangzhou&quot;</span>&gt;</span>广州<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span><br>                <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">colspan</span>=<span class="hljs-string">&quot;2&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;提交&quot;</span> /&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">table</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>在 net.biancheng.www 包中，创建一个名为 RequestParam 的 Servlet 类，代码如下。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> net.biancheng.www;<br><br><span class="hljs-keyword">import</span> java.io.IOException;<br><span class="hljs-keyword">import</span> java.io.PrintWriter;<br><span class="hljs-keyword">import</span> java.util.Arrays;<br><span class="hljs-keyword">import</span> java.util.Map;<br><span class="hljs-keyword">import</span> java.util.Set;<br><span class="hljs-keyword">import</span> javax.servlet.ServletException;<br><span class="hljs-keyword">import</span> javax.servlet.annotation.WebServlet;<br><span class="hljs-keyword">import</span> javax.servlet.http.HttpServlet;<br><span class="hljs-keyword">import</span> javax.servlet.http.HttpServletRequest;<br><span class="hljs-keyword">import</span> javax.servlet.http.HttpServletResponse;<br><br><span class="hljs-meta">@WebServlet(&quot;/RequestParam&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RequestParam</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">HttpServlet</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">serialVersionUID</span> <span class="hljs-operator">=</span> <span class="hljs-number">1L</span>;<br><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doGet</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span><br>            <span class="hljs-keyword">throws</span> ServletException, IOException &#123;<br>        response.setContentType(<span class="hljs-string">&quot;text/html;charset=UTF-8&quot;</span>);<br>        <span class="hljs-type">PrintWriter</span> <span class="hljs-variable">writer</span> <span class="hljs-operator">=</span> response.getWriter();<br>        <span class="hljs-comment">// 获取内容，做其他操作</span><br>        <span class="hljs-comment">// 获取姓名</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">username</span> <span class="hljs-operator">=</span> request.getParameter(<span class="hljs-string">&quot;username&quot;</span>);<br>        <span class="hljs-comment">// 获取密码</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">password</span> <span class="hljs-operator">=</span> request.getParameter(<span class="hljs-string">&quot;password&quot;</span>);<br>        <span class="hljs-comment">// 获取性别</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">sex</span> <span class="hljs-operator">=</span> request.getParameter(<span class="hljs-string">&quot;sex&quot;</span>);<br>        <span class="hljs-comment">// 获取城市</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">city</span> <span class="hljs-operator">=</span> request.getParameter(<span class="hljs-string">&quot;city&quot;</span>);<br>        <span class="hljs-comment">// 获取语言</span><br>        String[] languages = request.getParameterValues(<span class="hljs-string">&quot;language&quot;</span>);<br>        writer.write(<span class="hljs-string">&quot;用户名：&quot;</span> + username + <span class="hljs-string">&quot;&lt;br/&gt;&quot;</span> + <span class="hljs-string">&quot;密码：&quot;</span> + password + <span class="hljs-string">&quot;&lt;br/&gt;&quot;</span> + <span class="hljs-string">&quot;性别：&quot;</span> + sex + <span class="hljs-string">&quot;&lt;br/&gt;&quot;</span> + <span class="hljs-string">&quot;城市：&quot;</span> + city<br>                + <span class="hljs-string">&quot;&lt;br/&gt;&quot;</span> + <span class="hljs-string">&quot;使用过的语言：&quot;</span> + Arrays.toString(languages) + <span class="hljs-string">&quot;&lt;br/&gt;&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doPost</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span><br>            <span class="hljs-keyword">throws</span> ServletException, IOException &#123;<br>        doGet(request, response);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>启动 Tomcat 服务器，在地址栏中输入“<a target="_blank" rel="noopener" href="http://localhost:8080/httpServletRequestDemo/form.html%E2%80%9D%EF%BC%8C%E5%8D%B3%E5%8F%AF%E8%AE%BF%E9%97%AE">http://localhost:8080/httpServletRequestDemo/form.html”，即可访问</a> form.html，结果如下图。</p>
<p><img src="https://gcore.jsdelivr.net/gh/fuchajun/blogImgs/img/202208021004375.png" srcset="/img/loading.gif" lazyload></p>
<p>在表单中填写信息后，点击提交，结果如下图。</p>
<p><img src="https://gcore.jsdelivr.net/gh/fuchajun/blogImgs/img/202208021004870.png" srcset="/img/loading.gif" lazyload></p>
<h3 id="请求乱码"><a href="#请求乱码" class="headerlink" title="请求乱码"></a>请求乱码</h3><p>解决请求乱码的前提是我们必须要明白为什么会产生乱码,由于现在的 request 属于接收客户端的参数，所以必然有其默认的语言编码，主要是由于在解析过程 中默认使用的编码方式为 ISO-8859-1(此编码不支持中文)，所以解析时一定会出现乱码。要想解决这种 乱码问题，需要设置 request 中的编码方式，告诉服务器以何种方式来解析数据。或者在接收到乱码数 据以后，再通过相应的编码格式还原。</p>
<p>还有一点我们要了解,Tomcat8起，以后的GET方式请求是不会出现乱码的,言外之意,POST请求是可能出现乱码的.</p>
<p>方式一： </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">request.setCharacterEncoding(<span class="hljs-string">&quot;UTF-8&quot;</span>);<br></code></pre></td></tr></table></figure>

<p>这种方式只针对 POST 有效（必须在接收所有的数据之前设定） </p>
<p>方式二：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(request.getParameter(name).getBytes(<span class="hljs-string">&quot;ISO-8859-1&quot;</span>),<span class="hljs-string">&quot;UTF-8&quot;</span>);<br></code></pre></td></tr></table></figure>

<p>借助了String 对象的方法，该种方式对任何请求有效，是通用的</p>
<h3 id="请求转发"><a href="#请求转发" class="headerlink" title="请求转发"></a>请求转发</h3><p>请求转发，是一种服务器的行为，当客户端请求到达后，服务器进行转发，此时会将请求对象进行保 存，地址栏中的 URL 地址不会改变，得到响应后，服务器端再将响应发送给客户端，从始至终只有一个 请求发出。</p>
<p>实现方式如下，达到多个资源协同响应的效果。</p>
<figure class="highlight vbscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vbscript"><span class="hljs-built_in">request</span>.getRequestDispatcher(url).forward(<span class="hljs-built_in">request</span>,<span class="hljs-built_in">response</span>);<br></code></pre></td></tr></table></figure>



<h3 id="Request作用域"><a href="#Request作用域" class="headerlink" title="Request作用域"></a>Request作用域</h3><p>通过该对象可以在一个请求中传递数据，作用范围：在一次请求中有效，即服务器跳转有效。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 设置域对象内容</span><br>request.setAttribute(String name, String value);<br><span class="hljs-comment">// 获取域对象内容</span><br>request.getAttribute(String name);<br><span class="hljs-comment">// 删除域对象内容</span><br>request.removeAttribute(String name)<br></code></pre></td></tr></table></figure>

<p>request 域对象中的数据在一次请求中有效，则经过请求转发，request 域中的数据依然存在，则在 请求转发的过程中可以通过 request 来传输&#x2F;共享数据。</p>
<h2 id="HttpServletResponse对象"><a href="#HttpServletResponse对象" class="headerlink" title="HttpServletResponse对象"></a>HttpServletResponse对象</h2><p>在 Servlet API 中，定义了一个 HttpServletResponse 接口，它继承自 ServletResponse 接口。HttpServletResponse 对象专门用来封装 HTTP 响应消息，简称 response 对象。</p>
<p>Servlet 容器会针对每次请求创建一个 response 对象，并把它作为参数传递给 Servlet 的 service 方法。Servlet 处理请求后，会将响应信息封装到 response 对象中，并由容器解析后返回给客户端。</p>
<p>由于 HTTP 响应消息由响应行、响应头、消息体三部分组成，所以 HttpServletResponse 接口中定义了向客户端发送响应状态码、响应头、响应体的方法，下面我们将针对这些方法进行介绍。</p>
<h3 id="响应行相关的方法"><a href="#响应行相关的方法" class="headerlink" title="响应行相关的方法"></a>响应行相关的方法</h3><p>当 Servlet 返回响应消息时，需要在响应消息中设置状态码。因此，HttpServletResponse 接口定义了发送状态码的方法，如下表。</p>
<table>
<thead>
<tr>
<th>返回值类型</th>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>void</td>
<td>setStatus（int status）</td>
<td>用于设置 HTTP 响应消息的状态码，并生成响应状态行。</td>
</tr>
<tr>
<td>void</td>
<td>sendError（int sc）</td>
<td>用于发送表示错误信息的状态码。</td>
</tr>
</tbody></table>
<h3 id="响应头相关的方法"><a href="#响应头相关的方法" class="headerlink" title="响应头相关的方法"></a>响应头相关的方法</h3><p>HttpServletResponse 接口中定义了一系列设置 HTTP 响应头字段的方法，如下表所示。</p>
<table>
<thead>
<tr>
<th>返回值类型</th>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>void</td>
<td>addHeader(String name,String value)</td>
<td>用于增加响应头字段，其中，参数 name 用于指定响应头字段的名称，参数 value 用于指定响应头字段的值。</td>
</tr>
<tr>
<td>void</td>
<td>setHeader (String name,String value)</td>
<td>用于设置响应头字段，其中，参数 name 用于指定响应头字段的名称，参数 value 用于指定响应头字段的值。</td>
</tr>
<tr>
<td>void</td>
<td>addIntHeader(String name,int value)</td>
<td>用于增加值为 int 类型的响应头字段，其中，参数 name 用于指定响应头字段的名称，参数 value 用于指定响应头字段的值，类型为 int。</td>
</tr>
<tr>
<td>void</td>
<td>setIntHeader(String name, int value)</td>
<td>用于设置值为 int 类型的响应头字段，其中，参数 name 用于指定响应头字段的名称，参数 value 用于指定响应头字段的值，类型为 int。</td>
</tr>
<tr>
<td>void</td>
<td>setContentType(String type)</td>
<td>用于设置 Servlet 输出内容的 MIME 类型以及编码格式。</td>
</tr>
<tr>
<td>void</td>
<td>setCharacterEncoding(String charset)</td>
<td>用于设置输出内容使用的字符编码。</td>
</tr>
</tbody></table>
<h3 id="响应体相关的方法"><a href="#响应体相关的方法" class="headerlink" title="响应体相关的方法"></a>响应体相关的方法</h3><p>由于在 HTTP 响应消息中，大量的数据都是通过响应消息体传递的。因此 ServletResponse 遵循以 I&#x2F;O 流传递大量数据的设计理念，在发送响应消息体时，定义了两个与输出流相关的方法。</p>
<table>
<thead>
<tr>
<th>返回值类型</th>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>ServletOutputStream</td>
<td>getOutputStream()</td>
<td>用于获取字节输出流对象。</td>
</tr>
<tr>
<td>PrintWriter</td>
<td>getWriter()</td>
<td>用于获取字符输出流对象。</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//注意：getOutputStream() 和 getWriter() 方法互相排斥，不可同时使用，否则会发生 IllegalStateException 异常。</span><br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">*</span><br><span class="hljs-comment">* <span class="hljs-doctag">@author</span> 编程帮 www.biancheng.net 使用response对象向页面输出内容</span><br><span class="hljs-comment">*</span><br><span class="hljs-comment">*/</span><br><span class="hljs-meta">@WebServlet(&quot;/OutServlet&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OutServlet</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">HttpServlet</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">serialVersionUID</span> <span class="hljs-operator">=</span> <span class="hljs-number">1L</span>;<br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doGet</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span><br>            <span class="hljs-keyword">throws</span> ServletException, IOException &#123;<br>        run1(response);<br>        <span class="hljs-comment">// run2(response);</span><br>    &#125;<br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doPost</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span><br>            <span class="hljs-keyword">throws</span> ServletException, IOException &#123;<br>        doGet(request, response);<br>    &#125;<br>    <span class="hljs-comment">// 使用字符流向页面输出</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run2</span><span class="hljs-params">(HttpServletResponse response)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        response.getWriter().write(<span class="hljs-string">&quot;编程帮 www.biancheng.net&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">// 使用字节流向页面输出</span><br>    <span class="hljs-comment">// 使用字节流向页面输出</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run1</span><span class="hljs-params">(HttpServletResponse response)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-comment">// 设置浏览器打开文件时编码</span><br>        response.setHeader(<span class="hljs-string">&quot;Content-Type&quot;</span>, <span class="hljs-string">&quot;text/html;charset=UTF-8&quot;</span>);<br>        <span class="hljs-comment">// 获取字节输出流</span><br>        <span class="hljs-type">OutputStream</span> <span class="hljs-variable">os</span> <span class="hljs-operator">=</span> response.getOutputStream();<br>        <span class="hljs-type">byte</span>[] str = <span class="hljs-string">&quot;编程帮 www.biancheng.net&quot;</span>.getBytes(<span class="hljs-string">&quot;UTF-8&quot;</span>);<br>        <span class="hljs-comment">// 输出中文</span><br>        os.write(str);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>启动 Tomat 服务器，在客户端浏览器地址栏输入“<a target="_blank" rel="noopener" href="http://localhost:8080/responseDemo/OutServlet%E2%80%9D%E8%AE%BF%E9%97%AE">http://localhost:8080/responseDemo/OutServlet”访问</a> OutServlet，结果如下图。</p>
<p><img src="https://gcore.jsdelivr.net/gh/fuchajun/blogImgs/img/202208021004955.png" srcset="/img/loading.gif" lazyload></p>
<p>在 doGet() 方法中调用 run2() 方法，使用字符流输出响应内容到浏览器，再次访问 OutServlet，结果如下图。</p>
<p><img src="https://gcore.jsdelivr.net/gh/fuchajun/blogImgs/img/202208021004647.png" srcset="/img/loading.gif" lazyload></p>
<h3 id="response-中文乱码问题"><a href="#response-中文乱码问题" class="headerlink" title="response 中文乱码问题"></a>response 中文乱码问题</h3><p>response 对象向页面输出时有两种方式：字节流、字符流，这两种方式输出中文时都有可能出现乱码。下面我们针对这两种方式出现乱码的原因以及解决方案进行介绍。</p>
<h4 id="使用字节流输出中文"><a href="#使用字节流输出中文" class="headerlink" title="使用字节流输出中文"></a>使用字节流输出中文</h4><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">ServletOutputStream outptuStream <span class="hljs-operator">=</span> response.getOutputStream()<span class="hljs-comment">;outputStream.write(“编程帮 www.biancheng.net”.getBytes());</span><br></code></pre></td></tr></table></figure>


<p>使用字节流向页面输出中文是否会出现乱码问题？不一定。</p>
<h4 id="乱码原因："><a href="#乱码原因：" class="headerlink" title="乱码原因："></a>乱码原因：</h4><p>字节流输出中文是否出现乱码，取决于中文转成字节数组时与浏览器打开时采用的字符集是否一致。若两者保持一致，则不会出现乱码问题，若不一致就会出现乱码问题。</p>
<h4 id="解决方案："><a href="#解决方案：" class="headerlink" title="解决方案："></a>解决方案：</h4><p>将中文转成字节数组时和浏览器默认采用的字符集保持一致即可，代码如下。</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">response.setHeader(<span class="hljs-string">&quot;Content-Type&quot;</span>, <span class="hljs-string">&quot;text/html;charset=UTF-8&quot;</span>);<span class="hljs-regexp">//</span> 获取字节输出流OutputStream os = response.getOutputStream();byte[] str = <span class="hljs-string">&quot;编程帮 www.biancheng.net&quot;</span>.getBytes(<span class="hljs-string">&quot;UTF-8&quot;</span>);<span class="hljs-regexp">//</span> 输出中文os.write(str);<br></code></pre></td></tr></table></figure>

<h4 id="使用字符流输出中文"><a href="#使用字符流输出中文" class="headerlink" title="使用字符流输出中文"></a>使用字符流输出中文</h4><p>使用字符流向页面输出中文是否会出现乱码问题？一定乱码。</p>
<h4 id="乱码原因：-1"><a href="#乱码原因：-1" class="headerlink" title="乱码原因："></a>乱码原因：</h4><p>通过字符流输出的内容是存放在 response 缓冲区的，response 缓冲区的默认字符集是 ISO-8859-1，该字符集不支持中文。</p>
<h4 id="解决方案：-1"><a href="#解决方案：-1" class="headerlink" title="解决方案："></a>解决方案：</h4><p>将 response 缓冲区和浏览器采用的字符集保持一致即可，有如下 2 种的方式。</p>
<p>第一种方式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 设置response缓冲区的编码response.setCharacterEncoding(&quot;UTF-8&quot;);// 设置浏览器打开文件所采用的编码response.setHeader(&quot;Content-Type&quot;, &quot;text/html;charset=UTF-8&quot;);// 输出中文response.getWriter().write(&quot;编程帮 www.biancheng.net&quot;);</span><br></code></pre></td></tr></table></figure>


<p>第二种方式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">纯文本复制<br>response.setContentType(<span class="hljs-string">&quot;text/html;charset=UTF-8&quot;</span>);response.getWriter().write(<span class="hljs-string">&quot;编程帮 www.biancheng.net&quot;</span>);<br></code></pre></td></tr></table></figure>

<h2 id=""><a href="#" class="headerlink" title=""></a></h2><h2 id="会话技术-Cookie对象"><a href="#会话技术-Cookie对象" class="headerlink" title="会话技术(Cookie对象)"></a>会话技术(Cookie对象)</h2><p>从打开浏览器访问某个网站，到关闭浏览器的过程，称为一次会话。会话技术是指在会话中，帮助服务器记录用户状态和数据的技术。</p>
<p>常用的会话技术分为两种：</p>
<ol>
<li>Cookie ：客户端会话技术</li>
<li>Session ：服务端会话技术</li>
</ol>
<p>本节将对 Cookie 进行介绍，下节将对 Session 进行介绍。</p>
<p>Cookie是浏览器提供的一种技术，通过服务器的程序能将一些只须保存在客户端，或者在客户端进行 处理的数据，放在本地的计算机上，不需要通过网络传输，因而提高网页处理的效率，并且能够减少服 务器的负载，但是由于 Cookie 是服务器端保存在客户端的信息， 所以其安全性也是很差的。例如常见 的记住密码则可以通过 Cookie 来实现。</p>
<h3 id="Cookie-的分类"><a href="#Cookie-的分类" class="headerlink" title="Cookie 的分类"></a>Cookie 的分类</h3><p>Cookie分为两种：</p>
<ol>
<li>会话级别 Cookie（默认）：Cookie 保存到浏览器的内存中，浏览器关闭则 Cookie 失效。</li>
<li>持久的 Cookie：Cookie 以文本文件的形式保存到硬盘上。</li>
</ol>
<h3 id="Cookie-API"><a href="#Cookie-API" class="headerlink" title="Cookie API"></a>Cookie API</h3><p>javax.servlet.http 包中定义了一个 Cookie 类，利用它的带参构造方法，可以创建 Cookie 对象。例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Cookie</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Cookie</span>(<span class="hljs-string">&quot;url&quot;</span>, <span class="hljs-string">&quot;www.biancheng.net&quot;</span>); <br></code></pre></td></tr></table></figure>

<p>其中参数 name 为 Cookie 的名称，参数 value 为 Cookie 的值，name 与 value 的取值不能包含 <code>[ ] ( ) = , &quot; / ? @ : ;</code>等字符</p>
<p><strong>HttpServletResponse 接口和 HttpServletRequest 接口也都定义了与 Cookie 相关的方法，如下表所示。</strong></p>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
<th>所属接口</th>
</tr>
</thead>
<tbody><tr>
<td>void addCookie(Cookie cookie)</td>
<td>用于在响应头中增加一个相应的 Set-Cookie 头字段。</td>
<td>javax.servlet.http.HttpServletResponse</td>
</tr>
<tr>
<td>Cookie[] getCookies()</td>
<td>用于获取客户端提交的 Cookie。</td>
<td>javax.servlet.http.HttpServletRequest</td>
</tr>
</tbody></table>
<p>javax.servlet.http.Cookie 类中提供了一系列</p>
<h3 id="获取或者设置-Cookie-的方法"><a href="#获取或者设置-Cookie-的方法" class="headerlink" title="获取或者设置 Cookie 的方法"></a>获取或者设置 Cookie 的方法</h3><p>，如下表。</p>
<table>
<thead>
<tr>
<th>返回值类型</th>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>int</td>
<td>getMaxAge()</td>
<td>用于获取指定 Cookie 的最大有效时间，以秒为单位。 默认情况下取值为 -1，表示该 Cookie 保留到浏览器关闭为止。</td>
</tr>
<tr>
<td>String</td>
<td>getName()</td>
<td>用于获取 Cookie 的名称。</td>
</tr>
<tr>
<td>String</td>
<td>getPath()</td>
<td>用于获取 Cookie 的有效路径。</td>
</tr>
<tr>
<td>boolean</td>
<td>getSecure()</td>
<td>如果浏览器只通过安全协议发送 Cookie，则返回 true；如果浏览器可以使用任何协议发送 Cookie，则返回 false。</td>
</tr>
<tr>
<td>String</td>
<td>getValue()</td>
<td>用于获取 Cookie 的值。</td>
</tr>
<tr>
<td>int</td>
<td>getVersion()</td>
<td>用于获取 Cookie 遵守的协议版本。</td>
</tr>
<tr>
<td>void</td>
<td>setMaxAge(int expiry)</td>
<td>用于设置 Cookie 的最大有效时间，以秒为单位。 取值为正值时，表示 Cookie 在经过指定时间后过期。取值为负值时，表示 Cookie 不会被持久存储，在 Web 浏览器退出时删除。取值为 0 时，表示删除该 Cookie。</td>
</tr>
<tr>
<td>void</td>
<td>setPath(String uri)</td>
<td>用于指定 Cookie 的路径。</td>
</tr>
<tr>
<td>void</td>
<td>setSecure(boolean flag)</td>
<td>用于设置浏览器是否只能使用安全协议（如 HTTPS 或 SSL）发送 Cookie。</td>
</tr>
<tr>
<td>void</td>
<td>setValue(String newValue)</td>
<td>用于设置 Cookie 的值。</td>
</tr>
</tbody></table>
<h3 id="Cookie-的使用细节"><a href="#Cookie-的使用细节" class="headerlink" title="Cookie 的使用细节"></a>Cookie 的使用细节</h3><p>使用 Cookie 开发时需要注意以下细节：</p>
<ul>
<li><p>一个 Cookie 只能标识一种信息，它至少包含一个名称（NAME）和一个值（VALUE）。</p>
</li>
<li><p>如果创建了一个 Cookie，并发送到浏览器，默认情况下它是一个会话级别的 Cookie。用户退出浏览器就被删除。如果希望将 Cookie 存到磁盘上，则需要调用 setMaxAge(int maxAge) 方法设置最大有效时间，以秒为单位。</p>
</li>
<li><p>使用 setMaxAge(0) 手动删除 Cookie时，需要使用 setPath 方法指定 Cookie 的路径，且该路径必须与创建 Cookie 时的路径保持一致。</p>
</li>
<li><p>浏览器存放Cookie的数量 不同的浏览器对Cookie也有限定，Cookie的存储有是上限的,大概是4kb。Cookie是存储在客户端（浏览器） 的，而且一般是由服务器端创建和设定。后期结合Session来实现回话跟踪。</p>
</li>
<li><p>Cookie存中文问题</p>
<ul>
<li><p>Cookie 中不能出现中文，如果有中文则通过 URLEncoder.encode()来进行编码，获取时通过 URLDecoder.decode()来进行解码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;姓名&quot;</span>;<br><span class="hljs-type">String</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;张三&quot;</span>;<br><span class="hljs-comment">// 通过 URLEncoder.encode()来进行编码</span><br>name = URLEncoder.encode(name);<br>value = URLEncoder.encode(value);<br><span class="hljs-comment">// 创建Cookie对象</span><br><span class="hljs-type">Cookie</span> <span class="hljs-variable">cookie</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Cookie</span>(name,value);<br><span class="hljs-comment">// 发送Cookie对象</span><br>response.addCookie(cookie);<br><br>	........<br>     <br><br><span class="hljs-comment">// 获取时通过 URLDecoder.decode()来进行解码</span><br>URLDecoder.decode(cookie.getName());<br>URLDecoder.decode(cookie.getValue());<br><br></code></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h3 id="Cookie-的缺点"><a href="#Cookie-的缺点" class="headerlink" title="Cookie 的缺点"></a>Cookie 的缺点</h3><p>Cookie 虽然可以解决服务器跟踪用户状态的问题，但是它具有以下缺点：</p>
<ul>
<li><p>在 HTTP 请求中，Cookie 是明文传递的，容易泄露用户信息，安全性不高。</p>
</li>
<li><p>浏览器可以禁用 Cookie，一旦被禁用，Cookie 将无法正常工作。</p>
</li>
<li><p>Cookie 对象中只能设置文本（字符串）信息。</p>
</li>
<li><p>客户端浏览器保存 Cookie 的数量和长度是有限制的。</p>
</li>
</ul>
<h3 id="Cookie的路径"><a href="#Cookie的路径" class="headerlink" title="Cookie的路径"></a>Cookie的路径</h3><p>Cookie的setPath设置cookie的路径，这个路径直接决定服务器的请求是否会从浏览器中加载某些 cookie。</p>
<p><strong>情景一：当前服务器下任何项目的任意资源都可获取Cookie对象</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/* 当前项目路径为：s01 */</span><br><span class="hljs-type">Cookie</span> <span class="hljs-variable">cookie</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Cookie</span>(<span class="hljs-string">&quot;xxx&quot;</span>,<span class="hljs-string">&quot;XXX&quot;</span>);<br><span class="hljs-comment">// 设置路径为&quot;/&quot;，表示在当前==服务器==下任何项目都可访问到Cookie对象</span><br>cookie.setPath(<span class="hljs-string">&quot;/&quot;</span>);<br>response.addCookie(cookie);<br></code></pre></td></tr></table></figure>

<p><strong>情景二：当前项目下的资源可获取Cookie对象 （默认不设置Cookie的path）</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/* 当前项目路径为：s01 */</span><br><span class="hljs-type">Cookie</span> <span class="hljs-variable">cookie</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Cookie</span>(<span class="hljs-string">&quot;xxx&quot;</span>,<span class="hljs-string">&quot;XXX&quot;</span>);<br><span class="hljs-comment">// 设置路径为&quot;/s01&quot;，表示在==当前项目下任何项目==都可访问到Cookie对象</span><br>cookie.setPath(<span class="hljs-string">&quot;/s01&quot;</span>); <span class="hljs-comment">// 默认情况，可不设置path的值</span><br>response.addCookie(cookie);<br></code></pre></td></tr></table></figure>

<p><strong>情景三：指定项目下的资源可获取Cookie对象</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/* 当前项目路径为：s01 */</span><br><span class="hljs-type">Cookie</span> <span class="hljs-variable">cookie</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Cookie</span>(<span class="hljs-string">&quot;xxx&quot;</span>,<span class="hljs-string">&quot;XXX&quot;</span>);<br><span class="hljs-comment">// 设置路径为&quot;/s02&quot;，表示在s02项目下才可访问到Cookie对象</span><br>cookie.setPath(<span class="hljs-string">&quot;/s02&quot;</span>); <span class="hljs-comment">// 只能在s02项目下获取Cookie，就算cookie是s01产生的，==s01也不能获取它==</span><br>response.addCookie(cookie);<br></code></pre></td></tr></table></figure>

<p><strong>情景四：指定目录下的资源可获取Cookie对象</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/* 当前项目路径为：s01 */</span><br><span class="hljs-type">Cookie</span> <span class="hljs-variable">cookie</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Cookie</span>(<span class="hljs-string">&quot;xxx&quot;</span>,<span class="hljs-string">&quot;XXX&quot;</span>);<br><span class="hljs-comment">// 设置路径为&quot;/s01/cook&quot;，表示在s02/cook目录下才可访问到Cookie对象</span><br>cookie.setPath(<span class="hljs-string">&quot;/s01/cook&quot;</span>);<br>response.addCookie(cookie);<br></code></pre></td></tr></table></figure>

<p>如果我们设置path，如果当前访问的路径包含了cookie的路径（当前访问路径在cookie路径基础上要 比cookie的范围小）cookie就会加载到request对象之中。</p>
<p>cookie的路径指的是可以访问该cookie的顶层目录，该路径的子路径也可以访问该cookie。</p>
<p>&#x3D;&#x3D;<strong>总结：当访问的路径包含了cookie的路径时，则该请求将带上该cookie；如果访问路径不包含 cookie路径，则该请求不会携带该cookie。</strong>&#x3D;&#x3D;</p>
<h2 id="会话技术-HttpSession对象"><a href="#会话技术-HttpSession对象" class="headerlink" title="会话技术(HttpSession对象)"></a>会话技术(HttpSession对象)</h2><p>从打开浏览器访问某个网站，到关闭浏览器的过程，称为一次会话。会话技术是指在会话中，帮助服务器记录用户状态和数据的技术。</p>
<p>常用的会话技术分为两种：</p>
<ol>
<li>Cookie ：客户端会话技术</li>
<li>Session ：服务端会话技术</li>
</ol>
<h3 id="Session-的工作原理-JSESSIONID"><a href="#Session-的工作原理-JSESSIONID" class="headerlink" title="Session 的工作原理(JSESSIONID)"></a>Session 的工作原理(JSESSIONID)</h3><p><img src="https://gcore.jsdelivr.net/gh/fuchajun/blogImgs/img/202208021004083.jpeg" srcset="/img/loading.gif" lazyload></p>
<ol>
<li><p>当客户端第一次请求会话对象时，服务器会创建一个 Session 对象，并为该 Session 对象分配一个唯一的 SessionID（用来标识这个 Session 对象）；</p>
</li>
<li><p>服务器将 SessionID 以 Cookie（Cookie 名称为：“JSESSIONID”，值为 SessionID 的值）的形式发送给客户端浏览器；</p>
</li>
<li><p>客户端浏览器再次发送 HTTP 请求时，会将携带 SessionID 的 Cookie 随请求一起发送给服务器；</p>
</li>
<li><p>服务器从请求中读取 SessionID，然后根据 SessionID 找到对应的 Session 对象。</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//注意：</span><br><span class="hljs-comment">//流程中的 Cookie 是容器自动生成的，它的 maxAge 属性取值为 -1，表示仅当前浏览器有效。</span><br><span class="hljs-comment">//浏览器关闭时，对应的 Session 并没有失效，但此时与此 Session 对应的 Cookie 已失效，导致浏览器无法再通过 Cookie 获取服务器端的 Session 对象。</span><br><span class="hljs-comment">//同一浏览器的不同窗口共享同一 Session 对象，但不同浏览器窗口之间不能共享 Session 对象。</span><br></code></pre></td></tr></table></figure>

<p>Session既然是为了标识一次会话，那么此次会话就应该有一个唯一的标志，这个标志就是 sessionld。 </p>
<p>每当一次请求到达服务器，如果开启了会话（访问了session)，服务器第一步会查看是否从客户端 回传一个名为SESSIONID的cookie,如果没有则认为这是一次新的会话，会创建一个新的session对 象，并用唯一的sessionld为此次会话做一个标志。如果有IESSIONID这个cookiel回传，服务器则会根 据JSESSIONID这个值去查看是否含有id为SESSION值的session对象，如果没有则认为是一个新的会 话，重新创建一个新的session对象，并标志此次会话；如果找到了相应的session对象，则认为是之 前标志过的一次会话，返回该session对象，数据达到共享。 </p>
<p>这里提到一个叫做SESSIONID的cookie,这是一个比较特殊的cookie,当用户请求服务器时，如果 访问了session,则服务器会创建一个名为SESSIONID,值为获取到的session(无论是获取到的还是 新创建的)的sessionld的cookie对象，并添加到response对象中，响应给客户端，有效时间为关闭 浏览器。 </p>
<p><strong>所以Session的底层依赖Cookie来实现.</strong></p>
<h3 id="Session-API"><a href="#Session-API" class="headerlink" title="Session API"></a>Session API</h3><p>Session 对象由服务器创建，通过 HttpServletRequest.getSession() 方法可以获得 HttpSession 对象，例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//获取session对象HttpSession session=request.getSession();</span><br></code></pre></td></tr></table></figure>

<p>HttpSession 接口定义了一系列对 </p>
<h3 id="Session-对象操作的方法"><a href="#Session-对象操作的方法" class="headerlink" title="Session 对象操作的方法"></a>Session 对象操作的方法</h3><p>，如下表。</p>
<table>
<thead>
<tr>
<th>返回值类型</th>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>long</td>
<td>getCreationTime()</td>
<td>返回创建 Session 的时间。</td>
</tr>
<tr>
<td>String</td>
<td>getId()</td>
<td>返回获取 Seesion 的唯一的 ID。</td>
</tr>
<tr>
<td>long</td>
<td>getLastAccessedTime()</td>
<td>返回客户端上一次发送与此 Session 关联的请求的时间。(获取最后一次访问时间)</td>
</tr>
<tr>
<td>boolean</td>
<td>isNew()</td>
<td>判断是否是新的Session对象</td>
</tr>
<tr>
<td>int</td>
<td>getMaxInactiveInterval()</td>
<td>返回在无任何操作的情况下，Session 失效的时间，以秒为单位。</td>
</tr>
<tr>
<td>ServletContext</td>
<td>getServletContext()</td>
<td>返回 Session 所属的 ServletContext 对象。</td>
</tr>
<tr>
<td>void</td>
<td>invalidate()</td>
<td>使 Session 失效。</td>
</tr>
<tr>
<td>void</td>
<td>setMaxInactiveInterval(int interval)</td>
<td>指定在无任何操作的情况下，Session 失效的时间，以秒为单位。负数表示 Session 永远不会失效。</td>
</tr>
</tbody></table>
<h3 id="Session的域对象"><a href="#Session的域对象" class="headerlink" title="Session的域对象"></a>Session的域对象</h3><p>Session 用来表示一次会话，在一次会话中数据是可以共享的，这时 session 作为域对象存在，可以 通过 setAttribute(name,value) 方法向域对象中添加数据，通过 getAttribute(name) 从域对象中获取 数据，通过 removeAttribute(name) 从域对象中移除数据。</p>
<p>在 javax.servlet.http.HttpSession 接口中定义了一系列操作属性的方法，如下表。</p>
<table>
<thead>
<tr>
<th>返回值类型</th>
<th>方法</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td>void</td>
<td>setAttribute(String name, Object o)</td>
<td align="left">把一个 Java 对象与一个属性名绑定，并将它作为一个属性存放到 Session 对象中。 参数 name 为属性名，参数 object 为属性值。</td>
</tr>
<tr>
<td>Object</td>
<td>getAttribute(String name)</td>
<td align="left">根据指定的属性名 name，返回 Session 对象中对应的属性值。</td>
</tr>
<tr>
<td>void</td>
<td>removeAttribute(String name)</td>
<td align="left">从 Session 对象中移除属性名为 name 的属性。</td>
</tr>
<tr>
<td>Enumeration</td>
<td>getAttributeNames()</td>
<td align="left">用于返回 Session 对象中的所有属性名的枚举集合。</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 获取session对象</span><br><span class="hljs-type">HttpSession</span> <span class="hljs-variable">session</span> <span class="hljs-operator">=</span> request.getSession();<br><span class="hljs-comment">// 设置session域对象</span><br>session.setAttribute(<span class="hljs-string">&quot;uname&quot;</span>,<span class="hljs-string">&quot;admin&quot;</span>);<br><span class="hljs-comment">// 获取指定名称的session域对象</span><br><span class="hljs-type">String</span> <span class="hljs-variable">uname</span> <span class="hljs-operator">=</span> (String) request.getAttribute(<span class="hljs-string">&quot;uname&quot;</span>);<br><span class="hljs-comment">// 移除指定名称的session域对象</span><br>session.removeAttribute(<span class="hljs-string">&quot;uname&quot;</span>);<br></code></pre></td></tr></table></figure>

<p>数据存储在 session 域对象中，当 session 对象不存在了，或者是两个不同的 session 对象时，数据 也就不能共享了。这就不得不谈到 session 的生命周期。</p>
<p>同一个request,request域对象可以共享,言外之意,不同的request拿不到不属于他的request域对象例如request.setAttribute(“uname”,”admin),假设重定向网页(前面我们得知重定向是两次请求),request.getAttribute(“uname”)就得不到想要的数据;</p>
<p>而Session作为会话,session.setAttribute(“uname”,”admin”);重定向后还是同一个Session,可以同String uname &#x3D; (String) session.getAttribute(“uname”);得到想要的数据内容.</p>
<h3 id="Session-的生命周期"><a href="#Session-的生命周期" class="headerlink" title="Session 的生命周期"></a>Session 的生命周期</h3><h4 id="Session-对象创建"><a href="#Session-对象创建" class="headerlink" title="Session 对象创建"></a>Session 对象创建</h4><p>Session 对象在容器第一次调用 request.getSession() 方法时创建。</p>
<blockquote>
<p>值得注意的是，当客户端访问的 Web 资源是 HTML，CSS，图片等静态资源时，服务器不会创建 Session 对象。</p>
</blockquote>
<h4 id="Session-对象销毁"><a href="#Session-对象销毁" class="headerlink" title="Session 对象销毁"></a>Session 对象销毁</h4><h4 id="Session-对象在如下-3-种情况下会被销毁："><a href="#Session-对象在如下-3-种情况下会被销毁：" class="headerlink" title="Session 对象在如下 3 种情况下会被销毁："></a>Session 对象在如下 3 种情况下会被销毁：</h4><ul>
<li><p>Session 过期；</p>
<p><strong>默认时间到期</strong></p>
<p>当客户端第一次请求 servlet 并且操作 session 时，session 对象生成，Tomcat 中 session 默认的存 活时间为 30min，即你不操作界面的时间，一旦有操作，session 会重新计时。 那么 session 的默认时间可以改么？答案是肯定的。 可以在 Tomcat 中的 conf 目录下的 web.xml 文件中进行修改。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- session 默认的最大不活动时间。单位：分钟。 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">session-config</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">session-timeout</span>&gt;</span>30<span class="hljs-tag">&lt;/<span class="hljs-name">session-timeout</span>&gt;</span><span class="hljs-comment">&lt;!--配置为30min,正常情况不建议配置,自己配置属于修改tomcat默认配置了,一改则这个项目下Session都被改动--&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">session-config</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p><strong>自己设定到期时间</strong> </p>
<p>当然除了以上的修改方式外，我们也可以在程序中自己设定 session 的生命周期，通过 <strong>session.setMaxInactiveInterval(int)</strong> 来设定 session 的最大不活动时间，<strong>单位为秒</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 获取session对象</span><br><span class="hljs-type">HttpSession</span> <span class="hljs-variable">session</span> <span class="hljs-operator">=</span> request.getSession();ni<br><span class="hljs-comment">// 设置session的最大不活动时间</span><br>session.setMaxInactiveInterval(<span class="hljs-number">15</span>); <span class="hljs-comment">// 15秒</span><br>session.getMaxInactiveInterval;<span class="hljs-comment">//查看当前Session对象的最大不活动时间</span><br></code></pre></td></tr></table></figure>

<p>当然我们也可以通过 getMaxInactiveInterval() 方法来查看当前 Session 对象的最大不活动时间。</p>
<p>&#x2F;&#x2F; 获取session的最大不活动时间 int time &#x3D; session.getMaxInactiveInterval();</p>
</li>
<li><p>调用 session.invalidate() 方法，手动销毁 Session；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 销毁session对象,退出登录可以尝试使用这个方法,主要使用这一招,上面两种看看寄就行</span><br>session.invalidate();<br></code></pre></td></tr></table></figure>
</li>
<li><p>服务器关闭或者应用被卸载或者浏览器关闭。</p>
</li>
</ul>
<h3 id="Session-与-Cookie-对比"><a href="#Session-与-Cookie-对比" class="headerlink" title="Session 与 Cookie 对比"></a>Session 与 Cookie 对比</h3><p><strong>Session 和 Cookie 都属于会话技术，都能帮助服务器保存和跟踪用户状态，但两者也存在差异，如下表。</strong></p>
<table>
<thead>
<tr>
<th>不同点</th>
<th>Cookie</th>
<th>Session</th>
</tr>
</thead>
<tbody><tr>
<td>存储位置不同</td>
<td>Cookie 将数据存放在客户端浏览器内存中或硬盘上。</td>
<td>Session 将数据存储在服务器端。</td>
</tr>
<tr>
<td>大小和数量限制不同</td>
<td>浏览器对 Cookie 的大小和数量有限制。</td>
<td>Session 的大小和数量一般不受限制。</td>
</tr>
<tr>
<td>存放数据类型不同</td>
<td>Cookie 中保存的是字符串。</td>
<td>Session 中保存的是对象。</td>
</tr>
<tr>
<td>安全性不同</td>
<td>Cookie 明文传递，安全性低，他人可以分析存放在本地的 Cookie 并进行 Cookie 欺骗。</td>
<td>Session 存在服务器端，安全性较高。</td>
</tr>
<tr>
<td>对服务器造成的压力不同</td>
<td>Cookie 保存在客户端，不占用服务器资源。</td>
<td>Session 保存在服务端，每一个用户独占一个 Session。若并发访问的用户十分多，就会占用大量服务端资源。</td>
</tr>
<tr>
<td>跨域支持上不同</td>
<td>Cookie 支持跨域名访问。</td>
<td>Session 不支持跨域名访问。</td>
</tr>
</tbody></table>
<h2 id="ServletContext-也称作application应用对象"><a href="#ServletContext-也称作application应用对象" class="headerlink" title="ServletContext(也称作application应用对象)"></a>ServletContext(也称作application应用对象)</h2><h3 id="获取ServletContext对象"><a href="#获取ServletContext对象" class="headerlink" title="获取ServletContext对象"></a>获取ServletContext对象</h3><p>获取ServletContext对象的途径有很多。比如：</p>
<h4 id="1-通过request对象获取"><a href="#1-通过request对象获取" class="headerlink" title="1.通过request对象获取"></a>1.通过request对象获取</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">ServletContext servletContext request.getservletContext();<br></code></pre></td></tr></table></figure>

<h4 id="2-通过session对象获取"><a href="#2-通过session对象获取" class="headerlink" title="2.通过session对象获取"></a>2.通过session对象获取</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ServletContext</span> <span class="hljs-variable">servletContext</span> <span class="hljs-operator">=</span> request.getSession().getServletContext();<br></code></pre></td></tr></table></figure>

<h4 id="3-通过servletConfig对象获取，在Servlet标准中提供了ServletConfig方法"><a href="#3-通过servletConfig对象获取，在Servlet标准中提供了ServletConfig方法" class="headerlink" title="3.通过servletConfig对象获取，在Servlet标准中提供了ServletConfig方法"></a>3.通过servletConfig对象获取，在Servlet标准中提供了ServletConfig方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ServletConfig</span> <span class="hljs-variable">servletConfig</span> <span class="hljs-operator">=</span> getServletConfig();<br><span class="hljs-type">ServletContext</span> <span class="hljs-variable">servletContext</span> <span class="hljs-operator">=</span> servletConfig.getServletContext()<br></code></pre></td></tr></table></figure>

<h4 id="4-直接获取，Servlet类中提供了直接获取ServletContext对象的方法"><a href="#4-直接获取，Servlet类中提供了直接获取ServletContext对象的方法" class="headerlink" title="4.直接获取，Servlet类中提供了直接获取ServletContext对象的方法"></a>4.直接获取，Servlet类中提供了直接获取ServletContext对象的方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ServletContext</span> <span class="hljs-variable">servletContext</span> <span class="hljs-operator">=</span> getServletContext();<br></code></pre></td></tr></table></figure>



<h3 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 获取项目存放的真实路径</span><br><span class="hljs-type">String</span> <span class="hljs-variable">realPath</span> <span class="hljs-operator">=</span> request.getServletContext().getRealPath(<span class="hljs-string">&quot;/&quot;</span>);<br><span class="hljs-comment">// 获取当前服务器的版本信息</span><br><span class="hljs-type">String</span> <span class="hljs-variable">serverInfo</span> <span class="hljs-operator">=</span> request.getServletContext().getServerInfo();<br></code></pre></td></tr></table></figure>

<h3 id="ServletContext域对象"><a href="#ServletContext域对象" class="headerlink" title="ServletContext域对象"></a>ServletContext域对象</h3><p>ServletContext 也可当做域对象来使用，通过向 ServletContext 中存取数据，可以使得整个应用程序 共享某些数据。当<strong>然不建议存放过多数据，因为 ServletContext 中的数据一旦存储进去没有手动移除将 会一直保存</strong>。</p>
<table>
<thead>
<tr>
<th>返回值类型</th>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>void</td>
<td>setAttribute(String name, Object object)</td>
<td>把一个 Java 对象与一个属性名绑定，并将它作为一个属性存放到 ServletContext 中。 参数 name 为属性名，参数 object 为属性值。</td>
</tr>
<tr>
<td>void</td>
<td>removeAttribute(String name)</td>
<td>从 ServletContext 中移除属性名为 name 的属性。</td>
</tr>
<tr>
<td>Object</td>
<td>getAttribute(String name)</td>
<td>根据指定的属性名 name，返回 ServletContext 中对应的属性值。</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 获取ServletContext对象</span><br><span class="hljs-type">ServletContext</span> <span class="hljs-variable">servletContext</span> <span class="hljs-operator">=</span> request.getServletContext();<br><span class="hljs-comment">// 设置域对象</span><br>servletContext.setAttribute(<span class="hljs-string">&quot;name&quot;</span>,<span class="hljs-string">&quot;zhangsan&quot;</span>);<br><span class="hljs-comment">// 获取域对象</span><br><span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> (String) servletContext.getAttribute(<span class="hljs-string">&quot;name&quot;</span>);<br><span class="hljs-comment">// 移除域对象</span><br>servletContext.removeAttribute(<span class="hljs-string">&quot;name&quot;</span>)<br></code></pre></td></tr></table></figure>

<h3 id="ServletContext-属性与上下文初始化参数对比"><a href="#ServletContext-属性与上下文初始化参数对比" class="headerlink" title="ServletContext 属性与上下文初始化参数对比"></a>ServletContext 属性与上下文初始化参数对比</h3><p>虽然 ServletContext 的属性与上下文初始化参数都是存放在 ServletContext 对象中，但它们是不同的。</p>
<table>
<thead>
<tr>
<th>不同点</th>
<th>ServletContext 的属性</th>
<th>上下文初始化参数</th>
</tr>
</thead>
<tbody><tr>
<td>创建方式</td>
<td>ServletContext 的属性通过调用 ServletContext 接口的 setAttribute() 方法创建</td>
<td>上下文初始化参数通过 web.xml 使用 <context-param> 元素配置</td>
</tr>
<tr>
<td>可进行的操作</td>
<td>ServletContext 的属性可以通过 ServletContext 接口的方法进行读取、新增、修改、移除等操作</td>
<td>上下文初始化参数在容器启动后只能被读取，不能进行新增、修改和移除操作</td>
</tr>
<tr>
<td>生命周期</td>
<td>ServletContext 中属性的生命周期从创建开始，到该属性被移除（remove）或者容器关闭结束</td>
<td>上下文初始化参数的生命周期，从容器启动开始，到 Web 应用被卸载或容器关闭结束</td>
</tr>
<tr>
<td>作用</td>
<td>使用 ServletContext 中的属性可以实现 Servlet 之间的数据通讯</td>
<td>使用上下文初始化参数无法实现数据通讯</td>
</tr>
</tbody></table>
<h3 id="Servlet-的三大域对象对比"><a href="#Servlet-的三大域对象对比" class="headerlink" title="Servlet 的三大域对象对比"></a>Servlet 的三大域对象对比</h3><h4 id="1-request域对象"><a href="#1-request域对象" class="headerlink" title="1.request域对象"></a>1.request域对象</h4><p>在一次请求中有效。<strong>请求转发有效，重定向失效</strong>。</p>
<h4 id="2-session-域对象"><a href="#2-session-域对象" class="headerlink" title="2.session:域对象"></a>2.session:域对象</h4><p>在一次会话中有效。<strong>请求转发和重定向都有效，session销毁后失效</strong>。</p>
<h4 id="3-servletContext域对象"><a href="#3-servletContext域对象" class="headerlink" title="3.servletContext域对象"></a>3.servletContext域对象</h4><p>在整个应用程序中有效。<strong>服务器关闭后失效。</strong></p>
<p>Session 、request 以及 ServletContext 合称为 Servlet 的三大域对象，它们都能保存和传递数据，但是三者也存在许多差异，如下表。</p>
<table>
<thead>
<tr>
<th>不同</th>
<th align="center">request</th>
<th align="center">Session</th>
<th align="center">ServletContext</th>
</tr>
</thead>
<tbody><tr>
<td>类型</td>
<td align="center">javax.servlet.http.HttpServletRequest</td>
<td align="center">javax.servlet.http.HttpSession</td>
<td align="center">javax.servlet.ServletContext</td>
</tr>
<tr>
<td>创建</td>
<td align="center">客户端向容器发送请求时创建。</td>
<td align="center">容器第一次调用 getSession() 方法时创建。</td>
<td align="center">Servlet 容器启动时创建。</td>
</tr>
<tr>
<td>销毁</td>
<td align="center">容器对这次请求做出响应后销毁。</td>
<td align="center">Session 销毁的时机： 关闭服务器或应用被卸载。Session 过期，默认为 30 分钟。手动调用 session.invalidate() 方法进行销毁。</td>
<td align="center">容器关闭或者 Web 应用被移除时销毁。</td>
</tr>
<tr>
<td>有效范围</td>
<td align="center">只对当前请求涉及的 Servlet 有效。</td>
<td align="center">Session 对本次会话期间的所有 Servlet 都有效。</td>
<td align="center">对整个 Web 应用内的所有 Servlet 有效。</td>
</tr>
<tr>
<td>数量</td>
<td align="center">Web 应用中的所有 Servlet 实例都可以有多个 request 对象。</td>
<td align="center">Web 应用中可以有多个 Session，多个 Servet 实例可以共享同一 Session 对象。</td>
<td align="center">在整个 Web 应用中只有一个 Context 对象。</td>
</tr>
<tr>
<td>数据共享</td>
<td align="center">每一次请求都是一个新的 request 对象。 通过和请求转发的配合使用可以实现一次请求中 Web 组件之间共享的数据。</td>
<td align="center">每一次会话都是一个新的 Session 对象。 通过 Session 域对象可以实现一次会话中的多个请求之间共享数据。</td>
<td align="center">在一个应用中有且只有一个 Context 对象，作用于整个 Web 应用，可以实现多次会话之间的数据共享。</td>
</tr>
</tbody></table>
<p>在能够满足自己使用需求的基础上,建议使用较小的域对象,例如我们今后会经常使用request域对象,而类似ServletContext域对象应用于整个服务器,正常不要使用.</p>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">学习笔记</a>
                    
                      <a class="hover-with-bg" href="/categories/Servlet/">Servlet</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/Servlet/">Servlet</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2022/08/01/%E7%AE%80%E8%BF%B0JAVA%E7%9A%84List%E4%B8%8EHashMap/">
                        <span class="hidden-mobile">每日一烤:简述JAVA的List与HashMap</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  

  

  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  <script  src="/js/local-search.js" ></script>



  
    <script  src="/js/img-lazyload.js" ></script>
  



  



  
    <script  src="https://cdn.jsdelivr.net/npm/tocbot@4/dist/tocbot.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4/anchor.min.js" ></script>
  
  
    <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js" ></script>
  






  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
        typing(title);
      
    })(window, document);
  </script>















<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


</body>
</html>
