<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>SpringSecurity学习笔记(3)</title>
    <link href="/2022/09/01/SpringSecurity%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(3)/"/>
    <url>/2022/09/01/SpringSecurity%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(3)/</url>
    
    <content type="html"><![CDATA[<h1 id="SpringSecurity学习笔记-3"><a href="#SpringSecurity学习笔记-3" class="headerlink" title="SpringSecurity学习笔记(3)"></a>SpringSecurity学习笔记(3)</h1><p><strong><a href="https://www.bilibili.com/video/BV1xL4y1H7Tq?spm_id_from=333.999.0.0">参考链接 哔哩哔哩Java SSM 教程,推荐b站up主:青空の霞光,笔记很多部分也都是引用他的教程</a></strong></p><h2 id="授权"><a href="#授权" class="headerlink" title="授权:"></a>授权:</h2><p>授权视频中讲解到了三种方式–基于角色,基于权限,使用注解</p><p>我是这样理解的:</p><p>授权主要有两种方式:</p><ul><li>基于角色</li><li>基于权限</li></ul><p>每种方式又都有两种解决方案,也就是代码写法,分为</p><ul><li>配置SecurityConfiguration</li><li>配置注解</li></ul><p>相对来说,第二种更为灵活,更为符合”约定大于配置”的Spring思想</p><h3 id="基于角色"><a href="#基于角色" class="headerlink" title="基于角色:"></a>基于角色:</h3><p>根据用户属于哪个角色来决定是否可以访问某个路径</p><p>以常见的聊天软件QQ举例,一般有这群主,管理员,群成员等角色,每种角色的权限也会不同,例如</p><ul><li>群主：<code>/login</code>、<code>/logout</code>、<code>/chat</code>、<code>/edit</code>、<code>/delete</code>、<code>/upgrade</code></li><li>管理员：<code>/login</code>、<code>/logout</code>、<code>/chat</code>、<code>/edit</code></li><li>普通群成员：<code>/login</code>、<code>/logout</code>、<code>/chat</code></li></ul><p>现在我们希望创建两个角色，普通用户和管理员，普通用户只能访问index页面，而管理员可以访问任何页面。</p><ul><li><p>修改数据库表格</p><p>首先我们需要对数据库中的角色表进行一些修改，添加一个用户角色字段，并创建一个新的用户，Test用户的角色为user，而Admin用户的角色为admin。</p></li><li><p>配置SpringSecurity</p><p>也就是在SecurityConfiguration中给角色添加权限.决定哪些角色可以访问哪些页面：</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><pre><code class="hljs java">http<br>        .authorizeRequests()<br>        .antMatchers(<span class="hljs-string">&quot;/static/**&quot;</span>).permitAll()<br>  .antMatchers(<span class="hljs-string">&quot;/index&quot;</span>).hasAnyRole(<span class="hljs-string">&quot;user&quot;</span>, <span class="hljs-string">&quot;admin&quot;</span>)   <span class="hljs-comment">//index页面可以由user或admin访问</span><br>        .anyRequest().hasRole(<span class="hljs-string">&quot;admin&quot;</span>)   <span class="hljs-comment">//除了上面以外的所有内容，只能是admin访问</span><br></code></pre></td></tr></table></figure><ul><li><p>修改一下验证逻辑</p><p>首先创建一个实体类用于表示数据库中的用户名、密码和角色,为下面getRole做准备：</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Data</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AuthUser</span> &#123;<br>    String username;<br>    String password;<br>    String role;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>修改一下Mapper</p><p>使他返回的不只是密码,而是一个实体user,我们可以通过user.getRole获取到角色权限：</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Mapper</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">UserMapper</span> &#123;<br><br>    <span class="hljs-meta">@Select(&quot;select * from users where username = #&#123;username&#125;&quot;)</span><br>    AuthUser <span class="hljs-title function_">getPasswordByUsername</span><span class="hljs-params">(String username)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>修改Service：</p><p>通过这一步,我们就可以获取整个user的信息,包括角色,密码,用户名,有了角色,就可以通过之前给角色配置的权限进行路径访问权限判断了</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> UserDetails <span class="hljs-title function_">loadUserByUsername</span><span class="hljs-params">(String s)</span> <span class="hljs-keyword">throws</span> UsernameNotFoundException &#123;<br>    <span class="hljs-type">AuthUser</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> mapper.getPasswordByUsername(s);<br>    <span class="hljs-keyword">if</span>(user == <span class="hljs-literal">null</span>)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UsernameNotFoundException</span>(<span class="hljs-string">&quot;登录失败，用户名或密码错误！&quot;</span>);<br>    <span class="hljs-keyword">return</span> User<br>            .withUsername(user.getUsername())<br>            .password(user.getPassword())<br>            .roles(user.getRole())<br>            .build();<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>尝试登陆</p><p>访问一下<code>/index</code>和<code>/admin</code>两个页面,发现已经配置成功</p></li></ul><h3 id="基于权限"><a href="#基于权限" class="headerlink" title="基于权限:"></a>基于权限:</h3><p>基于权限其实和基于角色类似,就是在代码上有两点不同</p><ul><li><p>给权限而不是给角色</p><p>修改Service</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> UserDetails <span class="hljs-title function_">loadUserByUsername</span><span class="hljs-params">(String s)</span> <span class="hljs-keyword">throws</span> UsernameNotFoundException &#123;<br>    <span class="hljs-type">AuthUser</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> mapper.getPasswordByUsername(s);<br>    <span class="hljs-keyword">if</span>(user == <span class="hljs-literal">null</span>)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UsernameNotFoundException</span>(<span class="hljs-string">&quot;登录失败，用户名或密码错误！&quot;</span>);<br>    <span class="hljs-keyword">return</span> User<br>            .withUsername(user.getUsername())<br>            .password(user.getPassword())<br>            .authorities(<span class="hljs-string">&quot;page:index&quot;</span>)<span class="hljs-comment">//给权限而不是给角色</span><br>            .build();<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>判断有什么权限而不是判断是什么角色</p><p>基于权限的授权与角色类似，需要以<code>hasAnyAuthority</code>或<code>hasAuthority</code>进行判断：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">.anyRequest().hasAnyAuthority(<span class="hljs-string">&quot;page:index&quot;</span>)<span class="hljs-comment">//判断有什么权限而不是判断是什么角色</span><br></code></pre></td></tr></table></figure></li></ul><p>授权主要就是以上两种方式,但是上面我们都是通过配置文件判断有什么权限的,前面我们提过还有另一种方法,通过<strong>注解配置</strong>,这一种方式<strong>更为灵活</strong>,</p><p>个人认为前一种通过配置文件的方案更为简单,但还是很有必要掌握后一种,毕竟Spring的思想就是约定大于配置.</p><h3 id="使用注解判断权限"><a href="#使用注解判断权限" class="headerlink" title="使用注解判断权限"></a>使用注解判断权限</h3><p>除了直接配置以外，我们还可以以注解形式直接配置，首先需要在配置类（注意这里是在Mvc的配置类上添加，因为这里只针对Controller进行过滤，所有的Controller是由Mvc配置类进行注册的，如果需要为Service或其他Bean也启用权限判断，则需要在Security的配置类上添加）上开启：</p><ul><li><p>在父级配置类开启:</p><p>相比之前的直接配置,我们可以采用注解配置,<strong>父级配置类</strong>指的是在Mvc的配置类上添加，因为这里只针对Controller进行过滤，所有的Controller是由Mvc配置类进行注册的，如果需要为Service或其他Bean也启用权限判断，则需要在Security的配置类上添加</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@EnableGlobalMethodSecurity(prePostEnabled = true)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SecurityConfiguration</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">WebSecurityConfigurerAdapter</span> &#123;<span class="hljs-comment">//这里也要在Mvc配置类上添加上面一行的注释,这一行是为了后面再service用权限判断做的准备</span><br></code></pre></td></tr></table></figure><ul><li>在添加权限验证的请求映射上添加注解：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@PreAuthorize(&quot;hasRole(&#x27;user&#x27;)&quot;)</span>   <span class="hljs-comment">//判断是否为user角色，只有此角色才可以访问,或者也可以判断hasAnyAuthority(&quot;page:index&quot;)</span><br><span class="hljs-meta">@RequestMapping(&quot;/index&quot;)</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">index</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;index&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>通过添加<code>@PreAuthorize</code>注解，在<strong>方法执行之前</strong>判断判断权限，如果没有对应的权限或是对应的角色，将无法访问页面。</p><p>这里其实是使用了SpEL表达式，相当于可以执行一些逻辑再得到结果，而不是直接传值，官方文档地址：<a href="https://docs.spring.io/spring-framework/docs/5.2.13.RELEASE/spring-framework-reference/core.html#expressions%EF%BC%8C%E5%86%85%E5%AE%B9%E6%AF%94%E8%BE%83%E5%A4%9A%EF%BC%8C%E4%B8%8D%E6%98%AF%E9%87%8D%E7%82%B9%EF%BC%8C%E8%BF%99%E9%87%8C%E5%B0%B1%E4%B8%8D%E5%86%8D%E8%AF%A6%E7%BB%86%E4%BB%8B%E7%BB%8D%E4%BA%86%E3%80%82">https://docs.spring.io/spring-framework/docs/5.2.13.RELEASE/spring-framework-reference/core.html#expressions，内容比较多，不是重点，这里就不再详细介绍了。</a></p><p>同样的还有<code>@PostAuthorize</code>注解，但是它是在<strong>方法执行之后</strong>再进行拦截：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@PostAuthorize(&quot;hasRole(&#x27;user&#x27;)&quot;)</span><br><span class="hljs-meta">@RequestMapping(&quot;/index&quot;)</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">index</span><span class="hljs-params">()</span>&#123;<br>    System.out.println(<span class="hljs-string">&quot;执行了&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;index&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>坑(1),这里有个坑,采用注解配置后,项目运行地址中不会直接跳转到localhost:8080&#x2F;BookManager&#x2F;,而不是之前的localhost:8080&#x2F;BookManager&#x2F;login</p><p>而且以user角色登录后,无法访问<a href="http://localhost:8080/BookManager/all-product.html,%E6%98%BE%E7%A4%BA404">http://localhost:8080/BookManager/all-product.html,显示404</a></p><p>以admin角色登录后,无法访问<a href="http://localhost:8080/BookManager/all-product.html,%E6%98%BE%E7%A4%BA404">http://localhost:8080/BookManager/all-product.html,显示404</a></p><p>就像之前我们配置文件时权限认证的代码一般只好写在SecurityConfiguration,属于文件级,而通过注释配置是方法级的,可以直接配置在方法前.</p><p>新建一个SimpleService用于验证下面这句话</p><blockquote><p>除了Controller以外，只要是由Spring管理的Bean都可以使用注解形式来控制权限，只要不具备访问权限，那么就无法执行方法并且会返回403页面。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SimpleService</span> &#123;<br><br>    <span class="hljs-meta">@PreAuthorize(&quot;hasAnyRole(&#x27;user&#x27;)&quot;)</span><span class="hljs-comment">//通过注释配置是方法级的,可以直接配置在方法前,其他类调用这个方法是会判断调用者是否有权限或者属于有权限的角色</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;成功执行&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>注意Service是由根容器进行注册<strong>，需要在Security配置类上添加<code>@EnableGlobalMethodSecurity</code>注解才可以生效</strong>。</p><h2 id="简单回顾一下"><a href="#简单回顾一下" class="headerlink" title="简单回顾一下:"></a>简单回顾一下:</h2><ul><li><p>SecurityConfiguration配置角色</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">.antMatchers(<span class="hljs-string">&quot;/static/**&quot;</span>).permitAll()<br>.antMatchers(<span class="hljs-string">&quot;/index&quot;</span>).hasAnyRole(<span class="hljs-string">&quot;user&quot;</span>, <span class="hljs-string">&quot;admin&quot;</span>)   <span class="hljs-comment">//index页面可以由user或admin访问</span><br>.anyRequest().hasRole(<span class="hljs-string">&quot;admin&quot;</span>)   <span class="hljs-comment">//除了上面以外的所有内容，只能是admin访问</span><br></code></pre></td></tr></table></figure></li><li><p>创建实体类,注意要包含role</p></li><li><p>修改mapper映射,这一次不只是查询出密码,而是查询出user对象</p></li><li><p>修改service,上一步查询出user对象,这一步通过getRole获取角色</p></li></ul><h3 id="回顾补充"><a href="#回顾补充" class="headerlink" title="回顾补充:"></a>回顾补充:</h3><p>​    暂无</p><h2 id="排坑指南"><a href="#排坑指南" class="headerlink" title="排坑指南:"></a>排坑指南:</h2><p>坑(1) </p><p>暂未解决</p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>SpringSecurity</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringSecurity学习笔记(2)</title>
    <link href="/2022/08/28/SpringSecurity%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(2)/"/>
    <url>/2022/08/28/SpringSecurity%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(2)/</url>
    
    <content type="html"><![CDATA[<h1 id="SpringSecurity学习笔记-2"><a href="#SpringSecurity学习笔记-2" class="headerlink" title="SpringSecurity学习笔记(2)"></a>SpringSecurity学习笔记(2)</h1><p><strong><a href="https://www.bilibili.com/video/BV1xL4y1H7Tq?spm_id_from=333.999.0.0">参考链接 哔哩哔哩Java SSM 教程,推荐b站up主:青空の霞光,笔记很多部分也都是引用他的教程</a></strong></p><h2 id="认证"><a href="#认证" class="headerlink" title="认证:"></a>认证:</h2><p>认证视频中讲解到了两种方式–直接认证与数据库认证</p><p>顾名思义,直接认证就是直接将用户名与密码写死在了代码中</p><p>数据库认证就是需要通过service层调用mapper层中的Select语句访问数据库进行认证</p><h3 id="直接认证"><a href="#直接认证" class="headerlink" title="直接认证:"></a>直接认证:</h3><p>我们今后必然不太会采用这种写死密码方式,但偶尔我们为了验证当前代码是否能够正确执行时,会通过这一种简单的方式来验证.此外,<strong>为了顺带讲解密码校验</strong>这一知识点,所以在这里我们简单提一下.</p><h4 id="关于密码校验"><a href="#关于密码校验" class="headerlink" title="关于密码校验:"></a>关于密码校验:</h4><p>正常情况下,我们不会将用户的密码明文存储到数据库中,如果一旦数据库泄露密码则直接暴露,我们会对用户的密码做简单加密,这里我常看到的加密方式主要是MD5</p><blockquote><p>SpringSecurity的密码校验自然也不是直接使用原文进行比较，而是使用加密算法将密码进行加密（更准确地说应该进行Hash处理，此过程是不可逆的，无法解密），最后将用户提供的密码以同样的方式加密后与密文进行比较。对于我们来说，用户提供的密码属于隐私信息，直接明文存储并不好，而且如果数据库内容被窃取，那么所有用户的密码将全部泄露，这是我们不希望看到的结果，我们需要一种既能隐藏用户密码也能完成认证的机制，而Hash处理就是一种很好的解决方案，通过将用户的密码进行Hash值计算，计算出来的结果无法还原为原文，如果需要验证是否与此密码一致，那么需要以同样的方式加密再比较两个Hash值是否一致，这样就很好的保证了用户密码的安全性。</p></blockquote><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fimages.10qianwan.com%2F10qianwan%2F20180223%2Fb_1_201802231459287319.jpg&refer=http%3A%2F%2Fimages.10qianwan.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1643122575&t=da2d04d86d4869d3054fb9a861ad1824" alt="点击查看源网页" style="zoom: 67%;" /><p>既然我们需要通过SpringSecurity验证进行用户认证,那么则要对Security进行配置</p><p>SecurityConfiguration:</p><figure class="highlight java"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">configure</span><span class="hljs-params">(AuthenticationManagerBuilder auth)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    <span class="hljs-type">BCryptPasswordEncoder</span> <span class="hljs-variable">encoder</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BCryptPasswordEncoder</span>();  <span class="hljs-comment">//这里使用SpringSecurity提供的BCryptPasswordEncoder</span><br>    auth<br>            .inMemoryAuthentication() <span class="hljs-comment">//直接验证方式，之后会讲解使用数据库验证</span><br>            .passwordEncoder(encoder) <span class="hljs-comment">//密码加密器</span><br>            .withUser(<span class="hljs-string">&quot;test&quot;</span>)   <span class="hljs-comment">//用户名</span><br>            .password(encoder.encode(<span class="hljs-string">&quot;123456&quot;</span>))   <span class="hljs-comment">//这里需要填写加密后的密码</span><br>            .roles(<span class="hljs-string">&quot;user&quot;</span>);   <span class="hljs-comment">//用户的角色（之后讲解）</span><br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>这里的configure方法,下面也会用到,但两者</p></blockquote><h3 id="数据库认证"><a href="#数据库认证" class="headerlink" title="数据库认证:"></a>数据库认证:</h3><p>这是我们之后有关登录验证采用的必要方法.</p><p>我们说过数据库中的密码是密文,我们我们直接输入进去,所以我们可以利用SpringSecurity写一个测试类将12345这个密码加密打印到控制台再复制到数据库中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MainTest</span> &#123;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-type">BCryptPasswordEncoder</span> <span class="hljs-variable">encoder</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BCryptPasswordEncoder</span>();<br>        System.out.println(encoder.encode(<span class="hljs-string">&quot;123456&quot;</span>));<span class="hljs-comment">//我们可以复制打印的结果到数据库中</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>UserAuthService:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserAuthService</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">UserDetailsService</span> &#123;<br><br>    <span class="hljs-meta">@Resource</span><br>    UserMapper mapper;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> UserDetails <span class="hljs-title function_">loadUserByUsername</span><span class="hljs-params">(String s)</span> <span class="hljs-keyword">throws</span> UsernameNotFoundException &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">password</span> <span class="hljs-operator">=</span> mapper.getPasswordByUsername(s);  <span class="hljs-comment">//从数据库根据用户名获取密码</span><br>        <span class="hljs-keyword">if</span>(password == <span class="hljs-literal">null</span>)<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UsernameNotFoundException</span>(<span class="hljs-string">&quot;登录失败，用户名或密码错误！&quot;</span>);<br>        <span class="hljs-keyword">return</span> User   <span class="hljs-comment">//这里需要返回UserDetails，SpringSecurity会根据给定的信息进行比对</span><br>                .withUsername(s)<br>                .password(password)   <span class="hljs-comment">//直接从数据库取的密码</span><br>                .roles(<span class="hljs-string">&quot;user&quot;</span>)   <span class="hljs-comment">//用户角色</span><br>                .build();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上述代码调用了getPasswordByUsername这个方法我们还没有定义</p><p>所以别忘记Service层需要调用Mapper中getPasswordByUsername定义的Select语句</p><p>创建mapper层</p><ul><li><p>interface:UserMapper</p></li><li><p>&#96;&#96;&#96;java<br>@Mapper<br>public interface UserMapper {</p><div class="code-wrapper"><pre><code class="hljs">@Select(&quot;select password from users where username = #&#123;username&#125;&quot;)String getPasswordByUsername(String username);</code></pre></div><p>}</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs scala"><br>    <br><br>**别忘记在<span class="hljs-type">RootConfiguration</span>中配置注解**<br><br><span class="hljs-meta">@MapperScan</span>(<span class="hljs-string">&quot;book.manager.mapper&quot;</span>)<br><br>并提醒一下之前我们曾在这配置过<br><br><span class="hljs-meta">@ComponentScans</span>(&#123;<br>        <span class="hljs-meta">@ComponentScan</span>(<span class="hljs-string">&quot;book.manager.service&quot;</span>)<br>&#125;)<br><br>最后我们需要再修改一下<span class="hljs-type">Security</span>配置：<br><br>我们的<span class="hljs-type">Security</span>配置是放在了<span class="hljs-type">SecurityConfiguration</span>中的<br><br><span class="hljs-type">SecurityConfiguration</span>:<br><br>```java<br><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@EnableWebSecurity</span><br>public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SecurityConfiguration</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">WebSecurityConfigurerAdapter</span> </span>&#123;<br>   <span class="hljs-comment">/*</span><br><span class="hljs-comment">   这是直接认证时的代码,这里可以直接删除或者像我这样注释掉</span><br><span class="hljs-comment">   @Override</span><br><span class="hljs-comment">    protected void configure(AuthenticationManagerBuilder auth) throws Exception &#123;</span><br><span class="hljs-comment">        BCryptPasswordEncoder encoder = new BCryptPasswordEncoder();  //这里使用SpringSecurity提供的BCryptPasswordEncoder</span><br><span class="hljs-comment">        auth</span><br><span class="hljs-comment">                .inMemoryAuthentication() //直接验证方式，之后会讲解使用数据库验证</span><br><span class="hljs-comment">                .passwordEncoder(encoder) //密码加密器</span><br><span class="hljs-comment">                .withUser(&quot;test&quot;)   //用户名</span><br><span class="hljs-comment">                .password(encoder.encode(&quot;123456&quot;))   //这里需要填写加密后的密码</span><br><span class="hljs-comment">                .roles(&quot;user&quot;);   //用户的角色（之后讲解）</span><br><span class="hljs-comment">    &#125;*/</span><br><br>    <br>    <span class="hljs-meta">@Resource</span><br>    <span class="hljs-type">UserAuthService</span> service;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> void configure(<span class="hljs-type">AuthenticationManagerBuilder</span> auth) <span class="hljs-keyword">throws</span> <span class="hljs-type">Exception</span> &#123;<br>        auth<br>                .userDetailsService(service)   <span class="hljs-comment">//使用自定义的Service实现类进行验证</span><br>                .passwordEncoder(<span class="hljs-keyword">new</span> <span class="hljs-type">BCryptPasswordEncoder</span>());   <span class="hljs-comment">//依然使用BCryptPasswordEncoder</span><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure></li></ul><p>既然要进行数据库认证,必然要解决的就是连接数据库,然后才可以查询数据库.</p><h4 id="链接数据库"><a href="#链接数据库" class="headerlink" title="链接数据库:"></a>链接数据库:</h4><p>和之前一样,我们需要在RootConfiguration中配置一下Mybatis和数据源：</p><p>数据库名:study</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@ComponentScans(&#123;</span><br><span class="hljs-meta">        @ComponentScan(&quot;book.manager.service&quot;)</span><br><span class="hljs-meta">&#125;)</span><br><span class="hljs-meta">@MapperScan(&quot;book.manager.mapper&quot;)</span><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RootConfiguration</span> &#123;<br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> DataSource <span class="hljs-title function_">dataSource</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-type">HikariDataSource</span> <span class="hljs-variable">dataSource</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HikariDataSource</span>();<br>        dataSource.setJdbcUrl(<span class="hljs-string">&quot;jdbc:mysql://localhost:3306/study&quot;</span>);<br>        dataSource.setDriverClassName(<span class="hljs-string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>);<br>        dataSource.setUsername(<span class="hljs-string">&quot;root&quot;</span>);<br>        dataSource.setPassword(<span class="hljs-string">&quot;123456&quot;</span>);<br>        <span class="hljs-keyword">return</span> dataSource;<br>    &#125;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> SqlSessionFactoryBean <span class="hljs-title function_">sqlSessionFactoryBean</span><span class="hljs-params">(<span class="hljs-meta">@Autowired</span> DataSource dataSource)</span>&#123;<br>        <span class="hljs-type">SqlSessionFactoryBean</span> <span class="hljs-variable">bean</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SqlSessionFactoryBean</span>();<br>        bean.setDataSource(dataSource);<br>        <span class="hljs-keyword">return</span> bean;<br>    &#125;   <br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>如上代码以及下图,之前我们提到过有关RootConfiguration和ServletConfiguration的区别</p><p><img src="https://img2018.cnblogs.com/blog/738818/201906/738818-20190617214214614-761905677.png" alt="img"></p><p>总结:有关service,datasources联想到Root</p></blockquote><h2 id="简单回顾一下"><a href="#简单回顾一下" class="headerlink" title="简单回顾一下:"></a>简单回顾一下:</h2><h3 id="SecurityConfiguration"><a href="#SecurityConfiguration" class="headerlink" title="SecurityConfiguration:"></a>SecurityConfiguration:</h3><p>功能:配置SpringSecurity,以达到区别直接认证或者数据库认证的效果</p><p>继承或接口:extends WebSecurityConfigurerAdapter</p><p>代码组成:</p><ul><li>被重写的一个方法,直接认证和数据库认证都需要重写此方法,只是数据库认证此方法还会调用service层,service层又会调用mapper层访问数据库<ul><li>protected void configure(AuthenticationManagerBuilder auth) throws Exception</li></ul></li></ul><p>注意要点:</p><ul><li><p>注解:</p><ul><li><p>@Resource</p><p>UserAuthService service;&#x2F;&#x2F;前面学的知识嗷,这样就不需要自己new实例了</p></li><li><p>@Configuration</p></li><li><p>@EnableWebSecurity</p></li></ul></li><li><p>提醒:</p><ul><li>被重写的configure其实有两个可选,当我们要选择Websecurity开头的,另一个HttpSecurity现在用不到,后续可能会用到</li></ul></li></ul><h3 id="UserAuthService"><a href="#UserAuthService" class="headerlink" title="UserAuthService:"></a>UserAuthService:</h3><p>功能:上面提到protected void configure方法会调用service层,这里service层做简单的业务处理</p><ul><li>从数据库根据用户名获取密码</li><li>判断密码是否为空</li><li>判断密码是否正确</li><li>判断用户类型</li><li>.build()</li></ul><p>继承或接口:implements UserDetailsService(重点)</p><p>代码组成:</p><ul><li><p>通过@Resource注解自动注册mapper实例</p></li><li><p>重写public UserDetails loadUserByUsername(String s)方法</p><ul><li><p>形参s代表传入的用户名,通过用户名查密码</p></li><li><p>最后需要返回UserDetails，SpringSecurity会根据给定的信息进行比对</p><ul><li><div class="code-wrapper"><pre><code class="java">return User   //这里需要返回UserDetails，SpringSecurity会根据给定的信息进行比对        .withUsername(s)        .password(password)   //直接从数据库取的密码        .roles(&quot;user&quot;)   //用户角色        .build();</code></pre></div></li></ul></li></ul></li></ul><p>注意要点:</p><ul><li><p>注解:</p><ul><li>@Service</li><li>@Resource</li></ul></li><li><p>提醒:用到mapper层,记得去写</p></li></ul><h3 id="UserMapper"><a href="#UserMapper" class="headerlink" title="UserMapper:"></a>UserMapper:</h3><p>功能:数据映射层</p><p>继承或接口:本身就是interface接口</p><p>代码组成:</p><ul><li>方法 String getPasswordByUsername(String username);</li></ul><p>注意要点: </p><ul><li>String getPasswordByUsername(String username)使用了@Select注解</li></ul><p>注解:</p><ul><li>@Select(“select password from users where username &#x3D; #{username}”)</li></ul><h3 id="RootConfiguration"><a href="#RootConfiguration" class="headerlink" title="RootConfiguration:"></a>RootConfiguration:</h3><p>功能:各类配置</p><ul><li>配置ComponentScan</li><li>配置MapperScan</li><li>配置数据库</li></ul><p>继承或接口:暂无</p><p>代码组成:</p><ul><li>两个被注册为@Bean的方法,老生常谈了,链接数据库基本直接复制这个方法就行</li><li>public DataSource dataSource</li><li>public SqlSessionFactoryBean sqlSessionFactoryBean(@Autowired DataSource dataSource)</li></ul><p>注意要点:配置类本身需要添加注解@Configuration别忘记了</p><p>注解:</p><ul><li>@Configuration</li><li>@ComponentScans</li><li>@MapperScan</li><li>@Bean</li></ul>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>SpringSecurity</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringSecurity学习笔记(1)</title>
    <link href="/2022/08/27/SpringSecurity%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(1)/"/>
    <url>/2022/08/27/SpringSecurity%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(1)/</url>
    
    <content type="html"><![CDATA[<h1 id="SpringSecurity学习笔记-1"><a href="#SpringSecurity学习笔记-1" class="headerlink" title="SpringSecurity学习笔记(1)"></a>SpringSecurity学习笔记(1)</h1><p><strong><a href="https://www.bilibili.com/video/BV1xL4y1H7Tq?spm_id_from=333.999.0.0">参考链接 哔哩哔哩Java SSM 教程,推荐b站up主:青空の霞光,笔记很多部分也都是引用他的教程</a></strong></p><p>通过图书管理系统了解SpringSecurity</p><p>  SpringSecurity是一个基于(spring)开发的非常强大的(  权限验证   ) 框架，其核心功能包括：</p><ul><li>认证 （用户登录）</li><li>授权 （此用户能够做哪些事情）</li><li>攻击防护 （防止伪造身份攻击）</li></ul><p>我们为什么需要使用更加专业的全新验证框架，还要从CSRF说起。</p><h2 id="CSRF攻击"><a href="#CSRF攻击" class="headerlink" title="CSRF攻击"></a>CSRF攻击</h2><p>全称()</p><p>我们想必都经历过这样一种情况,突然的某一天收到一条好友发来的链接,或者在某个深夜,你在找学习资料时,进入一个网站,也会看到一些钓鱼链接,点击之后可能一些不好的事情就会发生,那么这些钓鱼链接的工作又是什么呢?</p><p>了解其中的原理,我们需要知道一个前提:</p><p>当我们访问某个服务器时,往往会生成对应的名为JSESSION的cookie,这里面可能保存着一些重要信息,比如你的账号密码,通常记住密码这个功能也是可以用到这个cookie实现的.而这个Cookie的生命周期,一般你只要不关闭浏览器,他就会一直保存.</p><p>现在，我们的服务器新增了一个转账的接口，用户登录之后，只需要使用POST请求携带需要转账的金额和转账人访问此接口就可以进行转账操作：</p><figure class="highlight java"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(value = &quot;/pay&quot;, method = RequestMethod.POST, produces = &quot;text/html;charset=utf-8&quot;)</span> <span class="hljs-comment">//这里要设置一下produces不然会乱码</span><br><span class="hljs-meta">@ResponseBody</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">pay</span><span class="hljs-params">(String account,</span><br><span class="hljs-params">                  <span class="hljs-type">int</span> amount,</span><br><span class="hljs-params">                  <span class="hljs-meta">@SessionAttribute(&quot;login&quot;)</span> Boolean isLogin)</span>&#123;<br>    <span class="hljs-keyword">if</span> (isLogin) <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;成功转账 ￥&quot;</span>+amount+<span class="hljs-string">&quot; 给：&quot;</span>+account;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;转账失败，您没有登陆！&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>那么，大家有没有想过这样一个问题，我们为了搜索学习资料时可能一不小心访问了一个恶意网站，而此网站携带了这样一段内容：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>我是(恶)学(意)习网站<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>对不起，您还没有充值本站的学习会员，请先充值后再观看学习视频<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">action</span>=<span class="hljs-string">&quot;http://localhost:8080/mvc/pay&quot;</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;post&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;account&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;hacker&quot;</span> <span class="hljs-attr">hidden</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;number&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;amount&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;666666&quot;</span> <span class="hljs-attr">hidden</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;点我充值会员，观看完整视频&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p>注意这个页面并不是我们官方提供的页面，而是不法分子搭建的恶意网站。我们发现此页面中有一个表单，但是表单中的两个输入框被<strong>隐藏</strong>了，而我们看到的只有一个按钮，我们不知道这是一个表单，也不知道表单会提交给那个地址，这时整个页面就非常有迷惑性了。如果我们点击此按钮，那么整个表单的数据会以POST的形式发送给我们的服务端（会携带之前登陆我们网站的Cookie信息），但是这里很明显是另一个网站跳转，通过这样的方式，恶意网站就成功地在我们毫不知情的情况下引导我们执行了转账操作，当你发现上当受骗时，钱已经被转走了。</p><p>这样的漏洞是不可被接受的,那么SpringSecurity就可以用来解决这个问题.</p><h2 id="开发环境搭建"><a href="#开发环境搭建" class="headerlink" title="开发环境搭建"></a>开发环境搭建</h2><p>首先我们需要搭建一个图书管理系统的大致框架.静态文件我们采用直接导入他人写好的模板就行,后端部分先把简单的框架搭好就可以.</p><h3 id="新建项目"><a href="#新建项目" class="headerlink" title="新建项目:"></a>新建项目:</h3><p>项目类型选项:Java EnterPrise</p><p>项目模板:web应用程序</p><p>应用程序服务器:Tomcat9.0</p><p>组:book.manager</p><p>项目名:BookManager</p><p>进入项目后删除默认jsp文件,配置文件,以及HelloServlet文件,我们采用全注解方式</p><h3 id="导入依赖"><a href="#导入依赖" class="headerlink" title="导入依赖:"></a>导入依赖:</h3><p>友情提醒:今后我们一个项目中可能会导入大量的依赖,数量一旦多起来,看起来也会眼花缭乱,因此,建议将不同的一类进行分类,简单注释其内容.</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 建议为各个依赖进行分类，到后期我们的项目可能会导入很多依赖，添加注释会大幅度提高阅读效率 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--  Spring框架依赖  --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-comment">&lt;!--由此可见,此处导入了有关SpringSecurity的两个依赖,第二个是关于SpringSecurity的配置--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.security<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-security-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.5.3<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.security<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-security-config<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.5.3<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-webmvc<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.3.14<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!--  持久层框架依赖  --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>8.0.27<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mybatis<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis-spring<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.0.6<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mybatis<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.5.7<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-jdbc<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.3.14<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.zaxxer<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>HikariCP<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.4.5<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>     <span class="hljs-comment">&lt;!--  //我们需要使用ThymeleafViewResolver作为视图解析器，并解析我们的HTML页面--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.thymeleaf<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>thymeleaf-spring5<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.0.14.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!--  其他工具框架依赖：Lombok、Slf4j  --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.projectlombok<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>lombok<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.18.22<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.slf4j<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>slf4j-jdk14<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.7.32<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!--  ServletAPI  --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>javax.servlet<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>javax.servlet-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.0.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>provided<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!--  JUnit依赖  --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.junit.jupiter<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>junit-jupiter-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;junit.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.junit.jupiter<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>junit-jupiter-engine<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;junit.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br></code></pre></td></tr></table></figure><p>接下来我们先把几个包创建好</p><h3 id="初始化包-initializer"><a href="#初始化包-initializer" class="headerlink" title="初始化包:initializer"></a>初始化包:initializer</h3><ul><li><h4 id="MvcInitializer"><a href="#MvcInitializer" class="headerlink" title="MvcInitializer"></a>MvcInitializer</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> book.manager.initializer;<br><br><span class="hljs-keyword">import</span> book.manager.config.MvcConfiguration;<br><span class="hljs-keyword">import</span> book.manager.config.RootConfiguration;<br><span class="hljs-keyword">import</span> book.manager.config.SecurityConfiguration;<br><span class="hljs-keyword">import</span> org.springframework.web.servlet.support.AbstractAnnotationConfigDispatcherServletInitializer;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MvcInitializer</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractAnnotationConfigDispatcherServletInitializer</span> &#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> Class&lt;?&gt;[] getRootConfigClasses() &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;RootConfiguration.class, SecurityConfiguration.class&#125;;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> Class&lt;?&gt;[] getServletConfigClasses() &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;MvcConfiguration.class&#125;;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> String[] getServletMappings() &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[]&#123;<span class="hljs-string">&quot;/&quot;</span>&#125;;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="控制层包-controller"><a href="#控制层包-controller" class="headerlink" title="控制层包:controller"></a>控制层包:controller</h3><ul><li><h4 id="PageController"><a href="#PageController" class="headerlink" title="PageController"></a>PageController</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> book.manager.controller;<br><br><span class="hljs-keyword">import</span> org.springframework.stereotype.Controller;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 专用于处理页面响应的控制器</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Controller</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PageController</span> &#123;<br><br>    <span class="hljs-meta">@RequestMapping(&quot;/index&quot;)</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">login</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;index&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="配置包-config"><a href="#配置包-config" class="headerlink" title="配置包:config"></a>配置包:config</h3><ul><li><h4 id="根容器配置文件-RootConfiguration"><a href="#根容器配置文件-RootConfiguration" class="headerlink" title="根容器配置文件:RootConfiguration"></a>根容器配置文件:RootConfiguration</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> book.manager.config;<br><br><span class="hljs-keyword">import</span> org.springframework.context.annotation.ComponentScan;<br><span class="hljs-keyword">import</span> org.springframework.context.annotation.ComponentScans;<br><span class="hljs-keyword">import</span> org.springframework.context.annotation.Configuration;<br><br><span class="hljs-meta">@ComponentScans(&#123;</span><br><span class="hljs-meta">        @ComponentScan(&quot;book.manager.service&quot;)</span><br><span class="hljs-meta">&#125;)</span><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RootConfiguration</span> &#123;<br><br>&#125;<br></code></pre></td></tr></table></figure></li><li><h4 id="MvcWeb配置文件-MvcConfiguration"><a href="#MvcWeb配置文件-MvcConfiguration" class="headerlink" title="MvcWeb配置文件:MvcConfiguration"></a>MvcWeb配置文件:MvcConfiguration</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> book.manager.config;<br>  <br>  <span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Autowired;<br>  <span class="hljs-keyword">import</span> org.springframework.context.annotation.Bean;<br>  <span class="hljs-keyword">import</span> org.springframework.context.annotation.ComponentScan;<br>  <span class="hljs-keyword">import</span> org.springframework.context.annotation.Configuration;<br>  <span class="hljs-keyword">import</span> org.springframework.web.servlet.config.annotation.DefaultServletHandlerConfigurer;<br>  <span class="hljs-keyword">import</span> org.springframework.web.servlet.config.annotation.EnableWebMvc;<br>  <span class="hljs-keyword">import</span> org.springframework.web.servlet.config.annotation.ResourceHandlerRegistry;<br>  <span class="hljs-keyword">import</span> org.springframework.web.servlet.config.annotation.WebMvcConfigurer;<br>  <span class="hljs-keyword">import</span> org.thymeleaf.spring5.SpringTemplateEngine;<br>  <span class="hljs-keyword">import</span> org.thymeleaf.spring5.templateresolver.SpringResourceTemplateResolver;<br>  <span class="hljs-keyword">import</span> org.thymeleaf.spring5.view.ThymeleafViewResolver;<br>  <span class="hljs-keyword">import</span> org.thymeleaf.templateresolver.ITemplateResolver;<br>  <br>  <span class="hljs-meta">@ComponentScan(&quot;book.manager.controller&quot;)</span><br>  <span class="hljs-meta">@Configuration</span><br>  <span class="hljs-meta">@EnableWebMvc</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MvcConfiguration</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">WebMvcConfigurer</span> &#123;<br>  <br>      <span class="hljs-comment">//我们需要使用ThymeleafViewResolver作为视图解析器，并解析我们的HTML页面</span><br>      <span class="hljs-meta">@Bean</span><br>      <span class="hljs-keyword">public</span> ThymeleafViewResolver <span class="hljs-title function_">thymeleafViewResolver</span><span class="hljs-params">(<span class="hljs-meta">@Autowired</span> SpringTemplateEngine springTemplateEngine)</span>&#123;<br>          <span class="hljs-type">ThymeleafViewResolver</span> <span class="hljs-variable">resolver</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThymeleafViewResolver</span>();<br>          resolver.setOrder(<span class="hljs-number">1</span>);<br>          resolver.setCharacterEncoding(<span class="hljs-string">&quot;UTF-8&quot;</span>);<br>          resolver.setTemplateEngine(springTemplateEngine);<br>          <span class="hljs-keyword">return</span> resolver;<br>      &#125;<br>  <br>      <span class="hljs-comment">//配置模板解析器</span><br>      <span class="hljs-meta">@Bean</span><br>      <span class="hljs-keyword">public</span> SpringResourceTemplateResolver <span class="hljs-title function_">templateResolver</span><span class="hljs-params">()</span>&#123;<br>          <span class="hljs-type">SpringResourceTemplateResolver</span> <span class="hljs-variable">resolver</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SpringResourceTemplateResolver</span>();<br>          resolver.setSuffix(<span class="hljs-string">&quot;.html&quot;</span>);<br>          resolver.setPrefix(<span class="hljs-string">&quot;/WEB-INF/template/&quot;</span>);<br>          <span class="hljs-keyword">return</span> resolver;<br>      &#125;<br>  <br>      <span class="hljs-comment">//配置模板引擎Bean</span><br>      <span class="hljs-meta">@Bean</span><br>      <span class="hljs-keyword">public</span> SpringTemplateEngine <span class="hljs-title function_">springTemplateEngine</span><span class="hljs-params">(<span class="hljs-meta">@Autowired</span> ITemplateResolver resolver)</span>&#123;<br>          <span class="hljs-type">SpringTemplateEngine</span> <span class="hljs-variable">engine</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SpringTemplateEngine</span>();<br>          engine.setTemplateResolver(resolver);<br>          <span class="hljs-keyword">return</span> engine;<br>      &#125;<br>  <br>      <span class="hljs-comment">//开启静态资源处理</span><br>      <span class="hljs-meta">@Override</span><br>      <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">configureDefaultServletHandling</span><span class="hljs-params">(DefaultServletHandlerConfigurer configurer)</span> &#123;<br>          configurer.enable();<br>      &#125;<br>  <br>      <span class="hljs-comment">//静态资源路径配置</span><br>      <span class="hljs-meta">@Override</span><br>      <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addResourceHandlers</span><span class="hljs-params">(ResourceHandlerRegistry registry)</span> &#123;<br>          registry.addResourceHandler(<span class="hljs-string">&quot;/static/**&quot;</span>).addResourceLocations(<span class="hljs-string">&quot;/WEB-INF/static/&quot;</span>);<br>      &#125;<br>  &#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="在Web-INF文件夹下创建"><a href="#在Web-INF文件夹下创建" class="headerlink" title="在Web-INF文件夹下创建"></a>在Web-INF文件夹下创建</h3><h4 id="static文件夹-用于放置下载的前端静态文件"><a href="#static文件夹-用于放置下载的前端静态文件" class="headerlink" title="static文件夹:用于放置下载的前端静态文件"></a>static文件夹:用于放置下载的前端静态文件</h4><h4 id="template"><a href="#template" class="headerlink" title="template:"></a>template:</h4><ul><li>index.html</li></ul><h3 id="修改部署配置"><a href="#修改部署配置" class="headerlink" title="修改部署配置"></a>修改部署配置</h3><p>别忘了改一下配置和部署中的URL和应用程序上下文,把长名字改成简略名,这样访问地址会简单些</p><p>此时我们还没有使用到SpringSecurity框架,在URL地址输入ip&#x2F;端口&#x2F;xxx(项目名)&#x2F;index就可以访问到静态资源文件了</p><p>下面开始介绍如何**—**</p><h2 id="使用SpringSecurity"><a href="#使用SpringSecurity" class="headerlink" title="使用SpringSecurity"></a>使用SpringSecurity</h2><h3 id="创建SecurityInitializer"><a href="#创建SecurityInitializer" class="headerlink" title="创建SecurityInitializer"></a>创建SecurityInitializer</h3><p>配置SpringSecurity前，与Mvc一样，需要一个初始化器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SecurityInitializer</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractSecurityWebApplicationInitializer</span> &#123;<br>    <span class="hljs-comment">//不用重写任何内容</span><br>  <span class="hljs-comment">//这里实际上会自动注册一个Filter，SpringSecurity底层就是依靠N个过滤器实现的，我们之后再探讨</span><br>&#125;<br></code></pre></td></tr></table></figure><p>创建一个配置类用于</p><h3 id="配置SpringSecurity"><a href="#配置SpringSecurity" class="headerlink" title="配置SpringSecurity"></a>配置SpringSecurity</h3><p>即在config下创建SecurityConfiguration文件</p><p>和配置Spring一样,需要通过注解进行配置,这里用到了@EnableWebSecurity这个注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@EnableWebSecurity</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SecurityConfiguration</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">WebSecurityConfigurerAdapter</span> &#123;<br><span class="hljs-comment">//继承WebSecurityConfigurerAdapter，之后会进行配置</span><br>&#125;<br></code></pre></td></tr></table></figure><p>接着在MvcInitializer.java的根容器中</p><h3 id="添加此配置文件"><a href="#添加此配置文件" class="headerlink" title="添加此配置文件"></a>添加此配置文件</h3><p>即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">protected</span> Class&lt;?&gt;[] getRootConfigClasses() &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;RootConfiguration.class, SecurityConfiguration.class&#125;;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样，SpringSecurity的配置就完成了，我们再次运行项目，会发现无法进入的我们的页面中，无论我们访问哪个页面，都会进入到SpringSecurity为我们提供的一个默认登录页面，这样就不会出现我们在URL地址输入ip&#x2F;端口&#x2F;xxx(项目名)&#x2F;index就可以随意访问到原先需要登陆才可以访问静态资源文件了</p><p>至此，项目环境搭建完成。</p><h2 id="简单回顾一下"><a href="#简单回顾一下" class="headerlink" title="简单回顾一下:"></a>简单回顾一下:</h2><h3 id="SpringSecurity"><a href="#SpringSecurity" class="headerlink" title="SpringSecurity"></a>SpringSecurity</h3><p>是一个基于()开发的非常强大的(   ) 框架，其核心功能包括：</p><ul><li>认证 （）</li><li>授权 （）</li><li>攻击防护 （）</li></ul><p>首先是initializer包中:</p><h3 id="MvcInitializer-1"><a href="#MvcInitializer-1" class="headerlink" title="MvcInitializer"></a>MvcInitializer</h3><p>功能:初始化Mvc项目</p><p>继承或接口: extends <strong>AbstractAnnotationConfigDispatcherServletInitializer</strong></p><p>代码组成:</p><ul><li>被重写的三个方法<ul><li>getRootConfigClasses</li><li>getServletConfigClasses</li><li>getServletMappings</li></ul></li></ul><p>注意要点:无</p><h3 id="PageController-1"><a href="#PageController-1" class="headerlink" title="PageController"></a>PageController</h3><p>功能:专用于处理页面响应的控制器</p><p>继承或接口: 无</p><p>代码组成:return”index”(返回类型为String)的public方法login()</p><p>注意要点:</p><ul><li>注解<ul><li>类注解@Controller</li><li>方法注解@ResquestMaping(“&#x2F;index”)</li></ul></li></ul><h3 id="根容器配置文件-RootConfiguration-1"><a href="#根容器配置文件-RootConfiguration-1" class="headerlink" title="根容器配置文件:RootConfiguration"></a>根容器配置文件:RootConfiguration</h3><p>功能:配置类</p><p>继承或接口:待添加</p><p>代码组成:待添加</p><p>注意要点:</p><ul><li>注解<ul><li>@ComponentScans(  {   @ComponentScan(“book.manager.service”) }       )  </li><li>@Configuration</li></ul></li></ul><h3 id="MvcWeb配置文件-MvcConfiguration-1"><a href="#MvcWeb配置文件-MvcConfiguration-1" class="headerlink" title="MvcWeb配置文件:MvcConfiguration"></a>MvcWeb配置文件:MvcConfiguration</h3><p>功能:配置类</p><p>继承或接口: implements WebMvcConfigurer</p><p>代码组成:</p><ul><li>三个注解为@Bean的方法<ul><li>public ThymeleafViewResolver thymeleafViewResolver(@Autowired SpringTemplateEngine springTemplateEngine)<ul><li>功能:我们需要使用ThymeleafViewResolver作为视图解析器，并解析我们的HTML页面</li></ul></li><li>public SpringResourceTemplateResolver templateResolver()<ul><li>功能:配置模板解析器</li></ul></li><li>public SpringTemplateEngine springTemplateEngine(@Autowired ITemplateResolver resolver)<ul><li>功能:配置模板引擎Bean</li></ul></li></ul></li><li>两个重写的@override方法<ul><li>public void configureDefaultServletHandling(DefaultServletHandlerConfigurer configurer)<ul><li>功能:开启静态资源处理</li></ul></li><li>public void addResourceHandlers(ResourceHandlerRegistry registry)<ul><li>静态资源路径配置</li></ul></li></ul></li></ul><p>注意要点:</p><ul><li>注解<ul><li>@ComponentScan(“book.manager.controller”)</li><li>@Configuration</li><li><strong>@EnableWebMvc</strong></li><li>@Bean</li></ul></li></ul><h3 id="SecurityInitializer"><a href="#SecurityInitializer" class="headerlink" title="SecurityInitializer"></a>SecurityInitializer</h3><p>功能:初始化SpringSecurity框架</p><p>继承或者接口:extends AbstractSecurityWebApplicationInitializer</p><p>代码组成:待添加</p><p>注意要点:暂无</p><h3 id="SecurityConfiguration"><a href="#SecurityConfiguration" class="headerlink" title="SecurityConfiguration"></a>SecurityConfiguration</h3><p>功能:配置即将被初始化的SpringSecurity</p><p>继承或接口:extends WebSecurityConfigurerAdapter</p><p>注意要点:</p><ul><li>注解:<ul><li>@Configuration</li><li>@<strong>EnableWebSecurity</strong>这个注解可以想到上面的@EnableWebMvc</li></ul></li></ul><p>最后记得在 MvcInitializer中添加配置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">protected</span> Class&lt;?&gt;[] getRootConfigClasses() &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;RootConfiguration.class, SecurityConfiguration.class&#125;;<span class="hljs-comment">//就是这一步</span><br>&#125;<br></code></pre></td></tr></table></figure><p>好了,这篇文篇到这就结束了.</p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>SpringSecurity</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>球状闪电:美妙人生的意义</title>
    <link href="/2022/08/25/%E7%90%83%E7%8A%B6%E9%97%AA%E7%94%B5(%E7%BE%8E%E5%A6%99%E4%BA%BA%E7%94%9F%E7%9A%84%E6%84%8F%E4%B9%89)/"/>
    <url>/2022/08/25/%E7%90%83%E7%8A%B6%E9%97%AA%E7%94%B5(%E7%BE%8E%E5%A6%99%E4%BA%BA%E7%94%9F%E7%9A%84%E6%84%8F%E4%B9%89)/</url>
    
    <content type="html"><![CDATA[<h1 id="球状闪电-美妙人生的意义"><a href="#球状闪电-美妙人生的意义" class="headerlink" title="球状闪电:美妙人生的意义"></a>球状闪电:美妙人生的意义</h1><p>昨天提到最近几天晚上有些失眠,会通过听&lt;&lt;球状闪电&gt;&gt;的有声小说来排遣.</p><p>用另一种方式来重温这一部小说,在唤起一部分旧的回忆时,也有了一些新的感悟.</p><p>为了日后的回忆,特地把自己喜欢的一些片段记录下来,希望再过个3年,再过个30年,有一天我再看这篇记录,可以勾起我的回忆.</p><p>简单的来说,这个系列就像个小学生读后感,或许写的还没有小学生好,</p><p>从序曲部分开始:</p><p>“其实，儿子，过一个美妙的人生并不难，听爸爸教你：你选一个公认的世界难题，最好是只用一张纸和一只铅笔的数学难题，比如歌德巴赫猜想或费尔马大定理什么的，或连纸笔都不要的纯自然哲学难题，比如宇宙的本源之类，投入全部身心钻研，只问耕耘不问收获，不知不觉的专注中，一辈子也就过去了。人们常说的寄托，也就是这么回事。或是相反，把挣钱作为惟一的目标，所有的时间都想着怎么挣，也不问挣来干什么用，到死的时候像葛朗台一样抱者一堆金币说：啊，真暖和啊……<strong>所以，美妙人生的关键在于你能迷上什么东西</strong>。比如我——”爸爸指指房间里到处摆放着的那些小幅水彩画，它们的技法都很传统，画得中规中矩，从中看不出什么灵气来。这些画映着窗外的电光，像一群闪动的屏幕，“我迷上了画画，虽然知道自己成不了梵高。”</p><p>是啊，理想主义者和玩世不恭的人都觉得对方很可怜，可他们实际都很幸运。”妈妈若有所思地说。</p><p>第一次读到这一段话就像一段文字穿透了我的心灵,击碎了心中的我郁结,就像曾经一直困扰我的一个难题,突然便有了一个很简单易懂的答案,简单到你开始怀疑曾经的自己怎么会如此愚笨.  “人生的意义是什么?”这个问题常常会把我们唬住,吓得我们噤若寒蝉,人生,多么宏大的一个字眼,意义多么深邃的拷问,怎么会是我这样渺小的人能够解答的呢,即使心中似乎闪出一些思绪,我也会立刻否定自己,我怎敢自诩为哲学家去回答.</p><p>读完大刘这段话后我才恍然大悟,或许我并不用回答这个问题,我要回答的问题应该是”怎么样使自己的人生有意义”,而这一段话便是一种答案.人生的意义或许有N种答案,但我的人生如何使得它有意义,太多的答案只会缭乱我的双眼,三千弱水我只取一瓢饮,我们要寻找的答案只需要适合自己,而并非是普世性的.</p><p>美妙人生的关键在于你能迷上什么东西,所以,人这一生最好要有追求,我小学时被要求老师背论语时,印象中背过一句”高山仰止,景行行止,虽不能至,然心向往之,”我一直很喜欢这一句话,也知道这句话应该在&lt;&lt;诗经&gt;&gt;中也出现过,有些场合例如同学录要求写自己的座右铭或者赠言时,我会写上这一句话,现在仔细想想,”心向往之”不就是要去追求吗,只不过不同的是&lt;&lt;诗经&gt;&gt;中以及孔老先生他们迷上的”崇高的品行”,我们也可以追求”崇高的品行”,但也可以追求些看似不是那么伟大的.  例如做文中葛朗台或其他. 脑海中突然想起来一个网络上的梗” “,虽然我现在二十出头,但如今想来,这些前辈一定也是早早明白了这个道理,沉浸在自己的一方乐土之中.</p><p>所以,同志们,请时刻记住,美妙人生的关键在于你能迷上什么东西.</p><p>最后说一点悲凉的</p><p><strong>金黄色的森林里分出两条路，</strong></p><p><strong>可惜我们不能同时去涉足，</strong></p><p><strong>但我们却选择了，</strong></p><p><strong>人迹罕至的那一条，</strong></p><p><strong>从此决定了我们的一生。</strong></p><p>这是刘慈欣在其小说《球状闪电》里的一首诗，它改编自美国诗人罗伯特·弗罗斯特《未选择的路》,印象中不止出现了一次,大刘想要渲染小说人物选择追寻球状闪电而不得时的无力感会引用到这首诗.</p><p>如果前一段大刘告诉了我们的该怎么做,那么这部分则是将悲凉的现实也一并告知我们.</p><p> 我们无法想象另一条路—那未曾被选择的路又有着怎样的风景呢?我们更不知道,此刻我们选择的这一条,它将通向何方,前方坎坷几何?</p><p>更为悲凉的是,或许我们走着走着,发现了前辈的足迹,起初我们欣喜若狂,仿佛黑夜中的小船在狂风巨浪中隐约看到一丝灯塔的光芒.</p><p>当我们仔细端详前辈留下的足迹,却发现前辈用自己的鲜血的路旁写着”孩子,停下吧,这是条走不通的路”</p><p>正如俄国人格莫夫也将自己的一生奉献在了冰冷的西伯利亚荒原里，虚耗几十年来追寻球状闪电的秘密，最终一无所获,这样的例子在小说中比比皆是.</p><p>但人生最终还是要乐观,这是我们都清楚的,不是吗?</p><p>真正的英雄主义是认清生活的真相后依然热爱生活啊.</p>]]></content>
    
    
    <categories>
      
      <category>随笔</category>
      
      <category>摘抄</category>
      
    </categories>
    
    
    <tags>
      
      <tag>随笔</tag>
      
      <tag>摘抄</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>听和读</title>
    <link href="/2022/08/24/%E5%A4%A7%E5%9B%9B%E5%BC%80%E5%AD%A6%E7%A2%8E%E7%A2%8E%E5%BF%B5(1)/"/>
    <url>/2022/08/24/%E5%A4%A7%E5%9B%9B%E5%BC%80%E5%AD%A6%E7%A2%8E%E7%A2%8E%E5%BF%B5(1)/</url>
    
    <content type="html"><![CDATA[<h1 id="听和读"><a href="#听和读" class="headerlink" title="听和读"></a>听和读</h1><p>有将近一周没有更新博客了,这段时间倒也不是很慢,只是开学在即,莫名焦虑起来,搞得晚上睡不着觉,进而导致第二天效率很低.</p><p>唉,只能不好意思地给自己放了好几天假,渐渐把状态找回.</p><p>为了补更,索性从谢谢随笔,占个坑位,不然即使等我调整回来,一看一长段时间没更新,更会觉得头疼.</p><p>这几天第一次尝试听有声小说,正好睡不着,找了自己曾经看过的&lt;&lt;球状闪电&gt;&gt;,换一种感官去感受这本小说的魅力……</p><p>第一次阅读这本小说是在大一的第一个寒假,仔细想想不过三年吧,时间虽不长,但说实话小说的细节甚至主要剧情都快想不起来了.</p><p>不得不佩服我的”阅读记忆”力啊……和鱼五五开好吧.</p><p>或许是因为那个假期我看了不少书,有&lt;&lt;三体&gt;&gt;以及大刘的其他科幻作品,印象比较深的是&lt;&lt;乡村教师&gt;&gt;&lt;&lt;朝闻道&gt;&gt;等,甚至那段时间我还把自己关在了自己的房间里–一个几平米的小黑屋看&lt;&lt;百年孤独&gt;&gt;,不知道的还以为我搁那修炼呢,结果最后看了大半本实在不想看了,就改成看科幻小说.一下看的太多,猪脑过载,一下记不住了,我也只能给自己找到这个借口了…</p><p>回到听小说这个话题,对于我来说”听”似乎确实比”看”更有感觉,虽然”听”和”读”带宽的的速率有着很大差距,但或许是我的中央处理器性能太拉,只能开无画质纯语音系统.</p><p>“听”相比于”读”,更让我身临其境,将听到的信息转而构建场景,将自己代入会比读一段信息构建场景自然很多,至少对我来说.</p><p>以我的耐性,我也不会嫌”听”效率太低,毕竟从小到大无论是朋友间的倾诉还是家人间的唠叨,我都”处之泰然”好吧,甚至有些上瘾.</p><p>还记得高中的舍友,晚上睡不着的时候会和我夜聊,不过大多数时候都是他们在聊,我在听,最多做个捧哏.</p><p>其中一个舍友,特别喜欢像我倾诉,尤其是在他经历了一段”刻苦铭心的”爱情后……</p><p>而且本人最大的优点在于只进不出,朋友向我倾诉的心事我都会保密.</p><p>印象中有一次,也就是我那位死党兼舍友,经历了那段”刻苦铭心”的爱情后,那天晚上,在宿舍说着说着,就哭了起来,哭就算了,还要靠在我肩上,就差躺我怀里了…</p><p>这时候自然会发生点误会—宿管阿姨在门外用一种另类的眼光看着我们两…</p><p>那一晚宿管阿姨用一种关爱祖国花朵健康成长的语气语重心长地教导了我们…</p>]]></content>
    
    
    <categories>
      
      <category>随笔</category>
      
      <category>碎碎念</category>
      
    </categories>
    
    
    <tags>
      
      <tag>随笔</tag>
      
      <tag>碎碎念</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>偶然与想象,我看过的最佳日式三集片</title>
    <link href="/2022/08/18/%E5%81%B6%E7%84%B6%E4%B8%8E%E6%83%B3%E8%B1%A1,%E6%88%91%E7%9C%8B%E8%BF%87%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%A5%E5%BC%8F%E4%B8%89%E9%9B%86%E7%89%87/"/>
    <url>/2022/08/18/%E5%81%B6%E7%84%B6%E4%B8%8E%E6%83%B3%E8%B1%A1,%E6%88%91%E7%9C%8B%E8%BF%87%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%A5%E5%BC%8F%E4%B8%89%E9%9B%86%E7%89%87/</url>
    
    <content type="html"><![CDATA[<blockquote><p>那些遗憾,通过一次偶然与想象,得到了弥补</p><table><thead><tr><th>正式海报-西班牙</th><th>正式海报-美国</th></tr></thead><tbody><tr><td><img src="https://gcore.jsdelivr.net/gh/fuchajun/blogImgs/img/202208221151743.webp" style="zoom: 34%;" /></td><td><img src="https://gcore.jsdelivr.net/gh/fuchajun/blogImgs/img/202208221152125.webp" style="zoom: 33%;" /></td></tr></tbody></table><p>豆瓣简介:</p><p>&lt;&lt;偶然与想象&gt;&gt;影片由三个短片构成——《魔法（比魔法更不真切）》《开着的门》《再来一次》。</p><p>女性角色的多重性和镜像性是滨口之前的作品中的主题，在他的新作《偶然与想象》中也是如此。前作《欢乐时光》和《夜以继日》，从字面上看，颇有小说的味道，而《偶然与想象》则可以说是一部短篇小说集。叙事节奏 更强化了这一印象：三集，每集围绕一个女性角色展开，又分为三幕。三个短片讲述了一个意想不到的三角恋、一场未遂的诱惑和一个因误会而相遇的故事。尽管零散，但仍保持了有机的叙事流程，甚至还强调了这一点。虽然大部分的动作都发生在一个空间里，而且只有两个演员参与，这部电影却不让人觉得像一出室内剧。这不仅仅是由于对话的缘故，还在于其复杂的时空概念，最后一集几乎变成了科幻片。我们所见证的时刻都与感人的普遍命运相连，以选择、遗憾、欺骗和巧合为标志，它们是影片真正的主角。</p></blockquote><p>看完这一部日式三集片,给我留下最深刻印象的是影片的最后一集.</p><p>我想,每个人的一生,或多或少都有些许遗憾或后悔.</p><p>那么遗憾和后悔最大的区别是什么呢?</p><p>我觉得在于过程与结果.</p><p>努力了,却无法改变结果,会觉得有些遗憾,但不会后悔,自己已经做了该做的事.</p><p>过程无可挑剔,结果不尽人意,遗憾但不后悔</p><p>本可以努力争取,却退缩了,会遗憾,但更多的是后悔,愧疚自己没做好.</p><p>过程不尽人意,结果更是如此,这就是遗憾与后悔最大的区别吧.</p><p>如果说后悔是对以往所做事情的自责和愧疚.</p><p>那么遗憾的本质是什么呢?</p><p>我认为遗憾是痛心但又没办法补救的东西，让人悔恨终生.</p><p>无法补救,这四个字,击碎了多少人的幻想.</p><p>遗憾在天,后悔在人.</p><p>我宁愿相信这个世界上真的有人,他会不后悔,或许他对待每一件事都能足够认真.</p><p>但会有一个人他没有遗憾吗?</p><p>即使一个人在努力,在有些事面前也会显得无能无力.</p><p>有人说遗憾是生命的本质,我认为这句话有失偏颇.</p><p>遗憾怎么可以和生命的本质想挂钩,但我无法否认,遗憾必然是我们都要经历的,又有那一朵花能够逃脱凋谢的命运呢?</p><p>遗憾无法逃避,也无法补救,但在一次&lt;&lt;偶然与想象&gt;&gt;中,那些遗憾得到了弥补.</p>]]></content>
    
    
    <categories>
      
      <category>随笔</category>
      
      <category>观后有感</category>
      
    </categories>
    
    
    <tags>
      
      <tag>随笔</tag>
      
      <tag>观后有感</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>每周一炼:双指针</title>
    <link href="/2022/08/16/%E6%AF%8F%E5%91%A8%E4%B8%80%E7%82%BC(%E5%8F%8C%E6%8C%87%E9%92%88)/"/>
    <url>/2022/08/16/%E6%AF%8F%E5%91%A8%E4%B8%80%E7%82%BC(%E5%8F%8C%E6%8C%87%E9%92%88)/</url>
    
    <content type="html"><![CDATA[<h1 id="每周一炼-双指针"><a href="#每周一炼-双指针" class="headerlink" title="每周一炼:双指针"></a>每周一炼:双指针</h1><h3 id="什么是双指针（对撞指针、快慢指针-滑动窗口法）"><a href="#什么是双指针（对撞指针、快慢指针-滑动窗口法）" class="headerlink" title="什么是双指针（对撞指针、快慢指针,滑动窗口法）"></a>什么是双指针（对撞指针、快慢指针,滑动窗口法）</h3><p><strong>双指针</strong>，指的是在遍历对象的过程中，不是普通的使用单个指针进行访问，而是使用两个相同方向（<strong><em>快慢指针</em>,滑动窗口法</strong>）或者相反方向（<em><strong>对撞指针</strong></em>）的指针进行扫描，从而达到相应的目的。</p><p>换言之，双指针法充分使用了<strong>数组有序这一特征</strong>，从而在某些情况下能够简化一些运算。</p><p>首先我们要明确的是什么情况下我们应该想到使用双指针,而什么情况下可以排除使用双指针.,二分查找算法的的应用前提如下.</p><h3 id="应用前提条件如下"><a href="#应用前提条件如下" class="headerlink" title="应用前提条件如下:"></a>应用前提条件如下:</h3><p>例如我们在<strong>二分查找</strong>等算法中就要用到碰撞指针。</p><p>具体就是用两个变量动态存储两个或多个结点，来方便我们进行一些操作。</p><p>通常应在<strong>线性的数据结构</strong>中，比如<strong>链表和数组</strong>，有时候也会用在图算法中</p><p>双指针算法其本质<strong>是基于暴力解法的优化</strong></p><h3 id="常见类型"><a href="#常见类型" class="headerlink" title="常见类型:"></a>常见类型:</h3><h4 id="快慢指针"><a href="#快慢指针" class="headerlink" title="快慢指针"></a>快慢指针</h4><p>类似于龟兔赛跑，两个链表上的指针从同一节点出发，两个指针以不同的策略移动，直到两个指针满足某种特殊条件为止(例如相等,或者指针间的子序列大于某个数)，所谓不同的移动策略是指如fast每次增长两个，slow每次增长一个,快慢指针一般起点相同,移动策略不同.</p><p>特点</p><ul><li>快慢指针在同一端开始、往相同方向运动、并以两指针相交 或 单指针遍历完成结束</li><li>快慢指针常用于处理链表或数组中的循环的问题、找链表中点或需要知道特定元素的位置</li></ul><blockquote><p>这类问题一般包括</p><ul><li>计算链表中点</li><li>判断链表是否有环</li><li>判断链表环的起点或长度</li><li>求链表倒是第k个元素</li></ul></blockquote><h4 id="碰撞指针"><a href="#碰撞指针" class="headerlink" title="碰撞指针"></a>碰撞指针</h4><p>对撞指针是指在有序数组中，将指向最左侧的索引定义为左指针(left)，最右侧的定义为右指针(right)，然后从两头向中间进行数组遍历。</p><p>左右指针<strong>通常在数组有序的情况下</strong>，从最小和最大端同时对数组进行处理，对满足特定条件的数组元素进行成对处理，快慢指针逐渐靠拢直至发生碰撞，则遍历完所有数组。</p><p>特点</p><ul><li>对撞指针从两端向中间迭代数组。一个指针从始端开始，另一个从末端开始。</li><li>对撞指针的终止条件是两个指针相遇。</li><li>对撞指针用于已排序的区间</li></ul><blockquote><p>这类问题一般包括</p><ul><li>n数之和</li><li>二分查找</li><li>反转序列</li><li>反转字符串</li></ul></blockquote><h4 id="滑动窗口法"><a href="#滑动窗口法" class="headerlink" title="滑动窗口法"></a>滑动窗口法</h4><p>接下来,数组操作中的另一种重要方法,滑动窗口法</p><p>一般有两个指针,一前一后,形成一个窗口,多窗户内的元素进行逻辑处理.</p><p>所谓滑动窗口，<strong>就是不断的调节子序列的起始位置和终止位置，从而得出我们要想的结果</strong>。</p><p><strong>滑动指针算法思想可以用来解决数组&amp;字符串的子元素等问题。它将嵌套循环的问题，转换为单层循环问题，降低时间复杂度，提高效率。</strong></p><p>特点:</p><ul><li>滑块指针从同一端开始，以相同的方向运动</li><li>用来解决一些查找满足一定条件的连续区间 或 长度 的问题</li><li>窗口只能由左向右滑动，不能逆过来滑动。就是说，窗口的左右边界，只能从左到右增加，不能减少</li></ul><blockquote><p>这类问题一般包括</p><ul><li>字符串匹配问题</li><li>子数组问题</li><li>字串问题</li><li>子序列</li></ul></blockquote><p>接下来写几题简单题练习一下</p><h3 id="27-移除元素"><a href="#27-移除元素" class="headerlink" title="27. 移除元素"></a><strong><a href="https://leetcode.cn/problems/remove-element/">27. 移除元素</a></strong></h3><p>给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。</p><p>不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 原地 修改输入数组。</p><p>元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。</p><figure class="highlight inform7"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><pre><code class="hljs inform7">示例 1：<br><br>输入：nums = <span class="hljs-comment">[3,2,2,3]</span>, val = 3<br>输出：2, nums = <span class="hljs-comment">[2,2]</span><br>解释：函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。你不需要考虑数组中超出新长度后面的元素。例如，函数返回的新长度为 2 ，而 nums = <span class="hljs-comment">[2,2,3,3]</span> 或 nums = <span class="hljs-comment">[2,2,0,0]</span>，也会被视作正确答案。<br></code></pre></td></tr></table></figure><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs dns">示例 <span class="hljs-number">2</span>：<br><br>输入：nums = [<span class="hljs-number">0,1,2,2</span>,<span class="hljs-number">3,0,4,2</span>], val = <span class="hljs-number">2</span><br>输出：<span class="hljs-number">5</span>, nums = [<span class="hljs-number">0,1,4,0</span>,<span class="hljs-number">3</span>]<br>解释：函数应该返回新的长度 <span class="hljs-number">5</span>, 并且 nums 中的前五个元素为 <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">0</span>, <span class="hljs-number">4</span>。注意这五个元素可为任意顺序。你不需要考虑数组中超出新长度后面的元素。<br><br></code></pre></td></tr></table></figure><p>两个for循环暴力法,不是今天的主角,正如前面所说,双指针算法通常会作为暴力解法的优化算法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">removeElement</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> val)</span> &#123;<br>         <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; size; i++) &#123;<br>            <span class="hljs-keyword">if</span> (nums[i] == val) &#123; <span class="hljs-comment">// 发现需要移除的元素，就将数组集体向前移动一位</span><br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i + <span class="hljs-number">1</span>; j &lt; size; j++) &#123;<br>                    nums[j - <span class="hljs-number">1</span>] = nums[j];<br>                &#125;<br>                i--; <span class="hljs-comment">// 因为下标i以后的数值都向前移动了一位，所以i也向前移动一位</span><br>                size--; <span class="hljs-comment">// 此时数组的大小-1</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> size;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">removeElement</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> val)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">slowIndex</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">fastIndex</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; fastIndex &lt; nums.length; fastIndex++) &#123;<br>            <span class="hljs-keyword">if</span> (val != nums[fastIndex]) &#123;<br>                nums[slowIndex++] = nums[fastIndex];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> slowIndex;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="209-长度最小的子数组"><a href="#209-长度最小的子数组" class="headerlink" title="209. 长度最小的子数组"></a><a href="https://leetcode.cn/problems/minimum-size-subarray-sum/">209. 长度最小的子数组</a></h3><p>给定一个含有 n 个正整数的数组和一个正整数 target 。</p><p>找出该数组中满足其和 ≥ target 的长度最小的 连续子数组 [numsl, numsl+1, …, numsr-1, numsr] ，并返回其长度。如果不存在符合条件的子数组，返回 0 。</p><p>我们都知道,暴力解法中我们需要两个for循环,一个for循环对应数组的起始位置,一个for循环对应数组的终止位置</p><p>那么,在滑动窗口法中我们应该如何用一个for循环加两个指针能代替上面的操作呢?</p><p>首先要思考 如果用一个for循环，那么应该表示 滑动窗口的起始位置，还是终止位置。</p><p>如果只用一个for循环来表示 滑动窗口的起始位置，那么如何遍历剩下的终止位置？</p><p>此时难免再次陷入 暴力解法的怪圈。</p><p>所以 只用一个for循环，那么这个循环的索引，一定是表示 滑动窗口的终止位置。</p><p>那么问题来了， 滑动窗口的起始位置如何移动呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><br>    <span class="hljs-comment">// 滑动窗口</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minSubArrayLen</span><span class="hljs-params">(<span class="hljs-type">int</span> s, <span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> Integer.MAX_VALUE;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; right &lt; nums.length; right++) &#123;<br>            sum += nums[right];<br>            <span class="hljs-keyword">while</span> (sum &gt;= s) &#123;<br>                result = Math.min(result, right - left + <span class="hljs-number">1</span>);<br>                sum -= nums[left++];<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">return</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span>= Integer.MAX_VALUE ? <span class="hljs-number">0</span> : result;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章:"></a>参考文章:</h3><p>​                <a href="https://hk029.gitbooks.io/leetbook/content/twopoint.html">《LeetBook》双指针</a></p><p>​                <a href="https://zhuanlan.zhihu.com/p/71643340">算法一招鲜——双指针问题 - 知乎 (zhihu.com)</a></p><p>​                <a href="https://zhuanlan.zhihu.com/p/95747836">算法 | 双指针套路总结 - 知乎 (zhihu.com)</a></p><p>​                <a href="https://programmercarl.com/0209.%E9%95%BF%E5%BA%A6%E6%9C%80%E5%B0%8F%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84.html#%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3">代码随想录 (programmercarl.com)</a></p>]]></content>
    
    
    <categories>
      
      <category>每周一炼</category>
      
      <category>Leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>二分查找</tag>
      
      <tag>Leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>每日一烤:Vue中v-for时为什么要绑定key？</title>
    <link href="/2022/08/12/Vue%E4%B8%AD%E7%9A%84v-for%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%BB%91%E5%AE%9Akey%E5%80%BC/"/>
    <url>/2022/08/12/Vue%E4%B8%AD%E7%9A%84v-for%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%BB%91%E5%AE%9Akey%E5%80%BC/</url>
    
    <content type="html"><![CDATA[<h1 id="Vue中v-for时为什么要绑定key？"><a href="#Vue中v-for时为什么要绑定key？" class="headerlink" title="Vue中v-for时为什么要绑定key？"></a>Vue中v-for时为什么要绑定key？</h1><blockquote><p>对于这个问题,我也不是很清楚,似乎大家都建议绑定key,所以最简单的方式就是随大众绑定key,既然要绑定key,我们需要问两个问题!!!</p><p>1.绑定v-for的key是不是意味着效率高？！！</p><p>2.key的值应该和谁进行绑定呢?</p><p>对于上面的这两个问题</p><p>我这里先给出结论.</p></blockquote><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><h3 id="绑定v-for的key是不是意味着效率高？！！"><a href="#绑定v-for的key是不是意味着效率高？！！" class="headerlink" title="绑定v-for的key是不是意味着效率高？！！"></a>绑定v-for的key是不是意味着效率高？！！</h3><p>​    1.如果是给数组中间或其他类型中间插入或者修改一个元素，key值为唯一标识的确效率高些。</p><p>​    2.其他情况下绑定key的效率未必会高</p><p>​        <code>v-for</code>默认使用<strong>就地复用策略</strong>，列表数据修改的时候，他会根据key值去判断某个值是否修改，如果修改，则重新渲染这一项，否则复用之前的元素,如果不绑定key的话,每次修改某一条数据,都会重新渲染所有数据,会导致大量内存的浪费。如果绑定了key，每次修改某一条数据的时候，就只会重新渲染改条数据的变化，节省了大量的内存。</p><p>​        这也很好解释了为什么Vue源码怎么不直接设置<code>key=Date.now()</code>,即默认唯一标识,因为并不是所有情况下都需要将key绑定为唯一标识.</p><h3 id="那么如何设置v-for的key的值"><a href="#那么如何设置v-for的key的值" class="headerlink" title="那么如何设置v-for的key的值"></a>那么如何设置v-for的key的值</h3><ol><li><p>如果已渲染的列表元素下标不会变化，key值设置为index即可</p></li><li><p>如果已渲染的列表元素下标会变化，key值请设置为唯一标识,例如id</p></li></ol><h5 id="参考文章链接"><a href="#参考文章链接" class="headerlink" title="参考文章链接:"></a>参考文章链接:</h5><p>​                    [Vue v-for的key值如何设置？](<a href="https://www.cnblogs.com/kaicy/p/15079045.html">Vue v-for的key值如何设置？ - Kaicy - 博客园 (cnblogs.com)</a>)</p><p>​                    [Vue中v-for时为什么要绑定key?](<a href="https://juejin.cn/post/6997792097084375054">Vue中v-for时为什么要绑定key？ - 掘金 (juejin.cn)</a>)</p><p>​    </p>]]></content>
    
    
    <categories>
      
      <category>每日一烤</category>
      
      <category>Vue</category>
      
    </categories>
    
    
    <tags>
      
      <tag>每日一烤</tag>
      
      <tag>Vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>每日一烤:vue2和vue3的v-if与v-for优先级对比学习</title>
    <link href="/2022/08/10/vue2%E5%92%8Cvue3%E7%9A%84v-if%E4%B8%8Ev-for%E4%BC%98%E5%85%88%E7%BA%A7%E5%AF%B9%E6%AF%94%E5%AD%A6%E4%B9%A0/"/>
    <url>/2022/08/10/vue2%E5%92%8Cvue3%E7%9A%84v-if%E4%B8%8Ev-for%E4%BC%98%E5%85%88%E7%BA%A7%E5%AF%B9%E6%AF%94%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="vue2和vue3的v-if与v-for优先级对比学习"><a href="#vue2和vue3的v-if与v-for优先级对比学习" class="headerlink" title="vue2和vue3的v-if与v-for优先级对比学习"></a>vue2和vue3的v-if与v-for优先级对比学习</h1><h2 id="起"><a href="#起" class="headerlink" title="起"></a>起</h2><p>v-if和v-for是Vue中最常用的几个指令,[Vue官方文档](<a href="https://v3.cn.vuejs.org/guide/list.html#v-for-%E4%B8%8E-v-if-%E4%B8%80%E5%90%8C%E4%BD%BF%E7%94%A8">列表渲染 | Vue.js (vuejs.org)</a>)的有提到不建议将这两个指令写在同一个标签内.</p><h2 id="承"><a href="#承" class="headerlink" title="承"></a>承</h2><p>既然如此,想必我们就不得不讨论一下它们哥俩的工作方式,尤其是优先级.</p><p>为此,我们先假定一个案例</p><p>假设我们想要实现一个极简的 todoList 效果</p><img src="C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20220805113527161.png" alt="image-20220805113527161" style="zoom: 50%;" /><p>首先我们的有一个list</p><figure class="highlight javascript"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> todoList = [<br>  &#123;<br>    <span class="hljs-attr">id</span>: <span class="hljs-number">0</span>,<br>    <span class="hljs-attr">task</span>: <span class="hljs-string">&#x27;吃饭&#x27;</span>,<br>    <span class="hljs-attr">done</span>: <span class="hljs-literal">true</span>,<br>  &#125;,<br>  &#123;<br>    <span class="hljs-attr">id</span>: <span class="hljs-number">1</span>,<br>    <span class="hljs-attr">task</span>: <span class="hljs-string">&#x27;睡觉&#x27;</span>,<br>    <span class="hljs-attr">done</span>: <span class="hljs-literal">false</span>,<br>  &#125;,<br>  &#123;<br>    <span class="hljs-attr">id</span>: <span class="hljs-number">2</span>,<br>    <span class="hljs-attr">task</span>: <span class="hljs-string">&#x27;洗澡&#x27;</span>,<br>    <span class="hljs-attr">done</span>: <span class="hljs-literal">true</span>,<br>  &#125;,<br>  <span class="hljs-comment">// ...,</span><br>];<br></code></pre></td></tr></table></figure><h2 id="转"><a href="#转" class="headerlink" title="转"></a>转</h2><p>果然,对于他们两的优先级问题,官方也曾纠结过,</p><p>在Vue2.X版本中,v-for的优先级高于v-if,但在Vue3.x的版本中v-if的优先级高于v-for</p><p>在 vue2 中，<code>v-for</code> 优先级高于 <code>v-if</code>，我们可以这样实现：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span><br>  <span class="hljs-comment">&lt;!-- vue2中，v-for优先级高于v-if --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;item in todoList&quot;</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">&quot;!item.done&quot;</span> <span class="hljs-attr">:class</span>=<span class="hljs-string">&quot;&#123;todo: !item.done&#125;&quot;</span> <span class="hljs-attr">:key</span>=<span class="hljs-string">&quot;item.id&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>&#123;&#123;item.task&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;item in todoList&quot;</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">&quot;item.done&quot;</span> <span class="hljs-attr">:class</span>=<span class="hljs-string">&quot;&#123;finished: item.done&#125;&quot;</span> <span class="hljs-attr">:key</span>=<span class="hljs-string">&quot;item.id&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>&#123;&#123;item.task&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br></code></pre></td></tr></table></figure><p>在 vue3 中，由于 <code>v-if</code> 优先级要高于 <code>v-for</code>，所以不能像 vue2 那样将 <code>v-for</code> 和 <code>v-if</code> 放在同一个元素上，我们在 <code>li</code> 外面套一层用来执行 for 循环：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;item in list&quot;</span> <span class="hljs-attr">:key</span>=<span class="hljs-string">&quot;item.id&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">&quot;!item.done&quot;</span> <span class="hljs-attr">:class</span>=<span class="hljs-string">&quot;&#123;todo: !item.done&#125;&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>&#123;&#123;item.task&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;item in list&quot;</span> <span class="hljs-attr">:key</span>=<span class="hljs-string">&quot;item.id&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">&quot;item.done&quot;</span> <span class="hljs-attr">:class</span>=<span class="hljs-string">&quot;&#123;finished: item.done&#125;&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>&#123;&#123;item.task&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br>复制代码<br></code></pre></td></tr></table></figure><p>可以看出，如果在 vue2.x 中 <code>v-if</code> 和 <code>v-for</code> 在同一个元素上使用是无法直接在 vue3.x 中兼容的。</p><h4 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h4><p>针对 <code>v-if</code> 和 <code>v-for</code> 的使用，其实官方是建议我们使用计算属性来处理的，这样既提高了性能，又可以兼容到 vue3.x，</p><p>但是我目前还没有学到计算属性,改日再来看</p><p>接下来我们看看计算属性实现方式：</p><p>模板部分：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span><br>  <span class="hljs-comment">&lt;!--  最佳实践  --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">ul</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;todo-list&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;item in todos&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;todo&quot;</span> <span class="hljs-attr">:key</span>=<span class="hljs-string">&quot;item.id&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>&#123;&#123;item.task&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br><br>  <span class="hljs-tag">&lt;<span class="hljs-name">ul</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">&quot;showFinished&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;item in finished&quot;</span> <span class="hljs-attr">:key</span>=<span class="hljs-string">&quot;item.id&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;finished&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>&#123;&#123;item.task&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br><br>  <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span><br>    show finished？<br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;checkbox&quot;</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;showFinished&quot;</span> /&gt;</span><br>    &#123;&#123;showFinished ? &#x27;yes&#x27; : &#x27;no&#x27;&#125;&#125;<br>  <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>复制代码<br></code></pre></td></tr></table></figure><p>js 部分：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// vue3.x</span><br><span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">createApp</span>(&#123;<br>  <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> &#123;<br>      <span class="hljs-attr">msg</span>: <span class="hljs-string">&#x27;Todo List&#x27;</span>,<br>      <span class="hljs-attr">showFinished</span>: <span class="hljs-literal">true</span>,<br>      <span class="hljs-attr">list</span>: todoList,<br>    &#125;;<br>  &#125;,<br>  <span class="hljs-attr">computed</span>: &#123;<br>    <span class="hljs-title function_">finished</span>(<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-keyword">return</span> todoList.<span class="hljs-title function_">filter</span>(<span class="hljs-function"><span class="hljs-params">t</span> =&gt;</span> t.<span class="hljs-property">done</span>);<br>    &#125;,<br>    <span class="hljs-title function_">todos</span>(<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-keyword">return</span> todoList.<span class="hljs-title function_">filter</span>(<span class="hljs-function"><span class="hljs-params">t</span> =&gt;</span> !t.<span class="hljs-property">done</span>);<br>    &#125;,<br>  &#125;,<br>&#125;).<span class="hljs-title function_">mount</span>(<span class="hljs-string">&#x27;#app&#x27;</span>);<br><br><span class="hljs-comment">// vue2.x</span><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;<br>  <span class="hljs-attr">el</span>: <span class="hljs-string">&#x27;#app&#x27;</span>,<br>  <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> &#123;<br>      <span class="hljs-attr">msg</span>: <span class="hljs-string">&#x27;Todo List&#x27;</span>,<br>      <span class="hljs-attr">showFinished</span>: <span class="hljs-literal">true</span>,<br>      <span class="hljs-attr">list</span>: todoList,<br>    &#125;;<br>  &#125;,<br>  <span class="hljs-attr">computed</span>: &#123;<br>    <span class="hljs-title function_">finished</span>(<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-keyword">return</span> todoList.<span class="hljs-title function_">filter</span>(<span class="hljs-function"><span class="hljs-params">t</span> =&gt;</span> t.<span class="hljs-property">done</span>);<br>    &#125;,<br>    <span class="hljs-title function_">todos</span>(<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-keyword">return</span> todoList.<span class="hljs-title function_">filter</span>(<span class="hljs-function"><span class="hljs-params">t</span> =&gt;</span> !t.<span class="hljs-property">done</span>);<br>    &#125;,<br>  &#125;,<br>&#125;);<br></code></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>vue2.x 中<code>v-for</code>优先级高于<code>v-if</code>，vue3.x 相反；</li><li>尽量避免在同一个元素上面同时使用<code>v-if</code>和<code>v-for</code>，建议使用计算属性替代。</li></ol><p>参考文章链接：<a href="https://juejin.cn/post/6881581395068747790">https://juejin.cn/post/6881581395068747790</a></p>]]></content>
    
    
    <categories>
      
      <category>每日一烤</category>
      
      <category>Vue</category>
      
    </categories>
    
    
    <tags>
      
      <tag>每日一烤</tag>
      
      <tag>Vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue学习笔记(2)</title>
    <link href="/2022/08/08/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(2)/"/>
    <url>/2022/08/08/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(2)/</url>
    
    <content type="html"><![CDATA[<h1 id="Vue学习笔记-2"><a href="#Vue学习笔记-2" class="headerlink" title="Vue学习笔记(2)"></a>Vue学习笔记(2)</h1><p><a href="https://v3.cn.vuejs.org/guide/introduction.html">参考文档:Vue官方文档教程</a></p><h2 id="事件处理"><a href="#事件处理" class="headerlink" title="事件处理"></a>事件处理</h2><p>我们可以使用 <code>v-on</code> 指令 (通常缩写为 <code>@</code> 符号) 来监听 DOM 事件，并在触发事件时执行一些 JavaScript。用法为 <code>v-on:click=&quot;methodName&quot;</code> 或使用快捷方式 <code>@click=&quot;methodName&quot;</code></p><figure class="highlight html"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;basic-event&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;counter += 1&quot;</span>&gt;</span>Add 1<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>The button above has been clicked &#123;&#123; counter &#125;&#125; times.<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">createApp</span>(&#123;</span><br><span class="language-javascript">  <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">    <span class="hljs-keyword">return</span> &#123;</span><br><span class="language-javascript">      <span class="hljs-attr">counter</span>: <span class="hljs-number">0</span></span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript">  &#125;</span><br><span class="language-javascript">&#125;).<span class="hljs-title function_">mount</span>(<span class="hljs-string">&#x27;#basic-event&#x27;</span>)</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="事件处理方法"><a href="#事件处理方法" class="headerlink" title="事件处理方法"></a>事件处理方法</h3><p>然而许多事件处理逻辑会更为复杂，所以直接把 JavaScript 代码写在 <code>v-on</code> 指令中是不可行的。因此 <code>v-on</code> 还可以接收一个需要调用的方法名称。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;event-with-method&quot;</span>&gt;</span><br>  <span class="hljs-comment">&lt;!-- `greet` 是在下面定义的方法名 --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;greet&quot;</span>&gt;</span>Greet<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">createApp</span>(&#123;<br>  <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> &#123;<br>      <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Vue.js&#x27;</span><br>    &#125;<br>  &#125;,<br>  <span class="hljs-attr">methods</span>: &#123;<br>    <span class="hljs-title function_">greet</span>(<span class="hljs-params">event</span>) &#123;<br>      <span class="hljs-comment">// `methods` 内部的 `this` 指向当前活动实例</span><br>      <span class="hljs-title function_">alert</span>(<span class="hljs-string">&#x27;Hello &#x27;</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> + <span class="hljs-string">&#x27;!&#x27;</span>)<br>      <span class="hljs-comment">// `event` 是原生 DOM event</span><br>      <span class="hljs-keyword">if</span> (event) &#123;<br>        <span class="hljs-title function_">alert</span>(event.<span class="hljs-property">target</span>.<span class="hljs-property">tagName</span>)<br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;).<span class="hljs-title function_">mount</span>(<span class="hljs-string">&#x27;#event-with-method&#x27;</span>)<br></code></pre></td></tr></table></figure><h3 id="内联处理器中的方法"><a href="#内联处理器中的方法" class="headerlink" title="内联处理器中的方法"></a>内联处理器中的方法</h3><p>除了直接绑定到一个方法，也可以在内联 JavaScript 语句中调用方法</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;inline-handler&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;say(&#x27;hi&#x27;)&quot;</span>&gt;</span>Say hi<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;say(&#x27;what&#x27;)&quot;</span>&gt;</span>Say what<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">createApp</span>(&#123;<br>  <span class="hljs-attr">methods</span>: &#123;<br>    <span class="hljs-title function_">say</span>(<span class="hljs-params">message</span>) &#123;<br>      <span class="hljs-title function_">alert</span>(message)<br>    &#125;<br>  &#125;<br>&#125;).<span class="hljs-title function_">mount</span>(<span class="hljs-string">&#x27;#inline-handler&#x27;</span>)<br></code></pre></td></tr></table></figure><p>有时也需要在内联语句处理器中访问原始的 DOM 事件。可以用特殊变量 <code>$event</code> 把它传入方法：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;warn(&#x27;Form cannot be submitted yet.&#x27;, $event)&quot;</span>&gt;</span><span class="hljs-comment">&lt;!--&lt;button @click=&quot;add(1,2,$event)&quot;&gt;Add1&lt;/button&gt;</span><br><span class="hljs-comment">  Submit</span><br><span class="hljs-comment">&lt;/button&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// ...</span><br><span class="hljs-attr">methods</span>: &#123;<br>  <span class="hljs-title function_">warn</span>(<span class="hljs-params">message, event</span>) &#123;<br>    <span class="hljs-comment">// 现在可以访问到原生事件</span><br>    <span class="hljs-keyword">if</span> (event) &#123;<br>      event.<span class="hljs-title function_">preventDefault</span>()<br>    &#125;<br>    <span class="hljs-title function_">alert</span>(message)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="多事件处理器"><a href="#多事件处理器" class="headerlink" title="多事件处理器"></a>多事件处理器</h3><blockquote><p>不建议使用,你为啥要把它分成两个方法,最后又由一个事件调用,不如要么写成一个方法,要么交由两个事件调用</p></blockquote><p>事件处理程序中可以有多个方法，这些方法由逗号运算符分隔：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- 这两个 one() 和 two() 将执行按钮点击事件 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;one($event), two($event)&quot;</span>&gt;</span><br>  Submit<br><span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// ...</span><br><span class="hljs-attr">methods</span>: &#123;<br>  <span class="hljs-title function_">one</span>(<span class="hljs-params">event</span>) &#123;<br>    <span class="hljs-comment">// 第一个事件处理器逻辑...</span><br>  &#125;,<br>  <span class="hljs-title function_">two</span>(<span class="hljs-params">event</span>) &#123;<br>   <span class="hljs-comment">// 第二个事件处理器逻辑...</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="按键修饰符"><a href="#按键修饰符" class="headerlink" title="按键修饰符"></a>按键修饰符</h3><h3 id="exact-修饰符"><a href="#exact-修饰符" class="headerlink" title=".exact 修饰符"></a><code>.exact</code> 修饰符</h3><p><code>.exact</code> 修饰符允许你控制由精确的系统修饰符组合触发的事件。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- 即使 Alt 或 Shift 被一同按下时也会触发 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click.ctrl</span>=<span class="hljs-string">&quot;onClick&quot;</span>&gt;</span>A<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- 有且只有 Ctrl 被按下的时候才触发 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click.ctrl.exact</span>=<span class="hljs-string">&quot;onCtrlClick&quot;</span>&gt;</span>A<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- 没有任何系统修饰符被按下的时候才触发 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click.exact</span>=<span class="hljs-string">&quot;onClick&quot;</span>&gt;</span>A<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="鼠标按钮修饰符"><a href="#鼠标按钮修饰符" class="headerlink" title="鼠标按钮修饰符"></a>鼠标按钮修饰符</h3><ul><li><code>.left</code></li><li><code>.right</code></li><li><code>.middle</code></li></ul><p>这些修饰符会限制处理函数仅响应特定的鼠标按钮。</p><p>在监听键盘事件时，我们经常需要检查特定的按键。Vue 允许为 <code>v-on</code> 或者 <code>@</code> 在监听键盘事件时添加按键修饰符：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- 只有在 `key` 是 `Enter` 时调用 `vm.submit()` --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">input</span> @<span class="hljs-attr">keyup.enter</span>=<span class="hljs-string">&quot;submit&quot;</span> /&gt;</span><br></code></pre></td></tr></table></figure><p>你可以直接将 <a href="https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key/Key_Values"><code>KeyboardEvent.key</code></a> 暴露的任意有效按键名转换为 kebab-case 来作为修饰符。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> @<span class="hljs-attr">keyup.page-down</span>=<span class="hljs-string">&quot;onPageDown&quot;</span> /&gt;</span><br></code></pre></td></tr></table></figure><p>在上述示例中，处理函数只会在 <code>$event.key</code> 等于 <code>&#39;PageDown&#39;</code> 时被调用。</p><h3 id="按键别名"><a href="#按键别名" class="headerlink" title="#按键别名"></a><a href="https://v3.cn.vuejs.org/guide/events.html#%E6%8C%89%E9%94%AE%E5%88%AB%E5%90%8D">#</a>按键别名</h3><p>Vue 为最常用的键提供了别名：</p><ul><li><p><code>.enter</code></p></li><li><p><code>.tab</code></p></li><li><p><code>.delete</code> (捕获“删除”和“退格”键)</p></li><li><p><code>.esc</code></p></li><li><p><code>.space</code></p></li><li><p><code>.up</code></p></li><li><p><code>.down</code></p></li><li><p><code>.left</code></p></li><li><p><code>.right</code></p></li></ul><h3 id="系统修饰键"><a href="#系统修饰键" class="headerlink" title="系统修饰键"></a>系统修饰键</h3><p>可以用如下修饰符来实现仅在按下相应按键时才触发鼠标或键盘事件的监听器。</p><ul><li><code>.ctrl</code></li><li><code>.alt</code></li><li><code>.shift</code></li><li><code>.meta</code></li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click.middle</span>=<span class="hljs-string">&quot;add(1,2,$event)&quot;</span>&gt;</span>Add 1<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;add(2,5,$event)&quot;</span>&gt;</span>Add 2<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>The button above has been clicked &#123;&#123; counter &#125;&#125; times.<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> @<span class="hljs-attr">keyup.enter.exact</span>=<span class="hljs-string">&quot;submit&quot;</span> @<span class="hljs-attr">keyup.alt.enter</span>=<span class="hljs-string">&quot;clear&quot;</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;inputVal&quot;</span>/&gt;</span><span class="hljs-comment">&lt;!--双向绑定,下一章具体介绍--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>&#123;&#123;inputVal&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-comment">&lt;!--双向绑定,下一章具体介绍--&gt;</span><br><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">        <span class="hljs-keyword">const</span> <span class="hljs-title class_">App</span> = &#123;</span><br><span class="language-javascript">            <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">                <span class="hljs-keyword">return</span> &#123;</span><br><span class="language-javascript">                    <span class="hljs-attr">counter</span>:<span class="hljs-number">1</span>,</span><br><span class="language-javascript">                    <span class="hljs-attr">inputVal</span>:<span class="hljs-string">&quot;&quot;</span><span class="hljs-comment">//&lt;!--双向绑定,下一章具体介绍--&gt;</span></span><br><span class="language-javascript">                &#125;</span><br><span class="language-javascript">            &#125;,</span><br><span class="language-javascript">            <span class="hljs-attr">methods</span>:&#123;</span><br><span class="language-javascript">                <span class="hljs-title function_">add</span>(<span class="hljs-params">val,val2,event</span>)&#123;</span><br><span class="language-javascript">                    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(event);</span><br><span class="language-javascript">                    <span class="hljs-variable language_">this</span>.<span class="hljs-property">counter</span> += val * val2 ;</span><br><span class="language-javascript">                &#125;,</span><br><span class="language-javascript">                <span class="hljs-title function_">submit</span>(<span class="hljs-params"></span>)&#123;</span><br><span class="language-javascript">                    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;onsubmit&quot;</span>);</span><br><span class="language-javascript">                &#125;,</span><br><span class="language-javascript">                <span class="hljs-title function_">clear</span>(<span class="hljs-params"></span>)&#123;</span><br><span class="language-javascript">                    <span class="hljs-variable language_">this</span>.<span class="hljs-property">inputVal</span> = <span class="hljs-string">&quot;&quot;</span></span><br><span class="language-javascript">                &#125;</span><br><span class="language-javascript">            &#125;</span><br><span class="language-javascript">        &#125;</span><br><span class="language-javascript">        <span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">createApp</span>(<span class="hljs-title class_">App</span>).<span class="hljs-title function_">mount</span>(<span class="hljs-string">&#x27;#app&#x27;</span>)</span><br><span class="language-javascript">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="表单输入绑定"><a href="#表单输入绑定" class="headerlink" title="表单输入绑定"></a>表单输入绑定</h2><h3 id="基础用法"><a href="#基础用法" class="headerlink" title="基础用法"></a>基础用法</h3><p>你可以用 v-model 指令在表单 <code>&lt;input&gt;</code>、<code>&lt;textarea&gt;</code> 及 <code>&lt;select&gt;</code> 元素上创建双向数据绑定。它会根据控件类型自动选取正确的方法来更新元素。尽管有些神奇，但 <code>v-model</code> 本质上不过是语法糖。它负责监听用户的输入事件来更新数据，并在某种极端场景下进行一些特殊处理。</p><blockquote><p><strong><code>v-model</code> 会忽略所有表单元素的 <code>value</code>、<code>checked</code>、<code>selected</code> attribute 的初始值。它将始终将当前活动实例的数据作为数据来源。你应该通过 JavaScript 在组件的 <code>data</code> 选项中声明初始值。</strong></p></blockquote><p><code>v-model</code> 在内部为不同的输入元素使用不同的 property 并抛出不同的事件：</p><ul><li><p>text 和 textarea 元素使用 <code>value</code> property 和 <code>input</code> 事件；</p></li><li><p>checkbox 和 radio 使用 <code>checked</code> property 和 <code>change</code> 事件；</p></li><li><p>select 字段将 <code>value</code> 作为 prop 并将 <code>change</code> 作为事件。</p></li></ul><h3 id="文本-Text"><a href="#文本-Text" class="headerlink" title="文本 (Text)"></a>文本 (Text)</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;v-model-basic&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;demo&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;message&quot;</span> <span class="hljs-attr">placeholder</span>=<span class="hljs-string">&quot;edit me&quot;</span> /&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Message is: &#123;&#123; message &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">createApp</span>(&#123;</span><br><span class="language-javascript">  <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">    <span class="hljs-keyword">return</span> &#123;</span><br><span class="language-javascript">      <span class="hljs-attr">message</span>: <span class="hljs-string">&#x27;&#x27;</span></span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript">  &#125;</span><br><span class="language-javascript">&#125;).<span class="hljs-title function_">mount</span>(<span class="hljs-string">&#x27;#v-model-basic&#x27;</span>)</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="多行文本-Textarea"><a href="#多行文本-Textarea" class="headerlink" title="多行文本 (Textarea)"></a>多行文本 (Textarea)</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;v-model-textarea&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;demo&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>Multiline message is:<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;white-space: pre-line;&quot;</span>&gt;</span>&#123;&#123; message &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">br</span> /&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">textarea</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;message&quot;</span> <span class="hljs-attr">placeholder</span>=<span class="hljs-string">&quot;add multiple lines&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">textarea</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">createApp</span>(&#123;</span><br><span class="language-javascript">  <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">    <span class="hljs-keyword">return</span> &#123;</span><br><span class="language-javascript">      <span class="hljs-attr">message</span>: <span class="hljs-string">&#x27;&#x27;</span></span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript">  &#125;</span><br><span class="language-javascript">&#125;).<span class="hljs-title function_">mount</span>(<span class="hljs-string">&#x27;#v-model-textarea&#x27;</span>)</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>插值在 textarea 中不起作用，请使用 <code>v-model</code> 来代替。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- bad --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">textarea</span>&gt;</span>&#123;&#123; text &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">textarea</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- good --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">textarea</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;text&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">textarea</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="复选框-Checkbox"><a href="#复选框-Checkbox" class="headerlink" title="复选框 (Checkbox)"></a>复选框 (Checkbox)</h3><p>单个复选框，绑定到布尔值：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;v-model-checkbox&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;demo&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;checkbox&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;checkbox&quot;</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;checked&quot;</span> /&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">&quot;checkbox&quot;</span>&gt;</span>&#123;&#123; checked &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">createApp</span>(&#123;</span><br><span class="language-javascript">  <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">    <span class="hljs-keyword">return</span> &#123;</span><br><span class="language-javascript">      <span class="hljs-attr">checked</span>: <span class="hljs-literal">false</span></span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript">  &#125;</span><br><span class="language-javascript">&#125;).<span class="hljs-title function_">mount</span>(<span class="hljs-string">&#x27;#v-model-checkbox&#x27;</span>)</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>多个复选框，绑定到同一个数组：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;v-model-multiple-checkboxes&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;checkbox&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;jack&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;Jack&quot;</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;checkedNames&quot;</span> /&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">&quot;jack&quot;</span>&gt;</span>Jack<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;checkbox&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;john&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;John&quot;</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;checkedNames&quot;</span> /&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">&quot;john&quot;</span>&gt;</span>John<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;checkbox&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;mike&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;Mike&quot;</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;checkedNames&quot;</span> /&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">&quot;mike&quot;</span>&gt;</span>Mike<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">br</span> /&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>Checked names: &#123;&#123; checkedNames &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">createApp</span>(&#123;<br>  <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> &#123;<br>      <span class="hljs-attr">checkedNames</span>: []<br>    &#125;<br>  &#125;<br>&#125;).<span class="hljs-title function_">mount</span>(<span class="hljs-string">&#x27;#v-model-multiple-checkboxes&#x27;</span>)<br></code></pre></td></tr></table></figure><h2 id="Class-与-Style-绑定"><a href="#Class-与-Style-绑定" class="headerlink" title="Class 与 Style 绑定"></a>Class 与 Style 绑定</h2><p>操作元素的 class 列表和内联样式是数据绑定的一个常见需求。因为它们都是 attribute，所以我们可以用 <code>v-bind</code> 处理它们：只需要通过表达式计算出字符串结果即可。不过，字符串拼接麻烦且易错。因此，在将 <code>v-bind</code> 用于 <code>class</code> 和 <code>style</code> 时，Vue.js 做了专门的增强。表达式结果的类型除了字符串之外，还可以是对象或数组。</p><h3 id="绑定-HTML-Class"><a href="#绑定-HTML-Class" class="headerlink" title="绑定 HTML Class"></a>绑定 HTML Class</h3><h3 id="对象语法"><a href="#对象语法" class="headerlink" title="对象语法"></a>对象语法</h3><p>我们可以传给 <code>:class</code> (<code>v-bind:class</code> 的简写) 一个对象，以动态地切换 class：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">:class</span>=<span class="hljs-string">&quot;&#123; active: isActive &#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><p>上面的语法表示 <code>active</code> 这个 class 存在与否将取决于 data property <code>isActive</code> 的 <a href="https://developer.mozilla.org/en-US/docs/Glossary/Truthy">truthiness</a>。</p><p>你可以在对象中传入更多字段来动态切换多个 class。此外，<code>:class</code> 指令也可以与普通的 <code>class</code> attribute 共存。当有如下模板：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span></span><br><span class="hljs-tag">  <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;static&quot;</span></span><br><span class="hljs-tag">  <span class="hljs-attr">:class</span>=<span class="hljs-string">&quot;&#123; active: isActive, &#x27;text-danger&#x27;: hasError &#125;&quot;</span></span><br><span class="hljs-tag">&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><p>和如下 data：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> &#123;<br>    <span class="hljs-attr">isActive</span>: <span class="hljs-literal">true</span>,<br>    <span class="hljs-attr">hasError</span>: <span class="hljs-literal">false</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>渲染的结果为：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;static active&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><p>当 <code>isActive</code> 或者 <code>hasError</code> 变化时，class 列表将相应地更新。例如，如果 <code>hasError</code> 的值为 <code>true</code>，class 列表将变为 <code>&quot;static active text-danger&quot;</code>。</p><p>绑定的数据对象不必内联定义在模板里：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">:class</span>=<span class="hljs-string">&quot;classObject&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> &#123;<br>    <span class="hljs-attr">classObject</span>: &#123;<br>      <span class="hljs-attr">active</span>: <span class="hljs-literal">true</span>,<br>      <span class="hljs-string">&#x27;text-danger&#x27;</span>: <span class="hljs-literal">false</span><br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>渲染的结果和上面一样。我们也可以在这里绑定一个返回对象的<a href="https://v3.cn.vuejs.org/guide/computed.html">计算属性</a>。这是一个常用且强大的模式：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">:class</span>=<span class="hljs-string">&quot;classObject&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> &#123;<br>    <span class="hljs-attr">isActive</span>: <span class="hljs-literal">true</span>,<br>    <span class="hljs-attr">error</span>: <span class="hljs-literal">null</span><br>  &#125;<br>&#125;,<br><span class="hljs-attr">computed</span>: &#123;<br>  <span class="hljs-title function_">classObject</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> &#123;<br>      <span class="hljs-attr">active</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">isActive</span> &amp;&amp; !<span class="hljs-variable language_">this</span>.<span class="hljs-property">error</span>,<br>      <span class="hljs-string">&#x27;text-danger&#x27;</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">error</span> &amp;&amp; <span class="hljs-variable language_">this</span>.<span class="hljs-property">error</span>.<span class="hljs-property">type</span> === <span class="hljs-string">&#x27;fatal&#x27;</span><br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="数组语法"><a href="#数组语法" class="headerlink" title="数组语法"></a>数组语法</h3><p>我们可以把一个数组传给 <code>:class</code>，以应用一个 class 列表：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">:class</span>=<span class="hljs-string">&quot;[activeClass, errorClass]&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> &#123;<br>    <span class="hljs-attr">activeClass</span>: <span class="hljs-string">&#x27;active&#x27;</span>,<br>    <span class="hljs-attr">errorClass</span>: <span class="hljs-string">&#x27;text-danger&#x27;</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>渲染结果为:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;active text-danger&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><p>如果你想根据条件切换列表中的 class，可以使用三元表达式：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">:class</span>=<span class="hljs-string">&quot;[isActive ? activeClass : &#x27;&#x27;, errorClass]&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><p>这样写将始终添加 <code>errorClass</code>，但是只有在 <code>isActive</code> 为 truthy[<a href="https://v3.cn.vuejs.org/guide/class-and-style.html#footnote-1">1]</a> 时才添加 <code>activeClass</code>。</p><p>不过，当有多个条件 class 时这样写有些繁琐。所以在数组语法中也可以使用对象语法：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">:class</span>=<span class="hljs-string">&quot;[&#123; active: isActive &#125;, errorClass]&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="绑定内联样式"><a href="#绑定内联样式" class="headerlink" title="绑定内联样式"></a>绑定内联样式</h3><p><code>:style</code> 的对象语法十分直观——看着非常像 CSS，但其实是一个 JavaScript 对象。CSS property 名可以用驼峰式 (camelCase) 或短横线分隔 (kebab-case，记得用引号括起来) 来命名：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">:style</span>=<span class="hljs-string">&quot;&#123; color: activeColor, fontSize: fontSize + &#x27;px&#x27; &#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> &#123;<br>    <span class="hljs-attr">activeColor</span>: <span class="hljs-string">&#x27;red&#x27;</span>,<br>    <span class="hljs-attr">fontSize</span>: <span class="hljs-number">30</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>直接绑定到一个样式对象通常更好，这会让模板更清晰：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">:style</span>=<span class="hljs-string">&quot;styleObject&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> &#123;<br>    <span class="hljs-attr">styleObject</span>: &#123;<br>      <span class="hljs-attr">color</span>: <span class="hljs-string">&#x27;red&#x27;</span>,<br>      <span class="hljs-attr">fontSize</span>: <span class="hljs-string">&#x27;13px&#x27;</span><br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>同样的，对象语法常常结合返回对象的计算属性使用。</p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>Vue</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue</tag>
      
      <tag>学习笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>每周一炼:二分查找区间确定</title>
    <link href="/2022/08/06/%E6%AF%8F%E5%91%A8%E4%B8%80%E7%82%BC(%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE)/"/>
    <url>/2022/08/06/%E6%AF%8F%E5%91%A8%E4%B8%80%E7%82%BC(%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE)/</url>
    
    <content type="html"><![CDATA[<h1 id="每周一炼-二分法"><a href="#每周一炼-二分法" class="headerlink" title="每周一炼:二分法"></a>每周一炼:二分法</h1><h2 id="起"><a href="#起" class="headerlink" title="起"></a>起</h2><p><a href="https://programmercarl.com/0704.%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE.html#_704-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE">参考文章:代码随想录 (programmercarl.com)一个非常不错的网站,强烈推荐</a></p><p>二分查找是入门算法是最先接触,也是最为基础的算法,即使是这样,曾经的我看到二分查询一看就会一些就废,如果你也曾和我一样有过这种经历,或许可以再来复习一下二分查找.</p><p>首先我们要明确的是什么情况下我们应该使用二分查找算法,而什么情况下可以排除使用二分查找算法.,二分查找算法的的应用前提.</p><h3 id="应用前提条件如下"><a href="#应用前提条件如下" class="headerlink" title="应用前提条件如下:"></a>应用前提条件如下:</h3><p>1.我们一般会在有序数组中查找元素时使用二分法</p><p>2.无重复元素,因为一旦有重复元素，使用二分查找法返回的元素下标可能不是唯一的，这些都是使用二分法的前提条件</p><h3 id="二分法要点"><a href="#二分法要点" class="headerlink" title="二分法要点"></a>二分法要点</h3><p>有的时候,我们会搞不懂一些边缘代码到底是 <code>while(left &lt; right)</code> 还是 <code>while(left &lt;= right)</code>，或者是<code>right = middle</code>呢，还是要<code>right = middle - 1</code></p><p>大家写二分法经常写乱，主要是因为<strong>对区间的定义没有想清楚，区间的定义就是不变量</strong>。要在二分查找的过程中，保持不变量，就是在while寻找中每一次边界的处理都要坚持根据区间的定义来操作，这就是<strong>循环不变量</strong>规则。</p><p>写二分法，区间的定义一般为两种，左闭右闭即[left, right]，或者左闭右开即[left, right)。</p><p>简单来说,我们要坚持自己的区间,如果时左闭右闭即[left, right],那么从头到尾到要是左闭右闭即[left, right],而且不可以生成违法区间</p><p>[1,1]这是合法区间,值可以取1所以[left,right]当right&#x3D;left时也是合法区间,可以使用</p><p>[1,1)这是非法区间,既要大于1又要小于1,非法区间,所以[left,right]当right&#x3D;left时是非法区间,不可以使用</p><h2 id="承"><a href="#承" class="headerlink" title="承"></a>承</h2><p>接下来写几题简单题练习一下</p><h3 id="704-二分查找"><a href="#704-二分查找" class="headerlink" title="704. 二分查找"></a><a href="https://leetcode.cn/problems/binary-search/">704. 二分查找</a></h3><p>给定一个 n 个元素有序(-&gt;有序想到二分法)的（升序）整型数组 nums 和一个目标值 target  ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。</p><p>示例 1:</p><figure class="highlight makefile"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: nums = [-1,0,3,5,9,12], target = 9</span><br><span class="hljs-section">输出: 4</span><br><span class="hljs-section">解释: 9 出现在 nums 中并且下标为 4</span><br></code></pre></td></tr></table></figure><p>示例 2:</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: nums = [-1,0,3,5,9,12], target = 2</span><br><span class="hljs-section">输出: -1</span><br><span class="hljs-section">解释: 2 不存在 nums 中因此返回 -1</span><br></code></pre></td></tr></table></figure><p>提示：</p><ul><li>你可以假设 nums 中的所有元素是不重复的。&#x2F;&#x2F;不重复-&gt;二分法</li><li>n 将在 [1, 10000]之间。</li><li>nums 的每个元素都将在 [-9999, 9999]之间。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">search</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target)</span> &#123;<br>        <br>        <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> nums.length-<span class="hljs-number">1</span>;<br>    <br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">middle</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(left &lt;= right)&#123;  <br>            middle = (right+left)/<span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span>(nums[middle] &gt; target) right = middle-<span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[middle]&lt; target) left = middle+<span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> middle;<br>        &#125;<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="35-搜索插入位置"><a href="#35-搜索插入位置" class="headerlink" title="35. 搜索插入位置"></a><a href="https://leetcode.cn/problems/search-insert-position/">35. 搜索插入位置</a></h3><p>给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。</p><p>请必须使用时间复杂度为 O(log n) 的算法。</p><figure class="highlight nestedtext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs nestedtext"><span class="hljs-attribute">示例 1</span><span class="hljs-punctuation">:</span><br><span class="hljs-punctuation"></span><br><span class="hljs-attribute">输入</span><span class="hljs-punctuation">:</span> <span class="hljs-string">nums = [1,3,5,6], target = 5</span><br><span class="hljs-attribute">输出</span><span class="hljs-punctuation">:</span> <span class="hljs-string">2</span><br></code></pre></td></tr></table></figure><figure class="highlight nestedtext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs nestedtext"><span class="hljs-attribute">示例 2</span><span class="hljs-punctuation">:</span><br><span class="hljs-punctuation"></span><br><span class="hljs-attribute">输入</span><span class="hljs-punctuation">:</span> <span class="hljs-string">nums = [1,3,5,6], target = 2</span><br><span class="hljs-attribute">输出</span><span class="hljs-punctuation">:</span> <span class="hljs-string">1</span><br></code></pre></td></tr></table></figure><figure class="highlight nestedtext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs nestedtext"><span class="hljs-attribute">示例 3</span><span class="hljs-punctuation">:</span><br><span class="hljs-punctuation"></span><br><span class="hljs-attribute">输入</span><span class="hljs-punctuation">:</span> <span class="hljs-string">nums = [1,3,5,6], target = 7</span><br><span class="hljs-attribute">输出</span><span class="hljs-punctuation">:</span> <span class="hljs-string">4</span><br></code></pre></td></tr></table></figure><p>提示:</p><ul><li>nums 为 无重复元素 的 升序 排列数组</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">searchInsert</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>,right = nums.length-<span class="hljs-number">1</span>,middle = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(left &lt;= right)&#123;<br>            middle = (left+right)/<span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span>(nums[middle] &gt; target) right = middle-<span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nums[middle] &lt; target) left = middle+<span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> middle;<br>        &#125;<br>        <span class="hljs-keyword">return</span> left;<span class="hljs-comment">//此时right=left-1,left反而大一</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这一题和上一题区别就在于如果没搜索到要返回插入位置</p><h3 id="34-在排序数组中查找元素的第一个和最后一个位置"><a href="#34-在排序数组中查找元素的第一个和最后一个位置" class="headerlink" title="34. 在排序数组中查找元素的第一个和最后一个位置"></a><a href="https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/">34. 在排序数组中查找元素的第一个和最后一个位置</a></h3><p>给你一个按照非递减顺序排列的整数数组 nums，和一个目标值 target。请你找出给定目标值在数组中的开始位置和结束位置。</p><p>如果数组中不存在目标值 target，返回 [-1, -1]。</p><p>你必须设计并实现时间复杂度为 O(log n) 的算法解决此问题。</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs inform7">示例 1：<br><br>输入：nums = <span class="hljs-comment">[5,7,7,8,8,10]</span>, target = 8<br>输出：<span class="hljs-comment">[3,4]</span><br></code></pre></td></tr></table></figure><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs inform7">示例 2：<br><br>输入：nums = <span class="hljs-comment">[5,7,7,8,8,10]</span>, target = 6<br>输出：<span class="hljs-comment">[-1,-1]</span><br></code></pre></td></tr></table></figure><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs inform7">示例 3：<br><br>输入：nums = <span class="hljs-comment">[]</span>, target = 0<br>输出：<span class="hljs-comment">[-1,-1]</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] searchRange(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">flag</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>,middle=-<span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> [] res =&#123;flag,middle&#125;;<br>        <span class="hljs-keyword">if</span>(nums.length == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> res;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>,right = nums.length-<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(left &lt;= right)&#123;<br>            middle = (left+right)/<span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span>(nums[middle] &gt; target) right = middle-<span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nums[middle] &lt; target) left = middle+<span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span> &#123;<br>                flag = middle;<br>                <span class="hljs-keyword">while</span>(middle-<span class="hljs-number">1</span> &gt;=<span class="hljs-number">0</span>&amp;&amp;nums[middle-<span class="hljs-number">1</span>]==nums[middle])<br>                middle--;<br><br>                <span class="hljs-keyword">while</span>(flag+<span class="hljs-number">1</span>&lt;=nums.length-<span class="hljs-number">1</span>&amp;&amp;nums[flag+<span class="hljs-number">1</span>]==nums[flag])<br>                flag++;<br>                res[<span class="hljs-number">0</span>] = middle;<br>                res[<span class="hljs-number">1</span>] = flag;<br>            <span class="hljs-keyword">return</span> res;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="69-x-的平方根"><a href="#69-x-的平方根" class="headerlink" title="69. x 的平方根 "></a><a href="https://leetcode.cn/problems/sqrtx/">69. x 的平方根 </a></h3><p>给你一个非负整数 x ，计算并返回 x 的 算术平方根 。</p><p>由于返回类型是整数，结果只保留 整数部分 ，小数部分将被 舍去 。</p><p>注意：不允许使用任何内置指数函数和算符，例如 pow(x, 0.5) 或者 x ** 0.5 。</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs abnf">示例 <span class="hljs-number">1</span>：<br><br>输入：x <span class="hljs-operator">=</span> <span class="hljs-number">4</span><br>输出：<span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs dns">示例 <span class="hljs-number">2</span>：<br><br>输入：x = <span class="hljs-number">8</span><br>输出：<span class="hljs-number">2</span><br>解释：<span class="hljs-number">8</span> 的算术平方根是 <span class="hljs-number">2.82842</span>..., 由于返回类型是整数，小数部分将被舍去。<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">mySqrt</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> &#123;<br>     <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span><span class="hljs-number">1</span>,right = x/<span class="hljs-number">2</span>+<span class="hljs-number">1</span>,middle=<span class="hljs-number">0</span>;<br><br>     <span class="hljs-keyword">while</span>(left&lt;=right)&#123;<br>         middle = (left+right)/<span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span>((<span class="hljs-type">long</span>)middle*middle&lt;x)  left = middle+<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>((<span class="hljs-type">long</span>)middle*middle&gt;x) right = middle-<span class="hljs-number">1</span>; <br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> middle;<br>     &#125; <br>     <span class="hljs-keyword">return</span> right;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>贴一个别人的解法,原理一样,细节处处理的比我好很多</p><p>二分查找，用x&#x2F;m&lt;m而不是m*m&gt;x防止溢出</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-title function_">mySqrt</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> <br>    &#123;<br>        <span class="hljs-keyword">if</span>(x == <span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<span class="hljs-comment">//先考虑base情况</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">min</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> x;<br>        <span class="hljs-keyword">while</span>(max-min&gt;<span class="hljs-number">1</span>)<br>        &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> (max - min) / <span class="hljs-number">2</span> + min;<span class="hljs-comment">//防止溢出,先减后加占用空间更少</span><br>            <span class="hljs-keyword">if</span>(x/m&lt;m)<span class="hljs-comment">//防止溢出</span><br>                max = m;<br>            <span class="hljs-keyword">else</span><br>                min = m;<br>        &#125;<br>        <span class="hljs-keyword">return</span> min;<br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="367-有效的完全平方数"><a href="#367-有效的完全平方数" class="headerlink" title="367. 有效的完全平方数"></a><a href="https://leetcode.cn/problems/valid-perfect-square/">367. 有效的完全平方数</a></h3><p>给定一个 正整数 num ，编写一个函数，如果 num 是一个完全平方数，则返回 true ，否则返回 false 。</p><p>进阶：不要 使用任何内置的库函数，如  sqrt 。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dart">示例 <span class="hljs-number">1</span>：<br><br>输入：<span class="hljs-built_in">num</span> = <span class="hljs-number">16</span><br>输出：<span class="hljs-keyword">true</span><br></code></pre></td></tr></table></figure><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dart">示例 <span class="hljs-number">2</span>：<br><br>输入：<span class="hljs-built_in">num</span> = <span class="hljs-number">14</span><br>输出：<span class="hljs-keyword">false</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= num &lt;= 2^31 - 1</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isPerfectSquare</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span> &#123;<br>        <span class="hljs-type">int</span> left=<span class="hljs-number">1</span>,right=num/<span class="hljs-number">2</span>+<span class="hljs-number">1</span>,middle=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(left&lt;=right)&#123;<br>            middle=(left+right)/<span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span>((<span class="hljs-type">long</span>)middle*middle&gt;num) right = middle-<span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>((<span class="hljs-type">long</span>)middle*middle&lt;num) left = middle+<span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="转"><a href="#转" class="headerlink" title="转"></a>转</h2><p>上面我都习惯性采用左闭右闭的区间写法,当然也可以采用左闭右闭开的写法</p><p>不过要注意在这种情况下,一些判断条件的边界值就可能会有所改变</p><p>在这里贴一下第一题(704.二分查找)这类最基本的题型的左闭右开写法</p><h3 id="二分法第二种写法"><a href="#二分法第二种写法" class="headerlink" title="二分法第二种写法"></a>二分法第二种写法</h3><p>如果说定义 target 是在一个在左闭右开的区间里，也就是[left, right) ，那么二分法的边界处理方式则截然不同。</p><p>有如下两点：</p><ul><li>while (left &lt; right)，这里使用 &lt; ,因为left &#x3D;&#x3D; right在区间,此时**[left, right)**是没有意义的</li><li>if (nums[middle] &gt; target) right 更新为 middle，因为当前nums[middle]不等于target，去左区间继续寻找，而寻找区间是左闭右开区间，所以right更新为middle，即：下一个查询区间不会去比较nums[middle]</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-comment">//左闭右开写法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">search</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, right = nums.length;<span class="hljs-comment">//小于nums.length等价于小于等于nums.length-1</span><br>        <span class="hljs-keyword">while</span> (left &lt; right) &#123;<span class="hljs-comment">//这里使用 &lt; ,因为left == right在区间,此时**[left, right)**是没有意义的</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> left + ((right - left) &gt;&gt; <span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">if</span> (nums[mid] == target)<br>                <span class="hljs-keyword">return</span> mid;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] &lt; target)<br>                left = mid + <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] &gt; target)<br>                right = mid;<br>        &#125;<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="合"><a href="#合" class="headerlink" title="合"></a>合</h2><p>对于二分法都是<strong>一看就会，一写就废</strong></p><p>其实主要就是对区间的定义没有理解清楚，在循环中没有始终坚持根据查找区间的定义来做边界处理。</p><p>区间的定义就是不变量，那么在循环中坚持根据查找区间的定义来做边界处理，就是循环不变量规则。</p><p>本篇根据两种常见的区间定义，给出了两种二分法的写法，每一个边界为什么这么处理，都根据区间的定义做了详细介绍。</p>]]></content>
    
    
    <categories>
      
      <category>每周一炼</category>
      
      <category>Leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>二分查找</tag>
      
      <tag>Leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue学习笔记(1)</title>
    <link href="/2022/08/04/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(1)/"/>
    <url>/2022/08/04/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(1)/</url>
    
    <content type="html"><![CDATA[<h1 id="Vue学习笔记-1"><a href="#Vue学习笔记-1" class="headerlink" title="Vue学习笔记(1)"></a>Vue学习笔记(1)</h1><p><a href="https://v3.cn.vuejs.org/guide/introduction.html">参考文档:Vue官方文档教程</a></p><h2 id="1-Vue是什么"><a href="#1-Vue是什么" class="headerlink" title="1.Vue是什么?"></a>1.Vue是什么?</h2><p>渐进式框架</p><p>便于上手</p><h2 id="2-VUE安装与使用-第一个项目"><a href="#2-VUE安装与使用-第一个项目" class="headerlink" title="2.VUE安装与使用-第一个项目"></a>2.VUE安装与使用-第一个项目</h2><p>Vue.js 设计的初衷就包括可以被渐进式地采用。这意味着它可以根据需求以多种方式集成到一个项目中。</p><p>将 Vue.js 添加到项目中主要有四种方式：</p><ol><li><p>在页面上以 CDN 包的形式导入。</p></li><li><p>下载 JavaScript 文件并自行托管。</p></li><li><p>使用 npm]安装它。</p></li><li><p>使用官方的 CLI来构建一个项目，它为现代前端工作流程提供了功能齐备的构建设置 (例如，热重载、保存时的提示等等)。</p></li></ol><p>作为初学者,我想尝试用最简单的方法,也就是第一种方法</p><figure class="highlight html"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://unpkg.com/vue@next&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;hello-vue&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;demo&quot;</span>&gt;</span><br>  &#123;&#123; message &#125;&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span> <span class="hljs-comment">&lt;!-- 此处的id = &quot;hello-vue&quot; 目前看是要被第四个代码块的.mount(&#x27;#hello-vue&#x27;)关联, class =&quot;demo&quot;被第三个代码块相关联--&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.demo</span> &#123;<br>  <span class="hljs-attribute">font-family</span>: sans-serif;<br>  <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> solid <span class="hljs-number">#eee</span>;<br>  <span class="hljs-attribute">border-radius</span>: <span class="hljs-number">2px</span>;<br>  <span class="hljs-attribute">padding</span>: <span class="hljs-number">20px</span> <span class="hljs-number">30px</span>;<br>  <span class="hljs-attribute">margin-top</span>: <span class="hljs-number">1em</span>;<br>  <span class="hljs-attribute">margin-bottom</span>: <span class="hljs-number">40px</span>;<br>  user-select: none;<br>  <span class="hljs-attribute">overflow-x</span>: auto;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> <span class="hljs-title class_">HelloVueApp</span> = &#123;<br>  <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> &#123;<br>      <span class="hljs-attr">message</span>: <span class="hljs-string">&#x27;Hello Vue!!&#x27;</span><br>    &#125;<br>  &#125;<br>&#125;<br><br><span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">createApp</span>(<span class="hljs-title class_">HelloVueApp</span>).<span class="hljs-title function_">mount</span>(<span class="hljs-string">&#x27;#hello-vue&#x27;</span>) <span class="hljs-comment">//creatApp(HelloVueApp)似乎和const HelloVueApp相关联</span><br></code></pre></td></tr></table></figure><p>由上面可知,Vue中的内容最终会被渲染到<div></div>容器内</p><h2 id="3-模板语法"><a href="#3-模板语法" class="headerlink" title="3.模板语法"></a>3.模板语法</h2><p>Vue.js 使用了基于 HTML 的模板语法，允许开发者声明式地将 DOM 绑定至底层组件实例的数据。所有 Vue.js 的模板都是合法的 HTML，所以能被遵循规范的浏览器和 HTML 解析器解析。</p><p>在底层的实现上，Vue 将模板编译成虚拟 DOM 渲染函数。结合响应性系统，Vue 能够智能地计算出最少需要重新渲染多少组件，并把 DOM 操作次数减到最少。</p><h3 id="插值"><a href="#插值" class="headerlink" title="插值"></a>插值</h3><h4 id="文本"><a href="#文本" class="headerlink" title="文本"></a>文本</h4><p>数据绑定最常见的形式就是使用“Mustache” (双大括号) 语法的文本插值：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>Message: &#123;&#123; msg &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br></code></pre></td></tr></table></figure><p>Mustache 标签将会被替代为对应组件实例中 <code>msg</code> property 的值。无论何时，绑定的组件实例上 <code>msg</code> property 发生了改变，插值处的内容都会更新。</p><h4 id="原始-HTML"><a href="#原始-HTML" class="headerlink" title="原始 HTML"></a>原始 HTML</h4><p>双大括号会将数据解释为普通文本，而非 HTML 代码。如果你想要使得你的文本里的html标签被渲染成正确的html格式,你需要使用<a href="https://v3.cn.vuejs.org/api/directives.html#v-html"><code>v-html</code> 指令</a>：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;example1&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;demo&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Using mustaches: &#123;&#123; rawHtml &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Using v-html directive: <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">v-html</span>=<span class="hljs-string">&quot;rawHtml&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Using mustaches: &#123;&#123; rawHtml &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Using v-html directive: <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">v-html</span>=<span class="hljs-string">&quot;rawHtml&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> <span class="hljs-title class_">RenderHtmlApp</span> = &#123;<br>  <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> &#123;<br>      <span class="hljs-attr">rawHtml</span>: <span class="hljs-string">&#x27;&lt;span style=&quot;color: red&quot;&gt;This should be red.&lt;/span&gt;&#x27;</span><br>    &#125;<br>  &#125;<br>&#125;<br><br><span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">createApp</span>(<span class="hljs-title class_">RenderHtmlApp</span>).<span class="hljs-title function_">mount</span>(<span class="hljs-string">&#x27;#example1&#x27;</span>)<br></code></pre></td></tr></table></figure><p><img src="https://gcore.jsdelivr.net/gh/fuchajun/blogImgs/img/202208031032961.png" alt="image-20220801092421340"></p><p>上面我们了解到了如何渲染属性Attribute外面的内容,即渲染的内容都在两个<p>标签或<div>标签之间的内容,下面我们将要了解如何渲染属性</p><blockquote><p>之前,我们使用的是插值的方法绑定数据,下面我们将了解如何使用v-bind:来绑定属性,v-bind有以下特点</p><ul><li><p>和之前渲染两个标签之间的内容不同,例如<p></p>,它可以写在&lt;&gt;内部</p></li><li><p>它用于绑定数据或者元素属性,例如：绑定<code>&lt;a&gt;</code>标签的<code>href</code>属性</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">v-bind:href</span>=<span class="hljs-string">&quot;url&quot;</span>&gt;</span>click me<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>不光是<code>href</code>属性可以被<code>v-bind</code>指令绑定，任何属性都可以被绑定例如，绑定<code>src</code>属性、<code>class</code>属性</p></li></ul></blockquote><p>Mustache(大括号) 语法不能在 HTML attribute 中使用，然而，可以使用 <a href="https://v3.cn.vuejs.org/api/directives.html#v-bind"><code>v-bind</code> 指令</a>：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-bind:id</span>=<span class="hljs-string">&quot;dynamicId&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span> <span class="hljs-comment">&lt;!--由此可以看到v-bind:之间应用到&lt;div 内部&gt;,而非是两个&lt;div&gt;之间--&gt;</span><br></code></pre></td></tr></table></figure><p>如果绑定的值是 <code>null</code> 或 <code>undefined</code>，那么该 attribute 将不会被包含在渲染的元素上。</p><p>对于布尔 attribute (它们只要存在就意味着值为 <code>true</code>)，<code>v-bind</code> 工作起来略有不同，在这个例子中：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">v-bind:disabled</span>=<span class="hljs-string">&quot;isButtonDisabled&quot;</span>&gt;</span>按钮<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br></code></pre></td></tr></table></figure><p>如果 <code>isButtonDisabled</code> 的值是 truthy，那么 <code>disabled</code> attribute 将被包含在内。如果该值是一个空字符串，它也会被包括在内，与 <code>&lt;button disabled=&quot;&quot;&gt;</code> 保持一致。对于其他 falsy[<a href="https://v3.cn.vuejs.org/guide/template-syntax.html#footnote-2">2]</a> 的值，该 attribute 将被省略。</p><p>Html属性里面渲染,不需要加Mustache (双大括号),而应该使用v-bind:,并且v-bind:可以简写成  <strong>:</strong>  ,对没错,一个  <strong>:</strong>  就可以了.</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span> = <span class="hljs-string">&quot;app&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">v-bind:href</span>=<span class="hljs-string">&quot;href01&quot;</span>&gt;</span>超链接<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">:href</span>=<span class="hljs-string">&quot;href02&quot;</span>&gt;</span>超链接2<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-comment">&lt;!--如果我们想要让这个写死的链接变成动态链接,我们就可以使用v-bind: ,或者直接写:  --&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-handlebars"><span class="language-xml"></span></span><br><span class="language-xml"><span class="language-handlebars">  const App = &#123;</span></span><br><span class="language-xml"><span class="language-handlebars">      data() &#123;</span></span><br><span class="language-xml"><span class="language-handlebars">          return &#123;</span></span><br><span class="language-xml"><span class="language-handlebars">              href01:&quot;http://www.baidu.com&quot;,</span></span><br><span class="language-xml"><span class="language-handlebars">              href02:&quot;http://qq.com&quot;  <span class="hljs-comment">&lt;!--最后一个不用加逗号--&gt;</span></span></span><br><span class="language-xml"><span class="language-handlebars">          &#125;</span></span><br><span class="language-xml"><span class="language-handlebars">      &#125;</span></span><br><span class="language-xml"><span class="language-handlebars">  &#125;</span></span><br><span class="language-xml"><span class="language-handlebars">  Vue.createApp(App).mount(&#x27;#app&#x27;)</span></span><br><span class="language-xml"><span class="language-handlebars"></span></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>使用 JavaScript 表达式</p><p>迄今为止，在我们的模板中，我们一直都只绑定简单的 property 键值。但实际上，对于所有的数据绑定，Vue.js 都提供了完全的 JavaScript 表达式支持。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs html">&#123;&#123; number + 1 &#125;&#125;<br><br>&#123;&#123; ok ? &#x27;YES&#x27; : &#x27;NO&#x27; &#125;&#125;<br><br>&#123;&#123; message.split(&#x27;&#x27;).reverse().join(&#x27;&#x27;) &#125;&#125;<br><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-bind:id</span>=<span class="hljs-string">&quot;&#x27;list-&#x27; + id&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span> <span class="hljs-comment">&lt;!-- 属性里也是可以使用表达式,例如这里用来字符串拼接表达式--&gt;</span><br></code></pre></td></tr></table></figure><p>这些表达式会在当前活动实例的数据作用域下作为 JavaScript 被解析。有个限制就是，每个绑定都只能包含<strong>单个表达式</strong>，所以下面的例子都<strong>不会</strong>生效。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!--  这是语句，不是表达式：--&gt;</span><br>&#123;&#123; var a = 1 &#125;&#125;<br><br><span class="hljs-comment">&lt;!-- 流程控制也不会生效，请使用三元表达式 --&gt;</span><br>&#123;&#123; if (ok) &#123; return message &#125; &#125;&#125;<br></code></pre></td></tr></table></figure><p>动态参数</p><p>也可以在指令参数中使用 JavaScript 表达式，方法是用方括号括起来：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!--</span><br><span class="hljs-comment">注意，参数表达式的写法存在一些约束，如之后的“对动态参数表达式的约束”章节所述。</span><br><span class="hljs-comment">--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">v-bind:</span>[<span class="hljs-attr">attributeName</span>]=<span class="hljs-string">&quot;url&quot;</span>&gt;</span> ... <span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span> <span class="hljs-comment">&lt;!--这里有个坑,attributename应该全部小写才可以--&gt;</span><br></code></pre></td></tr></table></figure><p>这里的 <code>attributeName</code> 会被作为一个 JavaScript 表达式进行动态求值，求得的值将会作为最终的参数来使用。例如，如果你的组件实例有一个 data property <code>attributeName</code>，其值为 <code>&quot;href&quot;</code>，那么这个绑定将等价于 <code>v-bind:href</code>。</p><blockquote><p>动态参数这边之前一直没搞懂什么意思,现在简单说一下</p><p>正如上面提到当我们要v-bind:href&#x3D;”url”时,我们也许会遇到个问题就是我们还没确定url这个值赋给了哪一个属性,也许赋给了href01或href02,那我们可以将href暂时用[href]或者<a href="%E9%9A%8F%E4%BE%BF%E6%80%8E%E4%B9%88%E5%91%BD%E5%90%8D,%E4%BD%86%E6%9C%80%E5%A5%BD%E6%9C%89%E5%85%B3%E8%81%94,%E5%B9%B6%E4%B8%94%E4%BC%BC%E4%B9%8E%5B%E4%B8%AD%E6%8B%AC%E5%8F%B7%5D%E9%87%8C%E9%9D%A2%E4%B8%8D%E6%94%AF%E6%8C%81%E5%A4%A7%E5%86%99">[attributename]</a>代替,在const xxx  data() return中我们需要定义[href]的值告诉程序[href]指向哪一个属性,程序才会调用对应属性的值</p><p>再多说一句,其实动态参数不仅可以绑定属性,也是可以绑定方法的,当你的’on-click&#x3D;’后面不确定调用的方法,也可以用中括号括起来,在后面的const xxx  data() return中再来具体复制,使之调用对应的方法</p></blockquote><p><strong>这下我们了解到无论是属性名还是属性值,都可以动态的引用下面 const xxx  data() return中定义的值</strong></p><p>综合应用过程,直接把动态参数的应用写到里面</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;X-UA-Compatible&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;IE=edge&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://unpkg.com/vue@next&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span><br>        &#123;&#123;message&#125;&#125;<br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-html</span>=<span class="hljs-string">&quot;message&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">:href</span>=<span class="hljs-string">&quot;href01&quot;</span>&gt;</span>超链接<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">br</span>/&gt;</span><br>        &#123;&#123; number + 1 &#125;&#125; <br>        <span class="hljs-tag">&lt;<span class="hljs-name">br</span>/&gt;</span><br>        &#123;&#123; ok ? &#x27;YES&#x27; : &#x27;NO&#x27; &#125;&#125;<br>        <span class="hljs-tag">&lt;<span class="hljs-name">br</span>/&gt;</span><br>        &#123;&#123; message.split(&#x27;&#x27;).reverse().join(&#x27;&#x27;) &#125;&#125;<br>        <span class="hljs-tag">&lt;<span class="hljs-name">br</span>/&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">:id</span>=<span class="hljs-string">&quot;&#x27;list-&#x27; + id&quot;</span>&gt;</span>张三<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">:</span>[<span class="hljs-attr">attributename</span>]=<span class="hljs-string">&quot;url&quot;</span>&gt;</span>翠花<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-comment">&lt;!--靓仔看这应该明白了吧--&gt;</span><br><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">        <span class="hljs-keyword">const</span> <span class="hljs-title class_">App</span> = &#123;</span><br><span class="language-javascript">            <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">                <span class="hljs-keyword">return</span> &#123;</span><br><span class="language-javascript">                    <span class="hljs-attr">id</span>:<span class="hljs-number">2</span>,</span><br><span class="language-javascript">                    <span class="hljs-attr">attributename</span>:<span class="hljs-string">&quot;id&quot;</span>,<span class="hljs-comment">//靓仔看这应该明白了吧</span></span><br><span class="language-javascript">                    <span class="hljs-attr">url</span>:<span class="hljs-string">&quot;http://baidu.com&quot;</span>,</span><br><span class="language-javascript">                    <span class="hljs-attr">number</span>:<span class="hljs-number">5</span>,</span><br><span class="language-javascript">                    <span class="hljs-attr">ok</span>:<span class="hljs-literal">false</span>,</span><br><span class="language-javascript">                    <span class="hljs-attr">message</span>: <span class="hljs-string">&quot;hello &lt;span style=&#x27;color:red&#x27;&gt;vue&lt;/span&gt; !!&quot;</span>,</span><br><span class="language-javascript">                    <span class="hljs-attr">href01</span>:<span class="hljs-string">&quot;http://qq.com&quot;</span>,</span><br><span class="language-javascript">                    </span><br><span class="language-javascript">                &#125;</span><br><span class="language-javascript">            &#125;</span><br><span class="language-javascript">        &#125;</span><br><span class="language-javascript">        <span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">createApp</span>(<span class="hljs-title class_">App</span>).<span class="hljs-title function_">mount</span>(<span class="hljs-string">&#x27;#app&#x27;</span>)</span><br><span class="language-javascript">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p><img src="https://gcore.jsdelivr.net/gh/fuchajun/blogImgs/img/202208031121594.png" alt="上面代码效果"></p><h3 id="缩写"><a href="#缩写" class="headerlink" title="缩写"></a>缩写</h3><p><code>v-</code> 前缀作为一种视觉提示，用来识别模板中 Vue 特定的 attribute。当你在使用 Vue.js 为现有标签添加动态行为 (dynamic behavior) 时，v- 前缀很有帮助，然而，对于一些频繁用到的指令来说，就会感到使用繁琐。同时，在构建由 Vue 管理所有模板的单页面应用程序 <a href="https://en.wikipedia.org/wiki/Single-page_application">(SPA - single page application)</a> 时，<code>v-</code> 前缀也变得没那么重要了。因此，Vue 为 <code>v-bind</code> 和 <code>v-on</code> 这两个最常用的指令，提供了特定简写：</p><h4 id="v-bind-缩写"><a href="#v-bind-缩写" class="headerlink" title="v-bind 缩写"></a><code>v-bind</code> 缩写</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- 完整语法 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">v-bind:href</span>=<span class="hljs-string">&quot;url&quot;</span>&gt;</span> ... <span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- 缩写 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">:href</span>=<span class="hljs-string">&quot;url&quot;</span>&gt;</span> ... <span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- 动态参数的缩写 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">:</span>[<span class="hljs-attr">key</span>]=<span class="hljs-string">&quot;url&quot;</span>&gt;</span> ... <span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="v-on-缩写"><a href="#v-on-缩写" class="headerlink" title="v-on 缩写"></a><code>v-on</code> 缩写</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- 完整语法 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">v-on:click</span>=<span class="hljs-string">&quot;doSomething&quot;</span>&gt;</span> ... <span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- 缩写 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">a</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;doSomething&quot;</span>&gt;</span> ... <span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- 动态参数的缩写 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">a</span> @[<span class="hljs-attr">event</span>]=<span class="hljs-string">&quot;doSomething&quot;</span>&gt;</span> ... <span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br></code></pre></td></tr></table></figure><p>它们看起来可能与普通的 HTML 略有不同，但 <code>:</code> 与 <code>@</code> 对于 attribute 名来说都是合法字符，在所有支持 Vue 的浏览器都能被正确地解析。而且，它们不会出现在最终渲染的标记中。缩写语法是完全可选的，但随着你更深入地了解它们的作用，你会庆幸拥有它们。</p><h2 id="条件渲染"><a href="#条件渲染" class="headerlink" title="条件渲染"></a>条件渲染</h2><h3 id="v-if"><a href="#v-if" class="headerlink" title="v-if"></a><strong><code>v-if</code></strong></h3><p><code>v-if</code> 指令用于条件性地渲染一块内容。这块内容只会在指令的表达式返回 truthy 值的时候被渲染。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">&quot;awesome&quot;</span>&gt;</span>Vue is awesome!<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br></code></pre></td></tr></table></figure><p>也可以用 <code>v-else</code> 添加一个“else 块”：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">&quot;awesome&quot;</span>&gt;</span>Vue is awesome!<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">v-else</span>&gt;</span>Oh no 😢<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br></code></pre></td></tr></table></figure><p> 在 <code>&lt;template&gt;</code> 元素上使用 <code>v-if</code> 条件渲染分组</p><p>因为 <code>v-if</code> 是一个指令，所以必须将它添加到一个元素上。但是如果想切换多个元素呢？此时可以把一个 <code>&lt;template&gt;</code> 元素当做不可见的包裹元素，并在上面使用 <code>v-if</code>。最终的渲染结果将不包含 <code>&lt;template&gt;</code> 元素。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">&quot;ok&quot;</span>&gt;</span><span class="hljs-comment">&lt;!--template会丢掉--&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Title<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Paragraph 1<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Paragraph 2<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><span class="hljs-comment">&lt;!--这里的几个标签还是会有的,没得只是具体使用v-if的那一行的template标签--&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>简单来说,在<code>&lt;h1&gt;</code>上或者<code>&lt;p&gt;</code>标签上使用<code>v-if</code>渲染后会留下<code>&lt;h1&gt;</code>或者<code>&lt;p&gt;</code>这类标签,而在<code>&lt;template&gt;</code>使用则不会,另外,<code>&lt;template&gt;</code>是Vue里的标签,而不是html的</strong></p><h3 id="v-else"><a href="#v-else" class="headerlink" title="v-else"></a><code>v-else</code></h3><p>你可以使用 <code>v-else</code> 指令来表示 <code>v-if</code> 的“else 块”：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">&quot;Math.random() &gt; 0.5&quot;</span>&gt;</span><br>  Now you see me<br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-else</span>&gt;</span><br>  Now you don&#x27;t<br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><p><code>v-else</code> 元素必须紧跟在带 <code>v-if</code> 或者 <code>v-else-if</code> 的元素的后面，否则它将不会被识别。</p><h3 id="v-else-if"><a href="#v-else-if" class="headerlink" title="v-else-if"></a><code>v-else-if</code></h3><p><code>v-else-if</code>，顾名思义，充当 <code>v-if</code> 的“else-if 块”，并且可以连续使用：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">&quot;type === &#x27;A&#x27;&quot;</span>&gt;</span><br>  A<br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-else-if</span>=<span class="hljs-string">&quot;type === &#x27;B&#x27;&quot;</span>&gt;</span><br>  B<br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-else-if</span>=<span class="hljs-string">&quot;type === &#x27;C&#x27;&quot;</span>&gt;</span><br>  C<br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-else</span>&gt;</span><br>  Not A/B/C<br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>与 <code>v-else</code> 的用法类似，<code>v-else-if</code> 也必须紧跟在带 <code>v-if</code> 或者 <code>v-else-if</code> 的元素之后。</strong></p><h3 id="v-show"><a href="#v-show" class="headerlink" title="v-show"></a><code>v-show</code></h3><p>另一个用于条件性展示元素的选项是 <code>v-show</code> 指令。用法大致一样：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">v-show</span>=<span class="hljs-string">&quot;ok&quot;</span>&gt;</span>Hello!<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><span class="hljs-comment">&lt;!--记得要在下面定义ok的值类型为true或false--&gt;</span><br></code></pre></td></tr></table></figure><p>不同的是带有 <code>v-show</code> 的元素<strong>始终会被渲染并保留在 DOM 中</strong>。<code>v-show</code> 只是简单地切换元素的 <code>display</code> CSS property。</p><p>注意，<code>v-show</code> 不支持 <code>&lt;template&gt;</code> 元素，也不支持 <code>v-else</code>。</p><h3 id="v-if-vs-v-show"><a href="#v-if-vs-v-show" class="headerlink" title="v-if vs v-show"></a><code>v-if</code> vs <code>v-show</code></h3><p><code>v-if</code> 是“真正”的条件渲染，因为它会确保在切换过程中，条件块内的事件监听器和子组件适当地被销毁和重建。</p><p><code>v-if</code> 也是<strong>惰性的</strong>：如果在初始渲染时条件为假，则什么也不做——直到条件第一次变为真时，才会开始渲染条件块。</p><p>相比之下，<code>v-show</code> 就简单得多——不管初始条件是什么，元素总是会被渲染，并且只是简单地基于 CSS 进行切换。</p><p>一般来说，<code>v-if</code> 有更高的切换开销，而 <code>v-show</code> 有更高的初始渲染开销。因此，如果需要非常频繁地切换，则使用 <code>v-show</code> 较好；如果在运行时条件很少改变，则使用 <code>v-if</code> 较好。</p><blockquote><p><strong>简单来说,v-if 如果判断为false,浏览器F12查看不到使用v-if的标签,而使用v-show的会被F12看到,只是display属性被设置为none,就是隐藏起来了.</strong></p></blockquote><p>综合应用过程,查看v-show与v-if区别</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;X-UA-Compatible&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;IE=edge&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://unpkg.com/vue@next&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">&quot;type === &#x27;A&#x27; &quot;</span>&gt;</span>Vue is awesome!<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-else-if</span>=<span class="hljs-string">&quot;type === &#x27;B&#x27;&quot;</span>&gt;</span>B<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">v-else</span>&gt;</span>Oh no 😢<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">v-show</span>=<span class="hljs-string">&quot;ok&quot;</span>&gt;</span>Hello!<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">&quot;ok&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Title<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Paragraph 1<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Paragraph 2<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">        <span class="hljs-keyword">const</span> <span class="hljs-title class_">App</span> = &#123;</span><br><span class="language-javascript">            <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">                <span class="hljs-keyword">return</span> &#123;</span><br><span class="language-javascript">                    <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;C&#x27;</span>,</span><br><span class="language-javascript">                    <span class="hljs-attr">ok</span>: <span class="hljs-literal">false</span></span><br><span class="language-javascript">                &#125;</span><br><span class="language-javascript">            &#125;</span><br><span class="language-javascript">        &#125;</span><br><span class="language-javascript">        <span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">createApp</span>(<span class="hljs-title class_">App</span>).<span class="hljs-title function_">mount</span>(<span class="hljs-string">&#x27;#app&#x27;</span>)</span><br><span class="language-javascript">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p><img src="https://gcore.jsdelivr.net/gh/fuchajun/blogImgs/img/202208042204736.png" alt="综合应用v-if与v-show区别"></p><h2 id="列表渲染"><a href="#列表渲染" class="headerlink" title="列表渲染"></a>列表渲染</h2><h3 id="在-v-for-里使用值的范围"><a href="#在-v-for-里使用值的范围" class="headerlink" title="在 v-for 里使用值的范围"></a>在 <code>v-for</code> 里使用值的范围</h3><p><code>v-for</code> 也可以接受整数。在这种情况下，它会把模板重复对应次数。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;range&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;demo&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;n in 10&quot;</span> <span class="hljs-attr">:key</span>=<span class="hljs-string">&quot;n&quot;</span>&gt;</span>&#123;&#123; n &#125;&#125; <span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><span class="hljs-comment">&lt;!--n默认初始值为1,最后渲染出一行12345678910--&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="用-v-for-把一个数组映射为一组元素"><a href="#用-v-for-把一个数组映射为一组元素" class="headerlink" title="用 v-for 把一个数组映射为一组元素"></a>用 <code>v-for</code> 把一个数组映射为一组元素</h3><p>我们可以用 <code>v-for</code> 指令基于一个数组来渲染一个列表。<code>v-for</code> 指令需要使用 <code>item in items</code> 形式的特殊语法，其中 items 是源数据数组，而 <code>item</code> 则是被迭代的数组元素的<strong>别名</strong>。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;it in items&quot;</span>&gt;</span><br>        &#123;&#123;items.message&#125;&#125;<span class="hljs-comment">&lt;!--如果这里直接写&#123;&#123;item&#125;&#125;,输出内容将会是带括号的对象,例如&#123;1,&quot;Monday&quot;&#125;,&#123;2,&quot;Tuesday&quot;&#125;--&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">const</span> <span class="hljs-title class_">App</span> = &#123;</span><br><span class="language-javascript">        <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">            <span class="hljs-keyword">return</span> &#123;</span><br><span class="language-javascript">                <span class="hljs-attr">items</span>:[&#123;<span class="hljs-string">&quot;id&quot;</span>:<span class="hljs-number">1</span>,<span class="hljs-string">&quot;message&quot;</span>:<span class="hljs-string">&quot;Monday&quot;</span>&#125;,&#123;<span class="hljs-string">&quot;id&quot;</span>:<span class="hljs-number">2</span>,<span class="hljs-string">&quot;message&quot;</span>:<span class="hljs-string">&quot;Tuesday&quot;</span>&#125;]</span><br><span class="language-javascript">            &#125;</span><br><span class="language-javascript">        &#125;</span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>在 <code>v-for</code> 块中，我们可以访问所有父作用域的 property。<code>v-for</code> 还支持一个可选的第二个参数，即当前项的索引。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;array-with-index&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;demo&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;(item, index) in items&quot;</span>&gt;</span><br>    &#123;&#123; parentMessage &#125;&#125; - &#123;&#123; index &#125;&#125; - &#123;&#123; item.message &#125;&#125;<br>  <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">createApp</span>(&#123;</span><br><span class="language-javascript">  <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">    <span class="hljs-keyword">return</span> &#123;</span><br><span class="language-javascript">      <span class="hljs-attr">parentMessage</span>: <span class="hljs-string">&#x27;Parent&#x27;</span>,</span><br><span class="language-javascript">      <span class="hljs-attr">items</span>: [&#123; <span class="hljs-attr">message</span>: <span class="hljs-string">&#x27;Foo&#x27;</span> &#125;, &#123; <span class="hljs-attr">message</span>: <span class="hljs-string">&#x27;Bar&#x27;</span> &#125;]</span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript">  &#125;</span><br><span class="language-javascript">&#125;).<span class="hljs-title function_">mount</span>(<span class="hljs-string">&#x27;#array-with-index&#x27;</span>)</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p><img src="https://gcore.jsdelivr.net/gh/fuchajun/blogImgs/img/202208042204633.png" alt="image-20220801122816844"></p><p>你也可以用 <code>of</code> 替代 <code>in</code> 作为分隔符，因为它更接近 JavaScript 迭代器的语法：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;item of items&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-comment">&lt;!--简而言之,就是没区别,但我看到有人的博客里写建议数组用of,对象用in,比较好分辨你这个for用在什么上</span><br></code></pre></td></tr></table></figure><h3 id="在-v-for-里使用对象"><a href="#在-v-for-里使用对象" class="headerlink" title="在 v-for 里使用对象"></a>在 <code>v-for</code> 里使用对象</h3><p>你也可以用 <code>v-for</code> 来遍历一个对象的 property。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;v-for-object&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;demo&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;value in myObject&quot;</span>&gt;</span><br>    &#123;&#123; value &#125;&#125;<br>  <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">createApp</span>(&#123;<br>  <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> &#123;<br>      <span class="hljs-attr">myObject</span>: &#123;<br>        <span class="hljs-attr">title</span>: <span class="hljs-string">&#x27;How to do lists in Vue&#x27;</span>,<br>        <span class="hljs-attr">author</span>: <span class="hljs-string">&#x27;Jane Doe&#x27;</span>,<br>        <span class="hljs-attr">publishedAt</span>: <span class="hljs-string">&#x27;2016-04-10&#x27;</span><br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;).<span class="hljs-title function_">mount</span>(<span class="hljs-string">&#x27;#v-for-object&#x27;</span>)<br></code></pre></td></tr></table></figure><p><img src="https://gcore.jsdelivr.net/gh/fuchajun/blogImgs/img/202208042204895.png" alt="image-20220801140514588"></p><p>你也可以提供第二个的参数为 property 名称 (也就是键名 key)：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;(value, name) in myObject&quot;</span>&gt;</span><br>  &#123;&#123; name &#125;&#125;: &#123;&#123; value &#125;&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br></code></pre></td></tr></table></figure><p><img src="https://gcore.jsdelivr.net/gh/fuchajun/blogImgs/img/202208042204986.png" alt="image-20220801140536902"></p><p>还可以用第三个参数作为索引：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;(value, name, index) in myObject&quot;</span>&gt;</span><br>  &#123;&#123; index &#125;&#125;. &#123;&#123; name &#125;&#125;: &#123;&#123; value &#125;&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br></code></pre></td></tr></table></figure><p><img src="https://gcore.jsdelivr.net/gh/fuchajun/blogImgs/img/202208042204952.png" alt="image-20220801140600837"></p><blockquote><p><strong>在遍历对象时，会按 <code>Object.keys()</code> 的结果遍历，但是不能保证它在不同 JavaScript 引擎下的结果都一致。</strong></p></blockquote><h3 id="维护状态"><a href="#维护状态" class="headerlink" title="维护状态"></a>维护状态</h3><p>当 Vue 正在更新使用 <code>v-for</code> 渲染的元素列表时，它默认使用“就地更新”的策略。如果数据项的顺序被改变，Vue 将不会移动 DOM 元素来匹配数据项的顺序，而是就地更新每个元素，并且确保它们在每个索引位置正确渲染。</p><p>这个默认的模式是高效的，但是<strong>只适用于不依赖子组件状态或临时 DOM 状态 (例如：表单输入值) 的列表渲染输出</strong>。</p><p>为了给 Vue 一个提示，以便它能跟踪每个节点的身份，从而重用和重新排序现有元素，你需要为每项提供一个唯一的 <code>key</code> attribute：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;item in items&quot;</span> <span class="hljs-attr">:key</span>=<span class="hljs-string">&quot;item.id&quot;</span>&gt;</span><br>  <span class="hljs-comment">&lt;!-- 内容 --&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><p><a href="https://v3.cn.vuejs.org/style-guide/#keyed-v-for-essential">建议</a>尽可能在使用 <code>v-for</code> 时提供 <code>key</code> attribute，除非遍历输出的 DOM 内容非常简单，或者是刻意依赖默认行为以获取性能上的提升。</p><p>因为它是 Vue 识别节点的一个通用机制，<code>key</code> 并不仅与 <code>v-for</code> 特别关联。后面我们将在指南中看到，它还具有其它用途。</p><blockquote><p><strong>提示</strong></p><p><strong>不要使用对象或数组之类的非基本类型值作为 <code>v-for</code> 的 key。请用字符串或数值类型的值。</strong></p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs html"><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;n in 10&quot;</span> <span class="hljs-attr">:key</span>=<span class="hljs-string">&quot;n&quot;</span>&gt;</span>&#123;&#123; n &#125;&#125; <span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">br</span> /&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;(item,index) in items&quot;</span>&gt;</span>&#123;&#123;index&#125;&#125;-&#123;&#123;item.id&#125;&#125;,&#123;&#123;item.message&#125;&#125; ==== &#123;&#123;parentMessage&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">hr</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;(value, name, index) in myObject&quot;</span>&gt;</span><br>            &#123;&#123;index&#125;&#125; - &#123;&#123;name&#125;&#125; : &#123;&#123;value&#125;&#125;<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">hr</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;(value, name, index) in myObject&quot;</span>&gt;</span><br>            &#123;&#123;index&#125;&#125; - &#123;&#123;name&#125;&#125; : &#123;&#123;value&#125;&#125;<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">        <span class="hljs-keyword">const</span> <span class="hljs-title class_">App</span> = &#123;</span><br><span class="language-javascript">            <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">                <span class="hljs-keyword">return</span> &#123;</span><br><span class="language-javascript">                    <span class="hljs-attr">parentMessage</span>: <span class="hljs-string">&#x27;Parent&#x27;</span>,</span><br><span class="language-javascript">                    <span class="hljs-attr">items</span>: [&#123; <span class="hljs-attr">id</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">message</span>: <span class="hljs-string">&#x27;Foo&#x27;</span> &#125;, &#123; <span class="hljs-attr">id</span>: <span class="hljs-number">2</span>, <span class="hljs-attr">message</span>: <span class="hljs-string">&#x27;Bar&#x27;</span> &#125;],</span><br><span class="language-javascript">                    <span class="hljs-attr">myObject</span>: &#123;</span><br><span class="language-javascript">                        <span class="hljs-attr">title</span>: <span class="hljs-string">&#x27;How to do lists in Vue&#x27;</span>,</span><br><span class="language-javascript">                        <span class="hljs-attr">author</span>: <span class="hljs-string">&#x27;Jane Doe&#x27;</span>,</span><br><span class="language-javascript">                        <span class="hljs-attr">publishedAt</span>: <span class="hljs-string">&#x27;2016-04-10&#x27;</span></span><br><span class="language-javascript">                    &#125;</span><br><span class="language-javascript">                &#125;</span><br><span class="language-javascript">            &#125;</span><br><span class="language-javascript">        &#125;</span><br><span class="language-javascript">        <span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">createApp</span>(<span class="hljs-title class_">App</span>).<span class="hljs-title function_">mount</span>(<span class="hljs-string">&#x27;#app&#x27;</span>)</span><br><span class="language-javascript">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p><img src="https://gcore.jsdelivr.net/gh/fuchajun/blogImgs/img/202208042204313.png" alt="image-20220801141546193"></p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>Vue</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue</tag>
      
      <tag>学习笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Servlet学习笔记</title>
    <link href="/2022/08/02/Servlet%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2022/08/02/Servlet%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="Servlet学习笔记"><a href="#Servlet学习笔记" class="headerlink" title="Servlet学习笔记"></a>Servlet学习笔记</h1><h3 id="参考链接C语言编程网Servlet教程-Servlet教程-biancheng-net"><a href="#参考链接C语言编程网Servlet教程-Servlet教程-biancheng-net" class="headerlink" title="[参考链接C语言编程网Servlet教程](Servlet教程 (biancheng.net))"></a>[参考链接C语言编程网Servlet教程](<a href="http://c.biancheng.net/servlet2/">Servlet教程 (biancheng.net)</a>)</h3><h2 id="Http协议"><a href="#Http协议" class="headerlink" title="Http协议"></a>Http协议</h2><p>HTTP 协议（Hypertext Transfer Protocol, 超文本传输协议）,本质上是客户端与服务端的通行规则,这一通信规则规定了客户端发送给服务器的内容格式，也规定了服务器发送给客户端的内容格式。客户端 发送给服务器的格式叫”请求协议”；服务器发送给客户端的格式叫”响应协议”。</p><p>浏览器查看协议传输的数据内容,可以通过F12实现</p><p><img src="https://gcore.jsdelivr.net/gh/fuchajun/blogImgs/img/202208020946238.png"></p><h3 id="Http格式"><a href="#Http格式" class="headerlink" title="Http格式"></a>Http格式</h3><p>服务器端资源需要通过浏览器进行，此时由浏览器将我们给出的请求解析为满足 HTTP 协议的格式并 发出。我们发出的请求格式需要按照浏览器规定的格式来书写，在浏览器中书写格式如下：<img src="https://gcore.jsdelivr.net/gh/fuchajun/blogImgs/img/202208020946477.png" alt="http格式"></p><h3 id="Http特点"><a href="#Http特点" class="headerlink" title="Http特点"></a>Http特点</h3><p><strong>1.支持客户&#x2F;服务器模式。</strong></p><p><strong>2.简单快速：客户向服务器请求服务时，只需传送请求方法和路径。请求方法常用的有GT、POST。每种方法规定了客户与服务器联系的类型不同。由于HTTP协议简单，使得HTTP服务器的程序规模小，因而通信速度很快。</strong></p><p><strong>3.灵活：HTTP允许传输任意类型的数据对象。传输的类型由Content-Type加以标记。</strong></p><p><strong>4.无连接：无连接是表示每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。HTTP1.1版本后支持可持续连接。通过这种连接，就有可能在建立一个TCP连接后，发送请求并得到回应，然后发送更多的请求并得到更多的回应.通过把建立和释放TCP连接的开销分难到多个请求上，则对于每个请求而言，由于TCP而造成的相对开销被大大地降低了。而且，还可以发送流水线请求，也就是说在发送请求1之后的回应到来之前就可以发送请求2也可以认为，一次连接发送多个请求，由客户机确认是否关闭连接，而服务器会认为这些请求分别来自不同的客户端。</strong></p><p><strong>5.无状态：HTTP协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。</strong></p><h3 id="Http请求"><a href="#Http请求" class="headerlink" title="Http请求"></a>Http请求</h3><p>Http请求协议由三部分组成—请求行,请求头,请求正文(GET请求没有请求正文) </p><p><strong>请求头</strong>由一堆键值对组成</p><p>例如:</p><p>Accept: *&#x2F;*</p><p>Accept-Encoding: gzip, deflate, br </p><p>Accept-Language: zh-CN,zh;q&#x3D;0.9 </p><p>Cache-Control: no-cache </p><p>Connection: keep-alive </p><p>Host: hectorstatic.baidu.com </p><p>Pragma: no-cache </p><p>Referer: <a href="https://www.baidu.com/">https://www.baidu.com/</a></p><p><strong>请求行</strong>以一个方法符号开头，以空格分开，后面跟着请求的 URI 和协议的版本。 </p><p>格式如下：Method Request-URI HTTP-Version CRLF </p><p>Method 表示请求方法； Request-URI 是一个统一资源标识符； HTTP-Version 表示请 求的 HTTP 协议版本； CRLF 表示回车和换行；</p><p>例如:</p><p>GET &#x2F;s01&#x2F;ser01?uname&#x3D;zhangsan  HTTP&#x2F;1.1</p><p><strong>请求正文</strong>–你需要传递给服务器的数据</p><p>GET请求没有请求正文,因为GET请求会直接把请求正文放在地址栏后面</p><p>POST请求有请求体(请求正文),如果你有参数需要传递,则会把参数放到Form Data 中(请求体的一部分)</p><p>例如:</p><p><a href="http://localhost:8080/**myweb/servlet1/username=admin&amp;pwd=123456**,%E5%90%8E%E9%9D%A2%E8%BF%99%E4%B8%80%E6%AE%B5%E5%8F%AF%E4%BB%A5%E5%BD%93%E4%BD%9C%E8%AF%B7%E6%B1%82%E6%AD%A3%E6%96%87,%E6%90%9C%E7%B4%A2%E6%97%B6%E5%9C%B0%E5%9D%80%E6%A0%8F%E4%B8%8A%E7%9A%84%E4%B8%80%E5%A4%A7%E5%A0%86%E7%B1%BB%E4%BC%BC%E4%BA%8E%E4%B9%B1%E7%A0%81%E7%9A%84%E4%B8%9C%E8%A5%BF%E5%B0%B1%E6%98%AF%E8%AF%B7%E6%B1%82%E6%AD%A3%E6%96%87">http://localhost:8080/**myweb/servlet1/username=admin&amp;pwd=123456**,后面这一段可以当作请求正文,搜索时地址栏上的一大堆类似于乱码的东西就是请求正文</a></p><p>请求行也有三部分组成—请求方式   请求路径    Http协议版本</p><h3 id="Http响应"><a href="#Http响应" class="headerlink" title="Http响应"></a>Http响应</h3><p>在接收和解释请求消息后，服务器返回一个 HTTP 响应消息。</p><p>HTTP 响应也是由三个部分组成，分别 是：<strong>状态行、消息报头、响应正文。</strong></p><p><img src="https://gcore.jsdelivr.net/gh/fuchajun/blogImgs/img/202208020947404.png" alt="Snipaste_2022-07-28_21-19-54"></p><h3 id="消息头"><a href="#消息头" class="headerlink" title="消息头"></a>消息头</h3><p>HTTP 消息由客户端到服务器的请求和服务器到客户端的响应组成。请求消息和响应消息都是由开始 行（对于请求消息，开始行就是请求行，对于响应消息，开始行就是状态行）， 消息报头（可选），空 行（只有 CRLF 的行），消息正文（可选）组成。</p><p>每一个报头域都是由 <strong>名字+”:”+空格+值</strong> 组成，消息报头域的名字是大小写无关的。</p><p><strong>请求头</strong><br>请求报头允许客户端向服务器端传递请求的附加信息以及客户端自身的信息。</p><p>Referer:该请求头指明请求从哪里来。<br>如果是地址栏中输入地址访问的都没有该请求头地址栏输入地址，通过请求可以看到，此时多了一个Referer的请求头，并且后面的值为该请求从哪里发出。比如：百度竞价，只能从百度来的才有效果，否则不算；通常用来做统计工作、防盗链。</p><p><strong>响应头</strong><br>响应报头允许服务器传递不能放在状态行中的附加响应信息，以及关于服务器的信息和对Request-URl所标识的资源进行下一步访问的信息。</p><p>Location：Location响应报头域用于重定向接受者到一个新的位置。</p><p>Location响应报头域，常用在更换域名的时候。</p><figure class="highlight java"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs java">response.sendRedirect(<span class="hljs-string">&quot;http://www.baidu.com&quot;</span>);<br></code></pre></td></tr></table></figure><p>Refresh：自动跳转（单位是秒），可以在页面通过meta标签实现，也可在后台实现。</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jsp">&lt;meta http-equiv=<span class="hljs-string">&quot;refresh&quot;</span> content=<span class="hljs-string">&quot;3;url=http://www.baidu.com&quot;</span>&gt;<br></code></pre></td></tr></table></figure><h3 id="Servlet-HTTP-状态码"><a href="#Servlet-HTTP-状态码" class="headerlink" title="Servlet HTTP 状态码"></a>Servlet HTTP 状态码</h3><table><thead><tr><th align="left">代码</th><th align="left">消息</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">100</td><td align="left">Continue</td><td align="left">只有请求的一部分已经被服务器接收，但只要它没有被拒绝，客户端应继续该请求。</td></tr><tr><td align="left">101</td><td align="left">Switching Protocols</td><td align="left">服务器切换协议。</td></tr><tr><td align="left">200</td><td align="left">OK</td><td align="left">请求成功。</td></tr><tr><td align="left">201</td><td align="left">Created</td><td align="left">该请求是完整的，并创建一个新的资源。</td></tr><tr><td align="left">202</td><td align="left">Accepted</td><td align="left">该请求被接受处理，但是该处理是不完整的。</td></tr><tr><td align="left">203</td><td align="left">Non-authoritative Information</td><td align="left"></td></tr><tr><td align="left">204</td><td align="left">No Content</td><td align="left"></td></tr><tr><td align="left">205</td><td align="left">Reset Content</td><td align="left"></td></tr><tr><td align="left">206</td><td align="left">Partial Content</td><td align="left"></td></tr><tr><td align="left">300</td><td align="left">Multiple Choices</td><td align="left">链接列表。用户可以选择一个链接，进入到该位置。最多五个地址。</td></tr><tr><td align="left">301</td><td align="left">Moved Permanently</td><td align="left">所请求的页面已经转移到一个新的 URL。</td></tr><tr><td align="left">302</td><td align="left">Found</td><td align="left">所请求的页面已经临时转移到一个新的 URL。</td></tr><tr><td align="left">303</td><td align="left">See Other</td><td align="left">所请求的页面可以在另一个不同的 URL 下被找到。</td></tr><tr><td align="left">304</td><td align="left">Not Modified</td><td align="left"></td></tr><tr><td align="left">305</td><td align="left">Use Proxy</td><td align="left"></td></tr><tr><td align="left">306</td><td align="left"><em>Unused</em></td><td align="left">在以前的版本中使用该代码。现在已不再使用它，但代码仍被保留。</td></tr><tr><td align="left">307</td><td align="left">Temporary Redirect</td><td align="left">所请求的页面已经临时转移到一个新的 URL。</td></tr><tr><td align="left">400</td><td align="left">Bad Request</td><td align="left">服务器不理解请求。</td></tr><tr><td align="left">401</td><td align="left">Unauthorized</td><td align="left">所请求的页面需要用户名和密码。</td></tr><tr><td align="left">402</td><td align="left">Payment Required</td><td align="left"><em>您还不能使用该代码。</em></td></tr><tr><td align="left">403</td><td align="left">Forbidden</td><td align="left">禁止访问所请求的页面。</td></tr><tr><td align="left">404</td><td align="left">Not Found</td><td align="left">服务器无法找到所请求的页面。.</td></tr><tr><td align="left">405</td><td align="left">Method Not Allowed</td><td align="left">在请求中指定的方法是不允许的。</td></tr><tr><td align="left">406</td><td align="left">Not Acceptable</td><td align="left">服务器只生成一个不被客户端接受的响应。</td></tr><tr><td align="left">407</td><td align="left">Proxy Authentication Required</td><td align="left">在请求送达之前，您必须使用代理服务器的验证。</td></tr><tr><td align="left">408</td><td align="left">Request Timeout</td><td align="left">请求需要的时间比服务器能够等待的时间长，超时。</td></tr><tr><td align="left">409</td><td align="left">Conflict</td><td align="left">请求因为冲突无法完成。</td></tr><tr><td align="left">410</td><td align="left">Gone</td><td align="left">所请求的页面不再可用。</td></tr><tr><td align="left">411</td><td align="left">Length Required</td><td align="left">“Content-Length” 未定义。服务器无法处理客户端发送的不带 Content-Length 的请求信息。</td></tr><tr><td align="left">412</td><td align="left">Precondition Failed</td><td align="left">请求中给出的先决条件被服务器评估为 false。</td></tr><tr><td align="left">413</td><td align="left">Request Entity Too Large</td><td align="left">服务器不接受该请求，因为请求实体过大。</td></tr><tr><td align="left">414</td><td align="left">Request-url Too Long</td><td align="left">服务器不接受该请求，因为 URL 太长。当您转换一个 “post” 请求为一个带有长的查询信息的 “get” 请求时发生。</td></tr><tr><td align="left">415</td><td align="left">Unsupported Media Type</td><td align="left">服务器不接受该请求，因为媒体类型不被支持。</td></tr><tr><td align="left">417</td><td align="left">Expectation Failed</td><td align="left"></td></tr><tr><td align="left">500</td><td align="left">Internal Server Error</td><td align="left">未完成的请求。服务器遇到了一个意外的情况。</td></tr><tr><td align="left">501</td><td align="left">Not Implemented</td><td align="left">未完成的请求。服务器不支持所需的功能。</td></tr><tr><td align="left">502</td><td align="left">Bad Gateway</td><td align="left">未完成的请求。服务器从上游服务器收到无效响应。</td></tr><tr><td align="left">503</td><td align="left">Service Unavailable</td><td align="left">未完成的请求。服务器暂时超载或死机。</td></tr><tr><td align="left">504</td><td align="left">Gateway Timeout</td><td align="left">网关超时。</td></tr><tr><td align="left">505</td><td align="left">HTTP Version Not Supported</td><td align="left">服务器不支持”HTTP协议”版本。</td></tr></tbody></table><h2 id="Servlet"><a href="#Servlet" class="headerlink" title="Servlet"></a>Servlet</h2><p>Servlet 是 Server 与 Applet 的缩写，是服务端小程序的意思。使用 Java 语言编写的服务器端程序， 可以生成动态的 WEB 页，Servlet 主要运行在服务器端，并由服务器调用执行， 是一种按照 Servlet 标 准来开发的类。言外之意：要实现 web 开 发，需要实现 Servlet 标准</p><p>Servlet 本质上也是 Java 类，但要遵循 Servlet 规范进行编写，没有 main()方法，它的创建、使用、 销毁都由 Servlet 容器进行管理(如 Tomcat)。言外之意：写自己的类，不用写 main 方法，别人自动 调用</p><p> Servlet 是和 HTTP 协议是紧密联系的，其可以处理 HTTP 协议相关的所有内容。这也是 Servlet 应用 广泛的原因之一。 提供了 Servlet 功能的服务器，叫做 Servlet 容器，其常见容器有很多，如 Tomcat, Jetty, WebLogic Server, WebSphere, JBoss 等等。</p><p> <strong>Servlet是JavaWeb的三大组件之一，它属于动态资源。Servlet的作用是处理请求，服务器会把接受到的请求交给Servlet来处理，在Servlet中通常需要：</strong></p><ul><li><p>接受请求数据；</p></li><li><p>处理请求；</p></li><li><p>完成响应。</p><p>例如客户端发出登录请求，或者输出注册请求，这些请求都应该有Servlet来完成处理！Servlet需要我们自己来编写，每个Servlet必须实现javax.servlet.Servlet接口。</p></li></ul><h3 id="实现Servlet的三种方式"><a href="#实现Servlet的三种方式" class="headerlink" title="实现Servlet的三种方式"></a>实现Servlet的三种方式</h3><p>Servlet 创有三种方式。</p><h4 id="1、实现-Servlet-接口"><a href="#1、实现-Servlet-接口" class="headerlink" title="1、实现 Servlet 接口"></a><strong>1、实现 Servlet 接口</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//Servlet的生命周期:从Servlet被创建到Servlet被销毁的过程</span><br><span class="hljs-comment">//一次创建，到处服务</span><br><span class="hljs-comment">//一个Servlet只会有一个对象，服务所有的请求</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 1.实例化（使用构造方法创建对象）</span><br><span class="hljs-comment"> * 2.初始化  执行init方法</span><br><span class="hljs-comment"> * 3.服务     执行service方法</span><br><span class="hljs-comment"> * 4.销毁    执行destroy方法</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ServletDemo1</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Servlet</span> &#123;<br><br>    <span class="hljs-comment">//public ServletDemo1()&#123;&#125;</span><br><br>     <span class="hljs-comment">//生命周期方法:当Servlet第一次被创建对象时执行该方法,该方法在整个生命周期中只执行一次</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">(ServletConfig arg0)</span> <span class="hljs-keyword">throws</span> ServletException &#123;<br>                System.out.println(<span class="hljs-string">&quot;=======init=========&quot;</span>);<br>        &#125;<br><br>    <span class="hljs-comment">//生命周期方法:对客户端响应的方法,该方法会被执行多次，每次请求该servlet都会执行该方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">service</span><span class="hljs-params">(ServletRequest arg0, ServletResponse arg1)</span><br>            <span class="hljs-keyword">throws</span> ServletException, IOException &#123;<br>        System.out.println(<span class="hljs-string">&quot;hehe&quot;</span>);<br><br>    &#125;<br><br>    <span class="hljs-comment">//生命周期方法:当Servlet被销毁时执行该方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">destroy</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;******destroy**********&quot;</span>);<br>    &#125;<br><span class="hljs-comment">//当停止tomcat时也就销毁的servlet。</span><br>    <span class="hljs-keyword">public</span> ServletConfig <span class="hljs-title function_">getServletConfig</span><span class="hljs-params">()</span> &#123;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getServletInfo</span><span class="hljs-params">()</span> &#123;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>因为是实现 Servlet 接口，所以我们需要实现接口里的方法。</p><p>下面我们也说明了 Servlet 的执行过程，也就是 Servlet 的生命周期。</p><h4 id="2、继承-GenericServlet-类"><a href="#2、继承-GenericServlet-类" class="headerlink" title="2、继承 GenericServlet 类"></a><strong>2、继承 GenericServlet 类</strong></h4><p>它实现了 Servlet 接口除了 service 的方法，不过这种方法我们极少用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ServletDemo2</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">GenericServlet</span> &#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">service</span><span class="hljs-params">(ServletRequest arg0, ServletResponse arg1)</span><br>            <span class="hljs-keyword">throws</span> ServletException, IOException &#123;<br>        System.out.println(<span class="hljs-string">&quot;heihei&quot;</span>);<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3、继承-HttpServlet-方法-只需要记住这一种"><a href="#3、继承-HttpServlet-方法-只需要记住这一种" class="headerlink" title="3、继承 HttpServlet 方法(只需要记住这一种)"></a><strong>3、继承 HttpServlet 方法</strong>(只需要记住这一种)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ServletDemo3</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">HttpServlet</span> &#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doGet</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span><br>            <span class="hljs-keyword">throws</span> ServletException, IOException &#123;<br>        System.out.println(<span class="hljs-string">&quot;haha&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doPost</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span><br>            <span class="hljs-keyword">throws</span> ServletException, IOException &#123;<br>        System.out.println(<span class="hljs-string">&quot;ee&quot;</span>);<br>        doGet(req,resp);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>创建 Servlet 的第三种方法，也是我们经常用的方法。</p><p>详细讲解一下第三种方式,继承 Httpservlet的方式</p><h3 id="实现Servlet规范"><a href="#实现Servlet规范" class="headerlink" title="实现Servlet规范"></a>实现Servlet规范</h3><p>实现 Servlet 规范，即继承 HttpServlet 类，并到如响应的包，该类中已经完成了通信的规则，我们只 需要进行业务的实现即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@WebServlet(&quot;/ser01&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ServletDemo3</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">HttpServlet</span> &#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doGet</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span><br>            <span class="hljs-keyword">throws</span> ServletException, IOException &#123;<br>        System.out.println(<span class="hljs-string">&quot;haha&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doPost</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span><br>            <span class="hljs-keyword">throws</span> ServletException, IOException &#123;<br>        System.out.println(<span class="hljs-string">&quot;ee&quot;</span>);<br>        doGet(req,resp);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="重写Service方法"><a href="#重写Service方法" class="headerlink" title="重写Service方法"></a>重写Service方法</h3><p>满足 Servlet 规范只是让我们的类能够满足接收请求的要求，接收到请求后需要对请求进行分析，以 及进行业务逻辑处理，计算出结果，则需要添加代码，在规范中有一个叫做 service的方法，专门用来做 请求处理的操作，业务代码则可以写在该方法中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java">HttpServlet <span class="hljs-keyword">extends</span> <span class="hljs-title class_">GenderServlet</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">service</span><span class="hljs-params">(ServletRequest,ServletResponse)</span> <span class="hljs-comment">//生命周期方法</span><br>    <span class="hljs-comment">//强调两个参数为http协议相关的类型，</span><br>    <span class="hljs-comment">//调用本来的servlet(HttpServletRequest,HttpServletResponse)</span><br>        <br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">service</span><span class="hljs-params">(HttpServletRequest,HttpServletResponse)</span><span class="hljs-comment">//参数已经是Http协议相关的，使用起来更加方便。</span><br>    <span class="hljs-comment">//它会通过request得到当前请求的请求方式，例如：GET或POST</span><br>    <span class="hljs-comment">//根据请求方式再调用doGet()或doPost()方法</span><br>        <br>     <span class="hljs-keyword">void</span> <span class="hljs-title function_">doGet</span><span class="hljs-params">(...)</span>  <span class="hljs-comment">//重写</span><br>     <span class="hljs-keyword">void</span> <span class="hljs-title function_">doPsot</span><span class="hljs-params">(...)</span> <span class="hljs-comment">//重写</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="设置注解"><a href="#设置注解" class="headerlink" title="设置注解"></a>设置注解</h3><p>我一般直接抛弃使用web.xml配置servlet的这一种方式,直接使用注解配置会方便很多.开发servlet项目，使用@WebServlet将一个继承于javax.servlet.http.HttpServlet 的类定义为Servlet 组件。在Servlet3.0中 ， 可以使用@WebServlet注解将一个继承于javax.servlet.http.HttpServlet的类 标注为可以处理用户请求的 Servlet。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@WebServlet(name=&quot;Servlet01&quot;,value=&quot;/ser01&quot;)</span> <span class="hljs-comment">//后面的参数代表网址(访问路径例如localhost:8080/Servlet01/ser01)</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@WebServlet(name=&quot;Servlet01&quot;,urlPatterns = &quot;/ser01&quot;)</span> <span class="hljs-comment">//后面的参数代表网址(访问路径例如localhost:8080/Servlet01/ser01)</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@WebServlet(name=&quot;Servlet01&quot;,value=&#123;&quot;/ser01&quot;,&#x27;/ser001&#x27;&#125;)</span> <span class="hljs-comment">//后面的参数代表网址(访问路径例如localhost:8080/Servlet01/ser01)</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@WebServlet(name=&quot;Servlet01&quot;,urlPatterns=&#123;&quot;/ser01&quot;,&#x27;/ser001&#x27;&#125;)</span><span class="hljs-comment">//后面的参数代表网址(访问路径例如localhost:8080/Servlet01/ser01)</span><br></code></pre></td></tr></table></figure><h3 id="Servlet生命周期"><a href="#Servlet生命周期" class="headerlink" title="Servlet生命周期"></a>Servlet生命周期</h3><p><strong>Servlet 的生命周期，简单的概括这就分为四步：servlet 类加载–&gt;实例化–&gt;服务–&gt;销毁。</strong></p><p><strong>1.Web Client向Servlet容器(Tomcat)发出Http请求</strong></p><p><strong>2.Servlet容器接收Web Client的请求</strong></p><p><strong>3.Servlet容器创建一个HttpServletRequest对象，将Web Client请求的信息封装到这个对象中</strong></p><p><strong>4.Servlet容器创建一个HttpServletResponse对象</strong></p><p><strong>5.Servlet容器调HttpServlet对象service方法，把Request与Response作为参数，传给HttpServlet</strong></p><p><strong>6.HttpServlet调用HttpServletRequest对象的有关方法，获取Http请求信息</strong></p><p><strong>7.HttpServlet调用HttpServletResponse对象的有关方法，生成响应数据</strong></p><p><strong>8.Servlet容器把HttpServlet的响应结果传给Web Client</strong></p><ul><li>void init(ServletConfig)：出生之后（1次）</li><li>void service(ServiceRequest request,ServletResponse response)：每次处理请求时都会被调用；&#x2F;&#x2F;通常我们extends HttpServlet,参数类型也会改成HttpRequest(HttpResponse)</li><li>void destroy()：临死之前（1次）；</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@WebServlet(name=&quot;AServlet&quot;,value=&quot;/ser01&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AServlet</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Servlet</span> &#123;    <br><span class="hljs-comment">//它是生命周期方法</span><br> <span class="hljs-comment">//它会在Servlet被销毁之前调用，并且它只会被调用一次！</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">destroy</span><span class="hljs-params">()</span> &#123;<br>System.out.println(<span class="hljs-string">&quot;destory()...&quot;</span>);<br>&#125;<br><span class="hljs-comment">//可以用来获取Servlet的配置信息 </span><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> ServletConfig <span class="hljs-title function_">getServletConfig</span><span class="hljs-params">()</span> &#123;<br>System.out.println(<span class="hljs-string">&quot;getServletConfig()...&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br><span class="hljs-comment">//获取Servlet的信息(用户调用，基本没用)</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">getServletInfo</span><span class="hljs-params">()</span> &#123;<br>System.out.println(<span class="hljs-string">&quot;getServletInfo()...&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;我是一个快乐的Servlet&quot;</span>;<br>&#125;<br> <span class="hljs-comment">//它是生命周期方法</span><br> <span class="hljs-comment">//它会在Servlet对象创建之后马上执行，并且只执行一次！（出生之后）</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">(ServletConfig servletConfig)</span> <span class="hljs-keyword">throws</span> ServletException &#123;<br>System.out.println(<span class="hljs-string">&quot;init()...&quot;</span>);<br>&#125;<br> <span class="hljs-comment">//它是生命周期方法</span><br> <span class="hljs-comment">//它会被调用多次</span><br> <span class="hljs-comment">//每次处理请求都是在调用这个方法</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">service</span><span class="hljs-params">(ServletRequest request, ServletResponse response)</span> <span class="hljs-keyword">throws</span> ServletException, IOException &#123;<br>System.out.println(<span class="hljs-string">&quot;service()...&quot;</span>);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--你也可以使用web.xml方式配置,我是感觉这种方式不好--&gt;</span><br><span class="hljs-comment">&lt;!--web.xml--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">servlet</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>aservlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">servlet-class</span>&gt;</span>com.edu.cn.AServlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-class</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">servlet</span>&gt;</span><br>  <br>  <span class="hljs-tag">&lt;<span class="hljs-name">servlet-mapping</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>aservlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/AServlet<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">servlet-mapping</span>&gt;</span><br><span class="hljs-comment">&lt;!--也可以在类中加@WebServlet(&quot;/AServlet&quot;)来设置--&gt;</span><br></code></pre></td></tr></table></figure><p><strong>特性：</strong></p><ul><li>单例，一个类只有一个对象；当然可能存在多个Servlet类</li><li>线程不安全的，所以它的效率是高的</li></ul><p>**注：Servlet类由我们来写，但对象由服务器来创建，并且有服务器来调用相应的方法。</p><h3 id="Servlet工作流程"><a href="#Servlet工作流程" class="headerlink" title="Servlet工作流程"></a>Servlet工作流程</h3><p><strong>1.通过请求头获知浏览器访问的是哪个主机</strong></p><p><strong>2.再通过请求行获取访问的是哪个一个web应用</strong></p><p><strong>3.再通过请求行中的请求路径获知访问的是哪个资源</strong></p><p><strong>4.通过获取的资源路径在配置中匹配到真实的路径，</strong></p><p><strong>5.服务器会创建servlety对象，（如果是第一次访问时，创建servlet:实例，并调用init方法进行初始化操作)</strong></p><p><strong>6.调用service(request,response)方法来处理请求和响应的操作</strong></p><p><strong>7.调用service:完毕后返回服务器由服务器讲response缓冲区的数据取出，以http响应的格式发送给浏览器</strong></p><h2 id="HttpServletRequset对象"><a href="#HttpServletRequset对象" class="headerlink" title="HttpServletRequset对象"></a>HttpServletRequset对象</h2><p>ttpServletRequest 对象：主要作用是用来接收客户端发送过来的请求信息，例如：请求的参数，发 送的头信息等都属于客户端发来的信息，service()方法中形参接收的是 HttpServletRequest 接口的实例 化对象，表示该对象主要应用在 HTTP 协议上，该对象是由 Tomcat 封装好传递过来。</p><p>HttpServletRequest 是 ServletRequest 的子接口，ServletRequest 只有一个子接口，就是 HttpServletRequest。既然只有一个子接口为什么不将两个接口合并为一个？</p><p>从长远上讲：现在主要用的协议是 HTTP 协议，但以后可能出现更多新的协议。若以后想要支持这种 新协议，只需要直接继承 ServletRequest 接口就行了。</p><p>在 HttpServletRequest 接口中，定义的方法很多，<strong>但都是围绕接收客户端参数的</strong>。但是怎么拿到该对象呢？不需要，直接在 Service 方法中由容器传入过来，而我们需要做的就是取出对象中的数据，进行 分析、处理。</p><h3 id="1-常用方法"><a href="#1-常用方法" class="headerlink" title="1.常用方法"></a><strong>1.常用方法</strong></h3><table><thead><tr><th>返回值类型</th><th>方法声明</th><th>描述</th></tr></thead><tbody><tr><td>String</td><td>getMethod()</td><td>该方法用于获取 HTTP 请求方式（如 GET、POST 等）。</td></tr><tr><td>String</td><td>getRequestURI()</td><td>该方法用于获取请求行中的资源名称部分，即位于 URL 的主机和端口之后，参数部分之前的部分。</td></tr><tr><td>String</td><td>getQueryString()</td><td>该方法用于获取请求行中的参数部分，也就是 URL 中“?”以后的所有内容。</td></tr><tr><td>String</td><td>getContextPath()</td><td>返回当前 Servlet 所在的应用的名字（上下文）。对于默认（ROOT）上下文中的 Servlet，此方法返回空字符串””。</td></tr><tr><td>String</td><td>getServletPath()</td><td>该方法用于获取 Servlet 所映射的路径。</td></tr><tr><td>String</td><td>getRemoteAddr()</td><td>该方法用于获取客户端的 IP 地址。</td></tr><tr><td>String</td><td>getRemoteHost()</td><td>该方法用于获取客户端的完整主机名，如果无法解析出客户机的完整主机名，则该方法将会返回客户端的 IP 地址。</td></tr></tbody></table><p><strong>示例 1</strong></p><p>为了更好地理解这些方法，下面通过案例演示这些方法的使用。</p><p>创建一个名称为 httpServletRequestDemo 的项目，在 net.biancheng.www 包中创建一个名为 RequestLine 的 Servlet 类，代码如下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> net.biancheng.www;<br><br><span class="hljs-keyword">import</span> java.io.IOException;<br><span class="hljs-keyword">import</span> java.io.PrintWriter;<br><br><span class="hljs-keyword">import</span> javax.servlet.ServletException;<br><span class="hljs-keyword">import</span> javax.servlet.annotation.WebServlet;<br><span class="hljs-keyword">import</span> javax.servlet.http.HttpServlet;<br><span class="hljs-keyword">import</span> javax.servlet.http.HttpServletRequest;<br><span class="hljs-keyword">import</span> javax.servlet.http.HttpServletResponse;<br><br><br><span class="hljs-meta">@WebServlet(&quot;/RequestLine&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RequestLine</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">HttpServlet</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">serialVersionUID</span> <span class="hljs-operator">=</span> <span class="hljs-number">1L</span>;<br><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doGet</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="hljs-keyword">throws</span> ServletException, IOException &#123;<br>        response.setContentType(<span class="hljs-string">&quot;text/html;charset=UTF-8&quot;</span>);<br>        <span class="hljs-type">PrintWriter</span> <span class="hljs-variable">writer</span> <span class="hljs-operator">=</span> response.getWriter();<br>        writer.println(<span class="hljs-string">&quot;请求方式:&quot;</span> + request.getMethod() + <span class="hljs-string">&quot;&lt;br/&gt;&quot;</span> +<br>                <span class="hljs-string">&quot;客户端的 IP 地址:&quot;</span> + request.getRemoteAddr() + <span class="hljs-string">&quot;&lt;br/&gt;&quot;</span> +<br>                <span class="hljs-string">&quot;应用名字（上下文）:&quot;</span> + request.getContextPath() + <span class="hljs-string">&quot;&lt;br/&gt;&quot;</span> +<br>                <span class="hljs-string">&quot;URI:&quot;</span> + request.getRequestURI() + <span class="hljs-string">&quot;&lt;br/&gt;&quot;</span> +<br>                <span class="hljs-string">&quot;请求字符串:&quot;</span> + request.getQueryString() + <span class="hljs-string">&quot;&lt;br/&gt;&quot;</span> +<br>                <span class="hljs-string">&quot;Servlet所映射的路径:&quot;</span> + request.getServletPath() + <span class="hljs-string">&quot;&lt;br/&gt;&quot;</span> +<br>                <span class="hljs-string">&quot;客户端的完整主机名:&quot;</span> + request.getRemoteHost() + <span class="hljs-string">&quot;&lt;br/&gt;&quot;</span><br>        );<br>    &#125;<br><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doPost</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="hljs-keyword">throws</span> ServletException, IOException &#123;<br>        doGet(request, response);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://gcore.jsdelivr.net/gh/fuchajun/blogImgs/img/202208021003569.png"></p><h3 id="获取-form-表单的数据"><a href="#获取-form-表单的数据" class="headerlink" title="获取 form 表单的数据"></a><strong>获取 form 表单的数据</strong></h3><p>在实际开发中，我们经常需要获取用户提交的表单数据，例如用户名和密码等。为了方便获取表单中的请求参数，ServletRequest 定义了一系列获取请求参数的方法，如下表所示。</p><table><thead><tr><th>返回值类型</th><th>方法声明</th><th>功能描述</th></tr></thead><tbody><tr><td>String</td><td>getParameter(String name)</td><td>返回指定参数名的参数值。</td></tr><tr><td>String [ ]</td><td>getParameterValues (String name)</td><td>以字符串数组的形式返回指定参数名的所有参数值（HTTP 请求中可以有多个相同参数名的参数）。</td></tr><tr><td>Enumeration</td><td>getParameterNames()</td><td>以枚举集合的形式返回请求中所有参数名。</td></tr><tr><td>Map</td><td>getParameterMap()</td><td>用于将请求中的所有参数名和参数值装入一个 Map 对象中返回。</td></tr></tbody></table><p><strong>示例 3</strong></p><p>为了更好地理解这些方法，下面通过案例演示这些方法的使用。</p><p>在 httpServletRequestDemo 的 WebContent 目录下，创建 form.html，代码如下。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Insert title here<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">action</span>=<span class="hljs-string">&quot;/httpServletRequestDemo/RequestParam&quot;</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;post&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">table</span> <span class="hljs-attr">border</span>=<span class="hljs-string">&quot;1&quot;</span> <span class="hljs-attr">width</span>=<span class="hljs-string">&quot;50%&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">colspan</span>=<span class="hljs-string">&quot;2&quot;</span> <span class="hljs-attr">align</span>=<span class="hljs-string">&quot;center&quot;</span>&gt;</span>编程帮wwww.biancheng.net<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>输入姓名<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;username&quot;</span> /&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>输入密码<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;password&quot;</span> /&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>选择性别<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;radio&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;sex&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;male&quot;</span> /&gt;</span>男 <span class="hljs-tag">&lt;<span class="hljs-name">input</span></span><br><span class="hljs-tag">                    <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;radio&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;sex&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;female&quot;</span> /&gt;</span>女<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>选择使用的语言<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;checkbox&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;language&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;JAVA&quot;</span> /&gt;</span>JAVA<br>                    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;checkbox&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;language&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;C&quot;</span> /&gt;</span>C语言 <span class="hljs-tag">&lt;<span class="hljs-name">input</span></span><br><span class="hljs-tag">                    <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;checkbox&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;language&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;PHP&quot;</span> /&gt;</span>PHP <span class="hljs-tag">&lt;<span class="hljs-name">input</span></span><br><span class="hljs-tag">                    <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;checkbox&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;language&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;Python&quot;</span> /&gt;</span>Python<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>选择城市<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;city&quot;</span>&gt;</span><br>                        <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;none&quot;</span>&gt;</span>--请选择--<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span><br>                        <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;beijing&quot;</span>&gt;</span>北京<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span><br>                        <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;shanghai&quot;</span>&gt;</span>上海<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span><br>                        <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;guangzhou&quot;</span>&gt;</span>广州<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span><br>                <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">colspan</span>=<span class="hljs-string">&quot;2&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;提交&quot;</span> /&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">table</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p>在 net.biancheng.www 包中，创建一个名为 RequestParam 的 Servlet 类，代码如下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> net.biancheng.www;<br><br><span class="hljs-keyword">import</span> java.io.IOException;<br><span class="hljs-keyword">import</span> java.io.PrintWriter;<br><span class="hljs-keyword">import</span> java.util.Arrays;<br><span class="hljs-keyword">import</span> java.util.Map;<br><span class="hljs-keyword">import</span> java.util.Set;<br><span class="hljs-keyword">import</span> javax.servlet.ServletException;<br><span class="hljs-keyword">import</span> javax.servlet.annotation.WebServlet;<br><span class="hljs-keyword">import</span> javax.servlet.http.HttpServlet;<br><span class="hljs-keyword">import</span> javax.servlet.http.HttpServletRequest;<br><span class="hljs-keyword">import</span> javax.servlet.http.HttpServletResponse;<br><br><span class="hljs-meta">@WebServlet(&quot;/RequestParam&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RequestParam</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">HttpServlet</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">serialVersionUID</span> <span class="hljs-operator">=</span> <span class="hljs-number">1L</span>;<br><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doGet</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span><br>            <span class="hljs-keyword">throws</span> ServletException, IOException &#123;<br>        response.setContentType(<span class="hljs-string">&quot;text/html;charset=UTF-8&quot;</span>);<br>        <span class="hljs-type">PrintWriter</span> <span class="hljs-variable">writer</span> <span class="hljs-operator">=</span> response.getWriter();<br>        <span class="hljs-comment">// 获取内容，做其他操作</span><br>        <span class="hljs-comment">// 获取姓名</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">username</span> <span class="hljs-operator">=</span> request.getParameter(<span class="hljs-string">&quot;username&quot;</span>);<br>        <span class="hljs-comment">// 获取密码</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">password</span> <span class="hljs-operator">=</span> request.getParameter(<span class="hljs-string">&quot;password&quot;</span>);<br>        <span class="hljs-comment">// 获取性别</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">sex</span> <span class="hljs-operator">=</span> request.getParameter(<span class="hljs-string">&quot;sex&quot;</span>);<br>        <span class="hljs-comment">// 获取城市</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">city</span> <span class="hljs-operator">=</span> request.getParameter(<span class="hljs-string">&quot;city&quot;</span>);<br>        <span class="hljs-comment">// 获取语言</span><br>        String[] languages = request.getParameterValues(<span class="hljs-string">&quot;language&quot;</span>);<br>        writer.write(<span class="hljs-string">&quot;用户名：&quot;</span> + username + <span class="hljs-string">&quot;&lt;br/&gt;&quot;</span> + <span class="hljs-string">&quot;密码：&quot;</span> + password + <span class="hljs-string">&quot;&lt;br/&gt;&quot;</span> + <span class="hljs-string">&quot;性别：&quot;</span> + sex + <span class="hljs-string">&quot;&lt;br/&gt;&quot;</span> + <span class="hljs-string">&quot;城市：&quot;</span> + city<br>                + <span class="hljs-string">&quot;&lt;br/&gt;&quot;</span> + <span class="hljs-string">&quot;使用过的语言：&quot;</span> + Arrays.toString(languages) + <span class="hljs-string">&quot;&lt;br/&gt;&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doPost</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span><br>            <span class="hljs-keyword">throws</span> ServletException, IOException &#123;<br>        doGet(request, response);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>启动 Tomcat 服务器，在地址栏中输入“<a href="http://localhost:8080/httpServletRequestDemo/form.html%E2%80%9D%EF%BC%8C%E5%8D%B3%E5%8F%AF%E8%AE%BF%E9%97%AE">http://localhost:8080/httpServletRequestDemo/form.html”，即可访问</a> form.html，结果如下图。</p><p><img src="https://gcore.jsdelivr.net/gh/fuchajun/blogImgs/img/202208021004375.png"></p><p>在表单中填写信息后，点击提交，结果如下图。</p><p><img src="https://gcore.jsdelivr.net/gh/fuchajun/blogImgs/img/202208021004870.png"></p><h3 id="请求乱码"><a href="#请求乱码" class="headerlink" title="请求乱码"></a>请求乱码</h3><p>解决请求乱码的前提是我们必须要明白为什么会产生乱码,由于现在的 request 属于接收客户端的参数，所以必然有其默认的语言编码，主要是由于在解析过程 中默认使用的编码方式为 ISO-8859-1(此编码不支持中文)，所以解析时一定会出现乱码。要想解决这种 乱码问题，需要设置 request 中的编码方式，告诉服务器以何种方式来解析数据。或者在接收到乱码数 据以后，再通过相应的编码格式还原。</p><p>还有一点我们要了解,Tomcat8起，以后的GET方式请求是不会出现乱码的,言外之意,POST请求是可能出现乱码的.</p><p>方式一： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">request.setCharacterEncoding(<span class="hljs-string">&quot;UTF-8&quot;</span>);<br></code></pre></td></tr></table></figure><p>这种方式只针对 POST 有效（必须在接收所有的数据之前设定） </p><p>方式二：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(request.getParameter(name).getBytes(<span class="hljs-string">&quot;ISO-8859-1&quot;</span>),<span class="hljs-string">&quot;UTF-8&quot;</span>);<br></code></pre></td></tr></table></figure><p>借助了String 对象的方法，该种方式对任何请求有效，是通用的</p><h3 id="请求转发"><a href="#请求转发" class="headerlink" title="请求转发"></a>请求转发</h3><p>请求转发，是一种服务器的行为，当客户端请求到达后，服务器进行转发，此时会将请求对象进行保 存，地址栏中的 URL 地址不会改变，得到响应后，服务器端再将响应发送给客户端，从始至终只有一个 请求发出。</p><p>实现方式如下，达到多个资源协同响应的效果。</p><figure class="highlight vbscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vbscript"><span class="hljs-built_in">request</span>.getRequestDispatcher(url).forward(<span class="hljs-built_in">request</span>,<span class="hljs-built_in">response</span>);<br></code></pre></td></tr></table></figure><h3 id="Request作用域"><a href="#Request作用域" class="headerlink" title="Request作用域"></a>Request作用域</h3><p>通过该对象可以在一个请求中传递数据，作用范围：在一次请求中有效，即服务器跳转有效。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 设置域对象内容</span><br>request.setAttribute(String name, String value);<br><span class="hljs-comment">// 获取域对象内容</span><br>request.getAttribute(String name);<br><span class="hljs-comment">// 删除域对象内容</span><br>request.removeAttribute(String name)<br></code></pre></td></tr></table></figure><p>request 域对象中的数据在一次请求中有效，则经过请求转发，request 域中的数据依然存在，则在 请求转发的过程中可以通过 request 来传输&#x2F;共享数据。</p><h2 id="HttpServletResponse对象"><a href="#HttpServletResponse对象" class="headerlink" title="HttpServletResponse对象"></a>HttpServletResponse对象</h2><p>在 Servlet API 中，定义了一个 HttpServletResponse 接口，它继承自 ServletResponse 接口。HttpServletResponse 对象专门用来封装 HTTP 响应消息，简称 response 对象。</p><p>Servlet 容器会针对每次请求创建一个 response 对象，并把它作为参数传递给 Servlet 的 service 方法。Servlet 处理请求后，会将响应信息封装到 response 对象中，并由容器解析后返回给客户端。</p><p>由于 HTTP 响应消息由响应行、响应头、消息体三部分组成，所以 HttpServletResponse 接口中定义了向客户端发送响应状态码、响应头、响应体的方法，下面我们将针对这些方法进行介绍。</p><h3 id="响应行相关的方法"><a href="#响应行相关的方法" class="headerlink" title="响应行相关的方法"></a>响应行相关的方法</h3><p>当 Servlet 返回响应消息时，需要在响应消息中设置状态码。因此，HttpServletResponse 接口定义了发送状态码的方法，如下表。</p><table><thead><tr><th>返回值类型</th><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>void</td><td>setStatus（int status）</td><td>用于设置 HTTP 响应消息的状态码，并生成响应状态行。</td></tr><tr><td>void</td><td>sendError（int sc）</td><td>用于发送表示错误信息的状态码。</td></tr></tbody></table><h3 id="响应头相关的方法"><a href="#响应头相关的方法" class="headerlink" title="响应头相关的方法"></a>响应头相关的方法</h3><p>HttpServletResponse 接口中定义了一系列设置 HTTP 响应头字段的方法，如下表所示。</p><table><thead><tr><th>返回值类型</th><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>void</td><td>addHeader(String name,String value)</td><td>用于增加响应头字段，其中，参数 name 用于指定响应头字段的名称，参数 value 用于指定响应头字段的值。</td></tr><tr><td>void</td><td>setHeader (String name,String value)</td><td>用于设置响应头字段，其中，参数 name 用于指定响应头字段的名称，参数 value 用于指定响应头字段的值。</td></tr><tr><td>void</td><td>addIntHeader(String name,int value)</td><td>用于增加值为 int 类型的响应头字段，其中，参数 name 用于指定响应头字段的名称，参数 value 用于指定响应头字段的值，类型为 int。</td></tr><tr><td>void</td><td>setIntHeader(String name, int value)</td><td>用于设置值为 int 类型的响应头字段，其中，参数 name 用于指定响应头字段的名称，参数 value 用于指定响应头字段的值，类型为 int。</td></tr><tr><td>void</td><td>setContentType(String type)</td><td>用于设置 Servlet 输出内容的 MIME 类型以及编码格式。</td></tr><tr><td>void</td><td>setCharacterEncoding(String charset)</td><td>用于设置输出内容使用的字符编码。</td></tr></tbody></table><h3 id="响应体相关的方法"><a href="#响应体相关的方法" class="headerlink" title="响应体相关的方法"></a>响应体相关的方法</h3><p>由于在 HTTP 响应消息中，大量的数据都是通过响应消息体传递的。因此 ServletResponse 遵循以 I&#x2F;O 流传递大量数据的设计理念，在发送响应消息体时，定义了两个与输出流相关的方法。</p><table><thead><tr><th>返回值类型</th><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>ServletOutputStream</td><td>getOutputStream()</td><td>用于获取字节输出流对象。</td></tr><tr><td>PrintWriter</td><td>getWriter()</td><td>用于获取字符输出流对象。</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//注意：getOutputStream() 和 getWriter() 方法互相排斥，不可同时使用，否则会发生 IllegalStateException 异常。</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">*</span><br><span class="hljs-comment">* <span class="hljs-doctag">@author</span> 编程帮 www.biancheng.net 使用response对象向页面输出内容</span><br><span class="hljs-comment">*</span><br><span class="hljs-comment">*/</span><br><span class="hljs-meta">@WebServlet(&quot;/OutServlet&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OutServlet</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">HttpServlet</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">serialVersionUID</span> <span class="hljs-operator">=</span> <span class="hljs-number">1L</span>;<br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doGet</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span><br>            <span class="hljs-keyword">throws</span> ServletException, IOException &#123;<br>        run1(response);<br>        <span class="hljs-comment">// run2(response);</span><br>    &#125;<br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doPost</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span><br>            <span class="hljs-keyword">throws</span> ServletException, IOException &#123;<br>        doGet(request, response);<br>    &#125;<br>    <span class="hljs-comment">// 使用字符流向页面输出</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run2</span><span class="hljs-params">(HttpServletResponse response)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        response.getWriter().write(<span class="hljs-string">&quot;编程帮 www.biancheng.net&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">// 使用字节流向页面输出</span><br>    <span class="hljs-comment">// 使用字节流向页面输出</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run1</span><span class="hljs-params">(HttpServletResponse response)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-comment">// 设置浏览器打开文件时编码</span><br>        response.setHeader(<span class="hljs-string">&quot;Content-Type&quot;</span>, <span class="hljs-string">&quot;text/html;charset=UTF-8&quot;</span>);<br>        <span class="hljs-comment">// 获取字节输出流</span><br>        <span class="hljs-type">OutputStream</span> <span class="hljs-variable">os</span> <span class="hljs-operator">=</span> response.getOutputStream();<br>        <span class="hljs-type">byte</span>[] str = <span class="hljs-string">&quot;编程帮 www.biancheng.net&quot;</span>.getBytes(<span class="hljs-string">&quot;UTF-8&quot;</span>);<br>        <span class="hljs-comment">// 输出中文</span><br>        os.write(str);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>启动 Tomat 服务器，在客户端浏览器地址栏输入“<a href="http://localhost:8080/responseDemo/OutServlet%E2%80%9D%E8%AE%BF%E9%97%AE">http://localhost:8080/responseDemo/OutServlet”访问</a> OutServlet，结果如下图。</p><p><img src="https://gcore.jsdelivr.net/gh/fuchajun/blogImgs/img/202208021004955.png"></p><p>在 doGet() 方法中调用 run2() 方法，使用字符流输出响应内容到浏览器，再次访问 OutServlet，结果如下图。</p><p><img src="https://gcore.jsdelivr.net/gh/fuchajun/blogImgs/img/202208021004647.png"></p><h3 id="response-中文乱码问题"><a href="#response-中文乱码问题" class="headerlink" title="response 中文乱码问题"></a>response 中文乱码问题</h3><p>response 对象向页面输出时有两种方式：字节流、字符流，这两种方式输出中文时都有可能出现乱码。下面我们针对这两种方式出现乱码的原因以及解决方案进行介绍。</p><h4 id="使用字节流输出中文"><a href="#使用字节流输出中文" class="headerlink" title="使用字节流输出中文"></a>使用字节流输出中文</h4><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">ServletOutputStream outptuStream <span class="hljs-operator">=</span> response.getOutputStream()<span class="hljs-comment">;outputStream.write(“编程帮 www.biancheng.net”.getBytes());</span><br></code></pre></td></tr></table></figure><p>使用字节流向页面输出中文是否会出现乱码问题？不一定。</p><h4 id="乱码原因："><a href="#乱码原因：" class="headerlink" title="乱码原因："></a>乱码原因：</h4><p>字节流输出中文是否出现乱码，取决于中文转成字节数组时与浏览器打开时采用的字符集是否一致。若两者保持一致，则不会出现乱码问题，若不一致就会出现乱码问题。</p><h4 id="解决方案："><a href="#解决方案：" class="headerlink" title="解决方案："></a>解决方案：</h4><p>将中文转成字节数组时和浏览器默认采用的字符集保持一致即可，代码如下。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">response.setHeader(<span class="hljs-string">&quot;Content-Type&quot;</span>, <span class="hljs-string">&quot;text/html;charset=UTF-8&quot;</span>);<span class="hljs-regexp">//</span> 获取字节输出流OutputStream os = response.getOutputStream();byte[] str = <span class="hljs-string">&quot;编程帮 www.biancheng.net&quot;</span>.getBytes(<span class="hljs-string">&quot;UTF-8&quot;</span>);<span class="hljs-regexp">//</span> 输出中文os.write(str);<br></code></pre></td></tr></table></figure><h4 id="使用字符流输出中文"><a href="#使用字符流输出中文" class="headerlink" title="使用字符流输出中文"></a>使用字符流输出中文</h4><p>使用字符流向页面输出中文是否会出现乱码问题？一定乱码。</p><h4 id="乱码原因：-1"><a href="#乱码原因：-1" class="headerlink" title="乱码原因："></a>乱码原因：</h4><p>通过字符流输出的内容是存放在 response 缓冲区的，response 缓冲区的默认字符集是 ISO-8859-1，该字符集不支持中文。</p><h4 id="解决方案：-1"><a href="#解决方案：-1" class="headerlink" title="解决方案："></a>解决方案：</h4><p>将 response 缓冲区和浏览器采用的字符集保持一致即可，有如下 2 种的方式。</p><p>第一种方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 设置response缓冲区的编码response.setCharacterEncoding(&quot;UTF-8&quot;);// 设置浏览器打开文件所采用的编码response.setHeader(&quot;Content-Type&quot;, &quot;text/html;charset=UTF-8&quot;);// 输出中文response.getWriter().write(&quot;编程帮 www.biancheng.net&quot;);</span><br></code></pre></td></tr></table></figure><p>第二种方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">纯文本复制<br>response.setContentType(<span class="hljs-string">&quot;text/html;charset=UTF-8&quot;</span>);response.getWriter().write(<span class="hljs-string">&quot;编程帮 www.biancheng.net&quot;</span>);<br></code></pre></td></tr></table></figure><h2 id=""><a href="#" class="headerlink" title=""></a></h2><h2 id="会话技术-Cookie对象"><a href="#会话技术-Cookie对象" class="headerlink" title="会话技术(Cookie对象)"></a>会话技术(Cookie对象)</h2><p>从打开浏览器访问某个网站，到关闭浏览器的过程，称为一次会话。会话技术是指在会话中，帮助服务器记录用户状态和数据的技术。</p><p>常用的会话技术分为两种：</p><ol><li>Cookie ：客户端会话技术</li><li>Session ：服务端会话技术</li></ol><p>本节将对 Cookie 进行介绍，下节将对 Session 进行介绍。</p><p>Cookie是浏览器提供的一种技术，通过服务器的程序能将一些只须保存在客户端，或者在客户端进行 处理的数据，放在本地的计算机上，不需要通过网络传输，因而提高网页处理的效率，并且能够减少服 务器的负载，但是由于 Cookie 是服务器端保存在客户端的信息， 所以其安全性也是很差的。例如常见 的记住密码则可以通过 Cookie 来实现。</p><h3 id="Cookie-的分类"><a href="#Cookie-的分类" class="headerlink" title="Cookie 的分类"></a>Cookie 的分类</h3><p>Cookie分为两种：</p><ol><li>会话级别 Cookie（默认）：Cookie 保存到浏览器的内存中，浏览器关闭则 Cookie 失效。</li><li>持久的 Cookie：Cookie 以文本文件的形式保存到硬盘上。</li></ol><h3 id="Cookie-API"><a href="#Cookie-API" class="headerlink" title="Cookie API"></a>Cookie API</h3><p>javax.servlet.http 包中定义了一个 Cookie 类，利用它的带参构造方法，可以创建 Cookie 对象。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Cookie</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Cookie</span>(<span class="hljs-string">&quot;url&quot;</span>, <span class="hljs-string">&quot;www.biancheng.net&quot;</span>); <br></code></pre></td></tr></table></figure><p>其中参数 name 为 Cookie 的名称，参数 value 为 Cookie 的值，name 与 value 的取值不能包含 <code>[ ] ( ) = , &quot; / ? @ : ;</code>等字符</p><p><strong>HttpServletResponse 接口和 HttpServletRequest 接口也都定义了与 Cookie 相关的方法，如下表所示。</strong></p><table><thead><tr><th>方法</th><th>描述</th><th>所属接口</th></tr></thead><tbody><tr><td>void addCookie(Cookie cookie)</td><td>用于在响应头中增加一个相应的 Set-Cookie 头字段。</td><td>javax.servlet.http.HttpServletResponse</td></tr><tr><td>Cookie[] getCookies()</td><td>用于获取客户端提交的 Cookie。</td><td>javax.servlet.http.HttpServletRequest</td></tr></tbody></table><p>javax.servlet.http.Cookie 类中提供了一系列</p><h3 id="获取或者设置-Cookie-的方法"><a href="#获取或者设置-Cookie-的方法" class="headerlink" title="获取或者设置 Cookie 的方法"></a>获取或者设置 Cookie 的方法</h3><p>，如下表。</p><table><thead><tr><th>返回值类型</th><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>int</td><td>getMaxAge()</td><td>用于获取指定 Cookie 的最大有效时间，以秒为单位。 默认情况下取值为 -1，表示该 Cookie 保留到浏览器关闭为止。</td></tr><tr><td>String</td><td>getName()</td><td>用于获取 Cookie 的名称。</td></tr><tr><td>String</td><td>getPath()</td><td>用于获取 Cookie 的有效路径。</td></tr><tr><td>boolean</td><td>getSecure()</td><td>如果浏览器只通过安全协议发送 Cookie，则返回 true；如果浏览器可以使用任何协议发送 Cookie，则返回 false。</td></tr><tr><td>String</td><td>getValue()</td><td>用于获取 Cookie 的值。</td></tr><tr><td>int</td><td>getVersion()</td><td>用于获取 Cookie 遵守的协议版本。</td></tr><tr><td>void</td><td>setMaxAge(int expiry)</td><td>用于设置 Cookie 的最大有效时间，以秒为单位。 取值为正值时，表示 Cookie 在经过指定时间后过期。取值为负值时，表示 Cookie 不会被持久存储，在 Web 浏览器退出时删除。取值为 0 时，表示删除该 Cookie。</td></tr><tr><td>void</td><td>setPath(String uri)</td><td>用于指定 Cookie 的路径。</td></tr><tr><td>void</td><td>setSecure(boolean flag)</td><td>用于设置浏览器是否只能使用安全协议（如 HTTPS 或 SSL）发送 Cookie。</td></tr><tr><td>void</td><td>setValue(String newValue)</td><td>用于设置 Cookie 的值。</td></tr></tbody></table><h3 id="Cookie-的使用细节"><a href="#Cookie-的使用细节" class="headerlink" title="Cookie 的使用细节"></a>Cookie 的使用细节</h3><p>使用 Cookie 开发时需要注意以下细节：</p><ul><li><p>一个 Cookie 只能标识一种信息，它至少包含一个名称（NAME）和一个值（VALUE）。</p></li><li><p>如果创建了一个 Cookie，并发送到浏览器，默认情况下它是一个会话级别的 Cookie。用户退出浏览器就被删除。如果希望将 Cookie 存到磁盘上，则需要调用 setMaxAge(int maxAge) 方法设置最大有效时间，以秒为单位。</p></li><li><p>使用 setMaxAge(0) 手动删除 Cookie时，需要使用 setPath 方法指定 Cookie 的路径，且该路径必须与创建 Cookie 时的路径保持一致。</p></li><li><p>浏览器存放Cookie的数量 不同的浏览器对Cookie也有限定，Cookie的存储有是上限的,大概是4kb。Cookie是存储在客户端（浏览器） 的，而且一般是由服务器端创建和设定。后期结合Session来实现回话跟踪。</p></li><li><p>Cookie存中文问题</p><ul><li><p>Cookie 中不能出现中文，如果有中文则通过 URLEncoder.encode()来进行编码，获取时通过 URLDecoder.decode()来进行解码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;姓名&quot;</span>;<br><span class="hljs-type">String</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;张三&quot;</span>;<br><span class="hljs-comment">// 通过 URLEncoder.encode()来进行编码</span><br>name = URLEncoder.encode(name);<br>value = URLEncoder.encode(value);<br><span class="hljs-comment">// 创建Cookie对象</span><br><span class="hljs-type">Cookie</span> <span class="hljs-variable">cookie</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Cookie</span>(name,value);<br><span class="hljs-comment">// 发送Cookie对象</span><br>response.addCookie(cookie);<br><br>........<br>     <br><br><span class="hljs-comment">// 获取时通过 URLDecoder.decode()来进行解码</span><br>URLDecoder.decode(cookie.getName());<br>URLDecoder.decode(cookie.getValue());<br><br></code></pre></td></tr></table></figure></li></ul></li></ul><h3 id="Cookie-的缺点"><a href="#Cookie-的缺点" class="headerlink" title="Cookie 的缺点"></a>Cookie 的缺点</h3><p>Cookie 虽然可以解决服务器跟踪用户状态的问题，但是它具有以下缺点：</p><ul><li><p>在 HTTP 请求中，Cookie 是明文传递的，容易泄露用户信息，安全性不高。</p></li><li><p>浏览器可以禁用 Cookie，一旦被禁用，Cookie 将无法正常工作。</p></li><li><p>Cookie 对象中只能设置文本（字符串）信息。</p></li><li><p>客户端浏览器保存 Cookie 的数量和长度是有限制的。</p></li></ul><h3 id="Cookie的路径"><a href="#Cookie的路径" class="headerlink" title="Cookie的路径"></a>Cookie的路径</h3><p>Cookie的setPath设置cookie的路径，这个路径直接决定服务器的请求是否会从浏览器中加载某些 cookie。</p><p><strong>情景一：当前服务器下任何项目的任意资源都可获取Cookie对象</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/* 当前项目路径为：s01 */</span><br><span class="hljs-type">Cookie</span> <span class="hljs-variable">cookie</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Cookie</span>(<span class="hljs-string">&quot;xxx&quot;</span>,<span class="hljs-string">&quot;XXX&quot;</span>);<br><span class="hljs-comment">// 设置路径为&quot;/&quot;，表示在当前==服务器==下任何项目都可访问到Cookie对象</span><br>cookie.setPath(<span class="hljs-string">&quot;/&quot;</span>);<br>response.addCookie(cookie);<br></code></pre></td></tr></table></figure><p><strong>情景二：当前项目下的资源可获取Cookie对象 （默认不设置Cookie的path）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/* 当前项目路径为：s01 */</span><br><span class="hljs-type">Cookie</span> <span class="hljs-variable">cookie</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Cookie</span>(<span class="hljs-string">&quot;xxx&quot;</span>,<span class="hljs-string">&quot;XXX&quot;</span>);<br><span class="hljs-comment">// 设置路径为&quot;/s01&quot;，表示在==当前项目下任何项目==都可访问到Cookie对象</span><br>cookie.setPath(<span class="hljs-string">&quot;/s01&quot;</span>); <span class="hljs-comment">// 默认情况，可不设置path的值</span><br>response.addCookie(cookie);<br></code></pre></td></tr></table></figure><p><strong>情景三：指定项目下的资源可获取Cookie对象</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/* 当前项目路径为：s01 */</span><br><span class="hljs-type">Cookie</span> <span class="hljs-variable">cookie</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Cookie</span>(<span class="hljs-string">&quot;xxx&quot;</span>,<span class="hljs-string">&quot;XXX&quot;</span>);<br><span class="hljs-comment">// 设置路径为&quot;/s02&quot;，表示在s02项目下才可访问到Cookie对象</span><br>cookie.setPath(<span class="hljs-string">&quot;/s02&quot;</span>); <span class="hljs-comment">// 只能在s02项目下获取Cookie，就算cookie是s01产生的，==s01也不能获取它==</span><br>response.addCookie(cookie);<br></code></pre></td></tr></table></figure><p><strong>情景四：指定目录下的资源可获取Cookie对象</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/* 当前项目路径为：s01 */</span><br><span class="hljs-type">Cookie</span> <span class="hljs-variable">cookie</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Cookie</span>(<span class="hljs-string">&quot;xxx&quot;</span>,<span class="hljs-string">&quot;XXX&quot;</span>);<br><span class="hljs-comment">// 设置路径为&quot;/s01/cook&quot;，表示在s02/cook目录下才可访问到Cookie对象</span><br>cookie.setPath(<span class="hljs-string">&quot;/s01/cook&quot;</span>);<br>response.addCookie(cookie);<br></code></pre></td></tr></table></figure><p>如果我们设置path，如果当前访问的路径包含了cookie的路径（当前访问路径在cookie路径基础上要 比cookie的范围小）cookie就会加载到request对象之中。</p><p>cookie的路径指的是可以访问该cookie的顶层目录，该路径的子路径也可以访问该cookie。</p><p>&#x3D;&#x3D;<strong>总结：当访问的路径包含了cookie的路径时，则该请求将带上该cookie；如果访问路径不包含 cookie路径，则该请求不会携带该cookie。</strong>&#x3D;&#x3D;</p><h2 id="会话技术-HttpSession对象"><a href="#会话技术-HttpSession对象" class="headerlink" title="会话技术(HttpSession对象)"></a>会话技术(HttpSession对象)</h2><p>从打开浏览器访问某个网站，到关闭浏览器的过程，称为一次会话。会话技术是指在会话中，帮助服务器记录用户状态和数据的技术。</p><p>常用的会话技术分为两种：</p><ol><li>Cookie ：客户端会话技术</li><li>Session ：服务端会话技术</li></ol><h3 id="Session-的工作原理-JSESSIONID"><a href="#Session-的工作原理-JSESSIONID" class="headerlink" title="Session 的工作原理(JSESSIONID)"></a>Session 的工作原理(JSESSIONID)</h3><p><img src="https://gcore.jsdelivr.net/gh/fuchajun/blogImgs/img/202208021004083.jpeg"></p><ol><li><p>当客户端第一次请求会话对象时，服务器会创建一个 Session 对象，并为该 Session 对象分配一个唯一的 SessionID（用来标识这个 Session 对象）；</p></li><li><p>服务器将 SessionID 以 Cookie（Cookie 名称为：“JSESSIONID”，值为 SessionID 的值）的形式发送给客户端浏览器；</p></li><li><p>客户端浏览器再次发送 HTTP 请求时，会将携带 SessionID 的 Cookie 随请求一起发送给服务器；</p></li><li><p>服务器从请求中读取 SessionID，然后根据 SessionID 找到对应的 Session 对象。</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//注意：</span><br><span class="hljs-comment">//流程中的 Cookie 是容器自动生成的，它的 maxAge 属性取值为 -1，表示仅当前浏览器有效。</span><br><span class="hljs-comment">//浏览器关闭时，对应的 Session 并没有失效，但此时与此 Session 对应的 Cookie 已失效，导致浏览器无法再通过 Cookie 获取服务器端的 Session 对象。</span><br><span class="hljs-comment">//同一浏览器的不同窗口共享同一 Session 对象，但不同浏览器窗口之间不能共享 Session 对象。</span><br></code></pre></td></tr></table></figure><p>Session既然是为了标识一次会话，那么此次会话就应该有一个唯一的标志，这个标志就是 sessionld。 </p><p>每当一次请求到达服务器，如果开启了会话（访问了session)，服务器第一步会查看是否从客户端 回传一个名为SESSIONID的cookie,如果没有则认为这是一次新的会话，会创建一个新的session对 象，并用唯一的sessionld为此次会话做一个标志。如果有IESSIONID这个cookiel回传，服务器则会根 据JSESSIONID这个值去查看是否含有id为SESSION值的session对象，如果没有则认为是一个新的会 话，重新创建一个新的session对象，并标志此次会话；如果找到了相应的session对象，则认为是之 前标志过的一次会话，返回该session对象，数据达到共享。 </p><p>这里提到一个叫做SESSIONID的cookie,这是一个比较特殊的cookie,当用户请求服务器时，如果 访问了session,则服务器会创建一个名为SESSIONID,值为获取到的session(无论是获取到的还是 新创建的)的sessionld的cookie对象，并添加到response对象中，响应给客户端，有效时间为关闭 浏览器。 </p><p><strong>所以Session的底层依赖Cookie来实现.</strong></p><h3 id="Session-API"><a href="#Session-API" class="headerlink" title="Session API"></a>Session API</h3><p>Session 对象由服务器创建，通过 HttpServletRequest.getSession() 方法可以获得 HttpSession 对象，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//获取session对象HttpSession session=request.getSession();</span><br></code></pre></td></tr></table></figure><p>HttpSession 接口定义了一系列对 </p><h3 id="Session-对象操作的方法"><a href="#Session-对象操作的方法" class="headerlink" title="Session 对象操作的方法"></a>Session 对象操作的方法</h3><p>，如下表。</p><table><thead><tr><th>返回值类型</th><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>long</td><td>getCreationTime()</td><td>返回创建 Session 的时间。</td></tr><tr><td>String</td><td>getId()</td><td>返回获取 Seesion 的唯一的 ID。</td></tr><tr><td>long</td><td>getLastAccessedTime()</td><td>返回客户端上一次发送与此 Session 关联的请求的时间。(获取最后一次访问时间)</td></tr><tr><td>boolean</td><td>isNew()</td><td>判断是否是新的Session对象</td></tr><tr><td>int</td><td>getMaxInactiveInterval()</td><td>返回在无任何操作的情况下，Session 失效的时间，以秒为单位。</td></tr><tr><td>ServletContext</td><td>getServletContext()</td><td>返回 Session 所属的 ServletContext 对象。</td></tr><tr><td>void</td><td>invalidate()</td><td>使 Session 失效。</td></tr><tr><td>void</td><td>setMaxInactiveInterval(int interval)</td><td>指定在无任何操作的情况下，Session 失效的时间，以秒为单位。负数表示 Session 永远不会失效。</td></tr></tbody></table><h3 id="Session的域对象"><a href="#Session的域对象" class="headerlink" title="Session的域对象"></a>Session的域对象</h3><p>Session 用来表示一次会话，在一次会话中数据是可以共享的，这时 session 作为域对象存在，可以 通过 setAttribute(name,value) 方法向域对象中添加数据，通过 getAttribute(name) 从域对象中获取 数据，通过 removeAttribute(name) 从域对象中移除数据。</p><p>在 javax.servlet.http.HttpSession 接口中定义了一系列操作属性的方法，如下表。</p><table><thead><tr><th>返回值类型</th><th>方法</th><th align="left">描述</th></tr></thead><tbody><tr><td>void</td><td>setAttribute(String name, Object o)</td><td align="left">把一个 Java 对象与一个属性名绑定，并将它作为一个属性存放到 Session 对象中。 参数 name 为属性名，参数 object 为属性值。</td></tr><tr><td>Object</td><td>getAttribute(String name)</td><td align="left">根据指定的属性名 name，返回 Session 对象中对应的属性值。</td></tr><tr><td>void</td><td>removeAttribute(String name)</td><td align="left">从 Session 对象中移除属性名为 name 的属性。</td></tr><tr><td>Enumeration</td><td>getAttributeNames()</td><td align="left">用于返回 Session 对象中的所有属性名的枚举集合。</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 获取session对象</span><br><span class="hljs-type">HttpSession</span> <span class="hljs-variable">session</span> <span class="hljs-operator">=</span> request.getSession();<br><span class="hljs-comment">// 设置session域对象</span><br>session.setAttribute(<span class="hljs-string">&quot;uname&quot;</span>,<span class="hljs-string">&quot;admin&quot;</span>);<br><span class="hljs-comment">// 获取指定名称的session域对象</span><br><span class="hljs-type">String</span> <span class="hljs-variable">uname</span> <span class="hljs-operator">=</span> (String) request.getAttribute(<span class="hljs-string">&quot;uname&quot;</span>);<br><span class="hljs-comment">// 移除指定名称的session域对象</span><br>session.removeAttribute(<span class="hljs-string">&quot;uname&quot;</span>);<br></code></pre></td></tr></table></figure><p>数据存储在 session 域对象中，当 session 对象不存在了，或者是两个不同的 session 对象时，数据 也就不能共享了。这就不得不谈到 session 的生命周期。</p><p>同一个request,request域对象可以共享,言外之意,不同的request拿不到不属于他的request域对象例如request.setAttribute(“uname”,”admin),假设重定向网页(前面我们得知重定向是两次请求),request.getAttribute(“uname”)就得不到想要的数据;</p><p>而Session作为会话,session.setAttribute(“uname”,”admin”);重定向后还是同一个Session,可以同String uname &#x3D; (String) session.getAttribute(“uname”);得到想要的数据内容.</p><h3 id="Session-的生命周期"><a href="#Session-的生命周期" class="headerlink" title="Session 的生命周期"></a>Session 的生命周期</h3><h4 id="Session-对象创建"><a href="#Session-对象创建" class="headerlink" title="Session 对象创建"></a>Session 对象创建</h4><p>Session 对象在容器第一次调用 request.getSession() 方法时创建。</p><blockquote><p>值得注意的是，当客户端访问的 Web 资源是 HTML，CSS，图片等静态资源时，服务器不会创建 Session 对象。</p></blockquote><h4 id="Session-对象销毁"><a href="#Session-对象销毁" class="headerlink" title="Session 对象销毁"></a>Session 对象销毁</h4><h4 id="Session-对象在如下-3-种情况下会被销毁："><a href="#Session-对象在如下-3-种情况下会被销毁：" class="headerlink" title="Session 对象在如下 3 种情况下会被销毁："></a>Session 对象在如下 3 种情况下会被销毁：</h4><ul><li><p>Session 过期；</p><p><strong>默认时间到期</strong></p><p>当客户端第一次请求 servlet 并且操作 session 时，session 对象生成，Tomcat 中 session 默认的存 活时间为 30min，即你不操作界面的时间，一旦有操作，session 会重新计时。 那么 session 的默认时间可以改么？答案是肯定的。 可以在 Tomcat 中的 conf 目录下的 web.xml 文件中进行修改。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- session 默认的最大不活动时间。单位：分钟。 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">session-config</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">session-timeout</span>&gt;</span>30<span class="hljs-tag">&lt;/<span class="hljs-name">session-timeout</span>&gt;</span><span class="hljs-comment">&lt;!--配置为30min,正常情况不建议配置,自己配置属于修改tomcat默认配置了,一改则这个项目下Session都被改动--&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">session-config</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>自己设定到期时间</strong> </p><p>当然除了以上的修改方式外，我们也可以在程序中自己设定 session 的生命周期，通过 <strong>session.setMaxInactiveInterval(int)</strong> 来设定 session 的最大不活动时间，<strong>单位为秒</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 获取session对象</span><br><span class="hljs-type">HttpSession</span> <span class="hljs-variable">session</span> <span class="hljs-operator">=</span> request.getSession();ni<br><span class="hljs-comment">// 设置session的最大不活动时间</span><br>session.setMaxInactiveInterval(<span class="hljs-number">15</span>); <span class="hljs-comment">// 15秒</span><br>session.getMaxInactiveInterval;<span class="hljs-comment">//查看当前Session对象的最大不活动时间</span><br></code></pre></td></tr></table></figure><p>当然我们也可以通过 getMaxInactiveInterval() 方法来查看当前 Session 对象的最大不活动时间。</p><p>&#x2F;&#x2F; 获取session的最大不活动时间 int time &#x3D; session.getMaxInactiveInterval();</p></li><li><p>调用 session.invalidate() 方法，手动销毁 Session；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 销毁session对象,退出登录可以尝试使用这个方法,主要使用这一招,上面两种看看寄就行</span><br>session.invalidate();<br></code></pre></td></tr></table></figure></li><li><p>服务器关闭或者应用被卸载或者浏览器关闭。</p></li></ul><h3 id="Session-与-Cookie-对比"><a href="#Session-与-Cookie-对比" class="headerlink" title="Session 与 Cookie 对比"></a>Session 与 Cookie 对比</h3><p><strong>Session 和 Cookie 都属于会话技术，都能帮助服务器保存和跟踪用户状态，但两者也存在差异，如下表。</strong></p><table><thead><tr><th>不同点</th><th>Cookie</th><th>Session</th></tr></thead><tbody><tr><td>存储位置不同</td><td>Cookie 将数据存放在客户端浏览器内存中或硬盘上。</td><td>Session 将数据存储在服务器端。</td></tr><tr><td>大小和数量限制不同</td><td>浏览器对 Cookie 的大小和数量有限制。</td><td>Session 的大小和数量一般不受限制。</td></tr><tr><td>存放数据类型不同</td><td>Cookie 中保存的是字符串。</td><td>Session 中保存的是对象。</td></tr><tr><td>安全性不同</td><td>Cookie 明文传递，安全性低，他人可以分析存放在本地的 Cookie 并进行 Cookie 欺骗。</td><td>Session 存在服务器端，安全性较高。</td></tr><tr><td>对服务器造成的压力不同</td><td>Cookie 保存在客户端，不占用服务器资源。</td><td>Session 保存在服务端，每一个用户独占一个 Session。若并发访问的用户十分多，就会占用大量服务端资源。</td></tr><tr><td>跨域支持上不同</td><td>Cookie 支持跨域名访问。</td><td>Session 不支持跨域名访问。</td></tr></tbody></table><h2 id="ServletContext-也称作application应用对象"><a href="#ServletContext-也称作application应用对象" class="headerlink" title="ServletContext(也称作application应用对象)"></a>ServletContext(也称作application应用对象)</h2><h3 id="获取ServletContext对象"><a href="#获取ServletContext对象" class="headerlink" title="获取ServletContext对象"></a>获取ServletContext对象</h3><p>获取ServletContext对象的途径有很多。比如：</p><h4 id="1-通过request对象获取"><a href="#1-通过request对象获取" class="headerlink" title="1.通过request对象获取"></a>1.通过request对象获取</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">ServletContext servletContext request.getservletContext();<br></code></pre></td></tr></table></figure><h4 id="2-通过session对象获取"><a href="#2-通过session对象获取" class="headerlink" title="2.通过session对象获取"></a>2.通过session对象获取</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ServletContext</span> <span class="hljs-variable">servletContext</span> <span class="hljs-operator">=</span> request.getSession().getServletContext();<br></code></pre></td></tr></table></figure><h4 id="3-通过servletConfig对象获取，在Servlet标准中提供了ServletConfig方法"><a href="#3-通过servletConfig对象获取，在Servlet标准中提供了ServletConfig方法" class="headerlink" title="3.通过servletConfig对象获取，在Servlet标准中提供了ServletConfig方法"></a>3.通过servletConfig对象获取，在Servlet标准中提供了ServletConfig方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ServletConfig</span> <span class="hljs-variable">servletConfig</span> <span class="hljs-operator">=</span> getServletConfig();<br><span class="hljs-type">ServletContext</span> <span class="hljs-variable">servletContext</span> <span class="hljs-operator">=</span> servletConfig.getServletContext()<br></code></pre></td></tr></table></figure><h4 id="4-直接获取，Servlet类中提供了直接获取ServletContext对象的方法"><a href="#4-直接获取，Servlet类中提供了直接获取ServletContext对象的方法" class="headerlink" title="4.直接获取，Servlet类中提供了直接获取ServletContext对象的方法"></a>4.直接获取，Servlet类中提供了直接获取ServletContext对象的方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ServletContext</span> <span class="hljs-variable">servletContext</span> <span class="hljs-operator">=</span> getServletContext();<br></code></pre></td></tr></table></figure><h3 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 获取项目存放的真实路径</span><br><span class="hljs-type">String</span> <span class="hljs-variable">realPath</span> <span class="hljs-operator">=</span> request.getServletContext().getRealPath(<span class="hljs-string">&quot;/&quot;</span>);<br><span class="hljs-comment">// 获取当前服务器的版本信息</span><br><span class="hljs-type">String</span> <span class="hljs-variable">serverInfo</span> <span class="hljs-operator">=</span> request.getServletContext().getServerInfo();<br></code></pre></td></tr></table></figure><h3 id="ServletContext域对象"><a href="#ServletContext域对象" class="headerlink" title="ServletContext域对象"></a>ServletContext域对象</h3><p>ServletContext 也可当做域对象来使用，通过向 ServletContext 中存取数据，可以使得整个应用程序 共享某些数据。当<strong>然不建议存放过多数据，因为 ServletContext 中的数据一旦存储进去没有手动移除将 会一直保存</strong>。</p><table><thead><tr><th>返回值类型</th><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>void</td><td>setAttribute(String name, Object object)</td><td>把一个 Java 对象与一个属性名绑定，并将它作为一个属性存放到 ServletContext 中。 参数 name 为属性名，参数 object 为属性值。</td></tr><tr><td>void</td><td>removeAttribute(String name)</td><td>从 ServletContext 中移除属性名为 name 的属性。</td></tr><tr><td>Object</td><td>getAttribute(String name)</td><td>根据指定的属性名 name，返回 ServletContext 中对应的属性值。</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 获取ServletContext对象</span><br><span class="hljs-type">ServletContext</span> <span class="hljs-variable">servletContext</span> <span class="hljs-operator">=</span> request.getServletContext();<br><span class="hljs-comment">// 设置域对象</span><br>servletContext.setAttribute(<span class="hljs-string">&quot;name&quot;</span>,<span class="hljs-string">&quot;zhangsan&quot;</span>);<br><span class="hljs-comment">// 获取域对象</span><br><span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> (String) servletContext.getAttribute(<span class="hljs-string">&quot;name&quot;</span>);<br><span class="hljs-comment">// 移除域对象</span><br>servletContext.removeAttribute(<span class="hljs-string">&quot;name&quot;</span>)<br></code></pre></td></tr></table></figure><h3 id="ServletContext-属性与上下文初始化参数对比"><a href="#ServletContext-属性与上下文初始化参数对比" class="headerlink" title="ServletContext 属性与上下文初始化参数对比"></a>ServletContext 属性与上下文初始化参数对比</h3><p>虽然 ServletContext 的属性与上下文初始化参数都是存放在 ServletContext 对象中，但它们是不同的。</p><table><thead><tr><th>不同点</th><th>ServletContext 的属性</th><th>上下文初始化参数</th></tr></thead><tbody><tr><td>创建方式</td><td>ServletContext 的属性通过调用 ServletContext 接口的 setAttribute() 方法创建</td><td>上下文初始化参数通过 web.xml 使用 <context-param> 元素配置</td></tr><tr><td>可进行的操作</td><td>ServletContext 的属性可以通过 ServletContext 接口的方法进行读取、新增、修改、移除等操作</td><td>上下文初始化参数在容器启动后只能被读取，不能进行新增、修改和移除操作</td></tr><tr><td>生命周期</td><td>ServletContext 中属性的生命周期从创建开始，到该属性被移除（remove）或者容器关闭结束</td><td>上下文初始化参数的生命周期，从容器启动开始，到 Web 应用被卸载或容器关闭结束</td></tr><tr><td>作用</td><td>使用 ServletContext 中的属性可以实现 Servlet 之间的数据通讯</td><td>使用上下文初始化参数无法实现数据通讯</td></tr></tbody></table><h3 id="Servlet-的三大域对象对比"><a href="#Servlet-的三大域对象对比" class="headerlink" title="Servlet 的三大域对象对比"></a>Servlet 的三大域对象对比</h3><h4 id="1-request域对象"><a href="#1-request域对象" class="headerlink" title="1.request域对象"></a>1.request域对象</h4><p>在一次请求中有效。<strong>请求转发有效，重定向失效</strong>。</p><h4 id="2-session-域对象"><a href="#2-session-域对象" class="headerlink" title="2.session:域对象"></a>2.session:域对象</h4><p>在一次会话中有效。<strong>请求转发和重定向都有效，session销毁后失效</strong>。</p><h4 id="3-servletContext域对象"><a href="#3-servletContext域对象" class="headerlink" title="3.servletContext域对象"></a>3.servletContext域对象</h4><p>在整个应用程序中有效。<strong>服务器关闭后失效。</strong></p><p>Session 、request 以及 ServletContext 合称为 Servlet 的三大域对象，它们都能保存和传递数据，但是三者也存在许多差异，如下表。</p><table><thead><tr><th>不同</th><th align="center">request</th><th align="center">Session</th><th align="center">ServletContext</th></tr></thead><tbody><tr><td>类型</td><td align="center">javax.servlet.http.HttpServletRequest</td><td align="center">javax.servlet.http.HttpSession</td><td align="center">javax.servlet.ServletContext</td></tr><tr><td>创建</td><td align="center">客户端向容器发送请求时创建。</td><td align="center">容器第一次调用 getSession() 方法时创建。</td><td align="center">Servlet 容器启动时创建。</td></tr><tr><td>销毁</td><td align="center">容器对这次请求做出响应后销毁。</td><td align="center">Session 销毁的时机： 关闭服务器或应用被卸载。Session 过期，默认为 30 分钟。手动调用 session.invalidate() 方法进行销毁。</td><td align="center">容器关闭或者 Web 应用被移除时销毁。</td></tr><tr><td>有效范围</td><td align="center">只对当前请求涉及的 Servlet 有效。</td><td align="center">Session 对本次会话期间的所有 Servlet 都有效。</td><td align="center">对整个 Web 应用内的所有 Servlet 有效。</td></tr><tr><td>数量</td><td align="center">Web 应用中的所有 Servlet 实例都可以有多个 request 对象。</td><td align="center">Web 应用中可以有多个 Session，多个 Servet 实例可以共享同一 Session 对象。</td><td align="center">在整个 Web 应用中只有一个 Context 对象。</td></tr><tr><td>数据共享</td><td align="center">每一次请求都是一个新的 request 对象。 通过和请求转发的配合使用可以实现一次请求中 Web 组件之间共享的数据。</td><td align="center">每一次会话都是一个新的 Session 对象。 通过 Session 域对象可以实现一次会话中的多个请求之间共享数据。</td><td align="center">在一个应用中有且只有一个 Context 对象，作用于整个 Web 应用，可以实现多次会话之间的数据共享。</td></tr></tbody></table><p>在能够满足自己使用需求的基础上,建议使用较小的域对象,例如我们今后会经常使用request域对象,而类似ServletContext域对象应用于整个服务器,正常不要使用.</p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>Servlet</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Servlet</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>每日一烤:简述JAVA的List与HashMap</title>
    <link href="/2022/08/01/%E7%AE%80%E8%BF%B0JAVA%E7%9A%84List%E4%B8%8EHashMap/"/>
    <url>/2022/08/01/%E7%AE%80%E8%BF%B0JAVA%E7%9A%84List%E4%B8%8EHashMap/</url>
    
    <content type="html"><![CDATA[<h1 id="简述JAVA的Set"><a href="#简述JAVA的Set" class="headerlink" title="简述JAVA的Set"></a>简述JAVA的Set</h1><p>Set 即集合，该数据结构不允许元素重复且无序。JAVA对Set有三种实现方式： HashSet 通过 HashMap 实现，HashMap 的 Key 即 HashSet 存储的元素，Value系统自定义一个名为 PRESENT 的 Object 类型常量。判断元素是否相同时，先比较hashCode，相同后再利用equals比较， 查询O(1) LinkedHashSet 继承自 HashSet，通过 LinkedHashMap 实现，使用双向链表维护元素插入顺序。 TreeSet 通过 TreeMap 实现的，底层数据结构是红黑树，添加元素到集合时按照比较规则将其插入合适 的位置，保证插入后的集合仍然有序。查询O(logn)</p><h1 id="简述java的TreeMap"><a href="#简述java的TreeMap" class="headerlink" title="简述java的TreeMap"></a>简述java的TreeMap</h1><p>TreeMap是底层利用红黑树实现的Map结构，底层实现是一棵平衡的排序二叉树，由于红黑树的插入、 删除、遍历时间复杂度都为O(logN)，所以性能上低于哈希表。但是哈希表无法提供键值对的有序输 出，红黑树可以按照键的值的大小有序输出。</p><h1 id="简述JAVA的List"><a href="#简述JAVA的List" class="headerlink" title="简述JAVA的List"></a>简述JAVA的List</h1><p>List是一个有序队列，在JAVA中有两种实现方式: ArrayList 使用数组实现，是容量可变的非线程安全列表，随机访问快，集合扩容时会创建更大的数组， 把原有数组复制到新数组。 LinkedList 本质是双向链表，与 ArrayList 相比插入和删除速度更快，但随机访问元素很慢。</p><h1 id="简述JAVA的HashMap"><a href="#简述JAVA的HashMap" class="headerlink" title="简述JAVA的HashMap"></a>简述JAVA的HashMap</h1><p>JDK8 之前底层实现是数组 + 链表，JDK8 改为数组 + 链表&#x2F;红黑树。主要成员变量包括存储数据的 table 数组、元素数量 size、加载因子 loadFactor。 HashMap 中数据以键值对的形式存在，键对应的 hash 值用来计算数组下标，如果两个元素 key 的 hash 值一样，就会发生哈希冲突，被放到同一个链表上。 table 数组记录 HashMap 的数据，每个下标对应一条链表，所有哈希冲突的数据都会被存放到同一条链 表，Node&#x2F;Entry 节点包含四个成员变量：key、value、next 指针和 hash 值。在JDK8后链表超过8会转 化为红黑树。 若当前数据&#x2F;总数据容量&gt;负载因子，Hashmap将执行扩容操作。 默认初始化容量为 16，扩容容量必须是 2 的幂次方、最大容量为 1&lt;&lt; 30 、默认加载因子为 0.75。</p>]]></content>
    
    
    <categories>
      
      <category>每日一烤</category>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>每日一烤</tag>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>每日一烤:简述JAVA的Set</title>
    <link href="/2022/07/31/%E7%AE%80%E8%BF%B0Java%E7%9A%84Set/"/>
    <url>/2022/07/31/%E7%AE%80%E8%BF%B0Java%E7%9A%84Set/</url>
    
    <content type="html"><![CDATA[<h1 id="简述JAVA的Set"><a href="#简述JAVA的Set" class="headerlink" title="简述JAVA的Set"></a>简述JAVA的Set</h1><p>Set 即集合，该数据结构不允许元素重复且无序。JAVA对Set有三种实现方式： HashSet 通过 HashMap 实现，HashMap 的 Key 即 HashSet 存储的元素，Value系统自定义一个名为 PRESENT 的 Object 类型常量。判断元素是否相同时，先比较hashCode，相同后再利用equals比较， 查询O(1) LinkedHashSet 继承自 HashSet，通过 LinkedHashMap 实现，使用双向链表维护元素插入顺序。 TreeSet 通过 TreeMap 实现的，底层数据结构是红黑树，添加元素到集合时按照比较规则将其插入合适 的位置，保证插入后的集合仍然有序。查询O(logn)</p><h1 id="简述java的TreeMap"><a href="#简述java的TreeMap" class="headerlink" title="简述java的TreeMap"></a>简述java的TreeMap</h1><p>TreeMap是底层利用红黑树实现的Map结构，底层实现是一棵平衡的排序二叉树，由于红黑树的插入、 删除、遍历时间复杂度都为O(logN)，所以性能上低于哈希表。但是哈希表无法提供键值对的有序输 出，红黑树可以按照键的值的大小有序输出。</p>]]></content>
    
    
    <categories>
      
      <category>每日一烤</category>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>每日一烤</tag>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指 Offer 22. 链表中倒数第k个节点</title>
    <link href="/2022/07/30/%E5%89%91%E6%8C%87Offer22%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%80%92%E6%95%B0%E7%AC%ACk%E4%B8%AA%E8%8A%82%E7%82%B9/"/>
    <url>/2022/07/30/%E5%89%91%E6%8C%87Offer22%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%80%92%E6%95%B0%E7%AC%ACk%E4%B8%AA%E8%8A%82%E7%82%B9/</url>
    
    <content type="html"><![CDATA[<h1 id="剑指-Offer-22-链表中倒数第k个节点"><a href="#剑指-Offer-22-链表中倒数第k个节点" class="headerlink" title="剑指 Offer 22. 链表中倒数第k个节点"></a><a href="https://leetcode.cn/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/">剑指 Offer 22. 链表中倒数第k个节点</a></h1><p>输入一个链表，输出该链表中倒数第k个节点。为了符合大多数人的习惯，本题从1开始计数，即链表的尾节点是倒数第1个节点。</p><p>例如，一个链表有 6 个节点，从头节点开始，它们的值依次是 1、2、3、4、5、6。这个链表的倒数第 3 个节点是值为 4 的节点。</p><p><strong>示例：</strong></p><figure class="highlight clean"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><pre><code class="hljs clean">给定一个链表: <span class="hljs-number">1</span>-&gt;<span class="hljs-number">2</span>-&gt;<span class="hljs-number">3</span>-&gt;<span class="hljs-number">4</span>-&gt;<span class="hljs-number">5</span>, 和 k = <span class="hljs-number">2.</span><br><br>返回链表 <span class="hljs-number">4</span>-&gt;<span class="hljs-number">5.</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">getKthFromEnd</span><span class="hljs-params">(ListNode head, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">former</span> <span class="hljs-operator">=</span> head, latter = head;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; k; i++)<br>            former = former.next;<br>        <span class="hljs-keyword">while</span>(former != <span class="hljs-literal">null</span>) &#123;<br>            former = former.next;<br>            latter = latter.next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> latter;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/solution/mian-shi-ti-22-lian-biao-zhong-dao-shu-di-kge-j-11/">参考链接</a></p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>每日一练</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>每日一练</tag>
      
      <tag>剑指offer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>每日一烤:ArrayList、Vector和LinkedList有什么共同点与区别</title>
    <link href="/2022/07/30/ArrayList%E4%B8%8EVector%E5%92%8CLinkedList%E6%9C%89%E4%BB%80%E4%B9%88%E5%85%B1%E5%90%8C%E7%82%B9%E4%B8%8E%E5%8C%BA%E5%88%AB/"/>
    <url>/2022/07/30/ArrayList%E4%B8%8EVector%E5%92%8CLinkedList%E6%9C%89%E4%BB%80%E4%B9%88%E5%85%B1%E5%90%8C%E7%82%B9%E4%B8%8E%E5%8C%BA%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<h1 id="ArrayList、Vector和LinkedList有什么共同点与区别？"><a href="#ArrayList、Vector和LinkedList有什么共同点与区别？" class="headerlink" title="ArrayList、Vector和LinkedList有什么共同点与区别？"></a>ArrayList、Vector和LinkedList有什么共同点与区别？</h1><ol><li>ArrayList、Vector和LinkedList都是可伸缩的数组，即可以动态改变长度的数组。 </li><li>ArrayList和Vector都是基于存储元素的Object[] array来实现的，它们会在内存中开辟一块连续的空 间来存储，支持下标、索引访问。但在涉及插入元素时可能需要移动容器中的元素，插入效率较 低。当存储元素超过容器的初始化容量大小，ArrayList与Vector均会进行扩容。 </li><li>Vector是线程安全的，其大部分方法是直接或间接同步的。ArrayList不是线程安全的，其方法不具 有同步性质。LinkedList也不是线程安全的。</li><li>LinkedList采用双向列表实现，对数据索引需要从头开始遍历，因此随机访问效率较低，但在插入 元素的时候不需要对数据进行移动，插入效率较高。</li></ol>]]></content>
    
    
    <categories>
      
      <category>每日一烤</category>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>每日一烤</tag>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>每日一练:剑指 Offer 46. 把数字翻译成字符串</title>
    <link href="/2022/07/29/%E5%89%91%E6%8C%87%20Offer%2046.%20%E6%8A%8A%E6%95%B0%E5%AD%97%E7%BF%BB%E8%AF%91%E6%88%90%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <url>/2022/07/29/%E5%89%91%E6%8C%87%20Offer%2046.%20%E6%8A%8A%E6%95%B0%E5%AD%97%E7%BF%BB%E8%AF%91%E6%88%90%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    
    <content type="html"><![CDATA[<h1 id="剑指-Offer-46-把数字翻译成字符串"><a href="#剑指-Offer-46-把数字翻译成字符串" class="headerlink" title="剑指 Offer 46. 把数字翻译成字符串"></a><a href="https://leetcode.cn/problems/ba-shu-zi-fan-yi-cheng-zi-fu-chuan-lcof/">剑指 Offer 46. 把数字翻译成字符串</a></h1><p>给定一个数字，我们按照如下规则把它翻译为字符串：0 翻译成 “a” ，1 翻译成 “b”，……，11 翻译成 “l”，……，25 翻译成 “z”。一个数字可能有多个翻译。请编程实现一个函数，用来计算一个数字有多少种不同的翻译方法。</p><p>示例 1:</p><figure class="highlight 1c"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><pre><code class="hljs 1c">输入: <span class="hljs-number">12258</span><br>输出: <span class="hljs-number">5</span><br>解释: <span class="hljs-number">12258</span>有<span class="hljs-number">5</span>种不同的翻译，分别是<span class="hljs-string">&quot;bccfi&quot;</span>, <span class="hljs-string">&quot;bwfi&quot;</span>, <span class="hljs-string">&quot;bczi&quot;</span>, <span class="hljs-string">&quot;mcfi&quot;</span>和<span class="hljs-string">&quot;mzi&quot;</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">translateNum</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> String.valueOf(num);<br>        <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[s.length()+<span class="hljs-number">1</span>];<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        dp[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>; i &lt;= s.length(); i ++)&#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> s.substring(i-<span class="hljs-number">2</span>, i);<br>            <span class="hljs-keyword">if</span>(temp.compareTo(<span class="hljs-string">&quot;10&quot;</span>) &gt;= <span class="hljs-number">0</span> &amp;&amp; temp.compareTo(<span class="hljs-string">&quot;25&quot;</span>) &lt;= <span class="hljs-number">0</span>)<br>                dp[i] = dp[i-<span class="hljs-number">1</span>] + dp[i-<span class="hljs-number">2</span>];<br>            <span class="hljs-keyword">else</span><br>                dp[i] = dp[i-<span class="hljs-number">1</span>];<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[s.length()];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>从下周开始,每日一练改成每周一练</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>每日一练</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>每日一练</tag>
      
      <tag>剑指offer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>每日一烤:简述JAVA的List</title>
    <link href="/2022/07/29/%E7%AE%80%E8%BF%B0JAVA%E7%9A%84List/"/>
    <url>/2022/07/29/%E7%AE%80%E8%BF%B0JAVA%E7%9A%84List/</url>
    
    <content type="html"><![CDATA[<h1 id="简述JAVA的List"><a href="#简述JAVA的List" class="headerlink" title="简述JAVA的List"></a>简述JAVA的List</h1><p>List是一个有序队列，在JAVA中有两种实现方式:</p><p> ArrayList 使用数组实现，是容量可变的非线程安全列表，随机访问快，集合扩容时会创建更大的数组， 把原有数组复制到新数组。 </p><p>LinkedList 本质是双向链表，与 ArrayList 相比插入和删除速度更快，但随机访问元素很慢。</p><h1 id="Java中线程安全的基本数据结构有哪些"><a href="#Java中线程安全的基本数据结构有哪些" class="headerlink" title="Java中线程安全的基本数据结构有哪些"></a>Java中线程安全的基本数据结构有哪些</h1><p>HashTable: 哈希表的线程安全版，效率低 </p><p>ConcurrentHashMap：哈希表的线程安全版，效率高，用于替代HashTable </p><p>Vector：线程安全版Arraylist </p><p>Stack：线程安全版栈 BlockingQueue及其子类：线程安全版队列</p><h1 id="为何HashMap线程不安全"><a href="#为何HashMap线程不安全" class="headerlink" title="为何HashMap线程不安全"></a>为何HashMap线程不安全</h1><p>在JDK1.7中，HashMap采用头插法插入元素，因此并发情况下会导致环形链表，产生死循环。 </p><p>虽然JDK1.8采用了尾插法解决了这个问题，但是并发下的put操作也会使前一个key被后一个key覆盖。 由于HashMap有扩容机制存在，也存在A线程进行扩容后，B线程执行get方法出现失误的情况。</p>]]></content>
    
    
    <categories>
      
      <category>每日一烤</category>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>每日一烤</tag>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指 Offer 42. 连续子数组的最大和</title>
    <link href="/2022/07/28/%E5%89%91%E6%8C%87Offer%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E9%97%AE%E9%A2%98/"/>
    <url>/2022/07/28/%E5%89%91%E6%8C%87Offer%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="剑指-Offer-42-连续子数组的最大和"><a href="#剑指-Offer-42-连续子数组的最大和" class="headerlink" title="剑指 Offer 42. 连续子数组的最大和"></a><a href="https://leetcode.cn/problems/lian-xu-zi-shu-zu-de-zui-da-he-lcof/">剑指 Offer 42. 连续子数组的最大和</a></h1><p>输入一个整型数组，数组中的一个或连续多个整数组成一个子数组。求所有子数组的和的最大值。</p><p>要求时间复杂度为O(n)。</p><p><strong>示例1:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><pre><code class="hljs java">输入: nums = [-<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,-<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,-<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,-<span class="hljs-number">5</span>,<span class="hljs-number">4</span>]<br>输出: <span class="hljs-number">6</span><br>解释: 连续子数组 [<span class="hljs-number">4</span>,-<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>] 的和最大，为 <span class="hljs-number">6</span>。<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxSubArray</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; nums.length; i++) &#123;<br>            nums[i] += Math.max(nums[i - <span class="hljs-number">1</span>], <span class="hljs-number">0</span>);<br>            res = Math.max(res, nums[i]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a>解题思路：</h4><p>动态规划是本题的最优解法，以下按照标准流程解题。</p><p>动态规划解析：<br>状态定义： 设动态规划列表 dp ，dp[i] 代表以元素 nums[i] 为结尾的连续子数组最大和。</p><p>为何定义最大和 dp[i] 中必须包含元素 nums[i] ：保证 dp[i] 递推到 dp[i+1] 的正确性；如果不包含 nums[i] ，递推时则不满足题目的 连续子数组 要求。<br>转移方程： 若 dp[i−1]≤0 ，说明 dp[i−1] 对 dp[i]产生负贡献，即 dp[i-1] + nums[i]还不如nums[i] 本身大。</p><p>当 dp[i - 1] &gt; 0 时：执行 ]dp[i]&#x3D;dp[i−1]+nums[i] ；<br>当 dp[i−1]≤0 时：执行dp[i]&#x3D;nums[i] ；<br>初始状态： dp[0] &#x3D; nums[0]，即以 nums[0] 结尾的连续子数组最大和为 nums[0] 。</p><p>返回值： 返回 dp 列表中的最大值，代表全局最大值。</p><p><a href="https://leetcode.cn/problems/lian-xu-zi-shu-zu-de-zui-da-he-lcof/solution/mian-shi-ti-42-lian-xu-zi-shu-zu-de-zui-da-he-do-2/">参考链接</a></p><h1 id="剑指-Offer-47-礼物的最大价值"><a href="#剑指-Offer-47-礼物的最大价值" class="headerlink" title="剑指 Offer 47. 礼物的最大价值"></a><a href="https://leetcode.cn/problems/li-wu-de-zui-da-jie-zhi-lcof/">剑指 Offer 47. 礼物的最大价值</a></h1><p>在一个 m*n 的棋盘的每一格都放有一个礼物，每个礼物都有一定的价值（价值大于 0）。你可以从棋盘的左上角开始拿格子里的礼物，并每次向右或者向下移动一格、直到到达棋盘的右下角。给定一个棋盘及其上面的礼物的价值，请计算你最多能拿到多少价值的礼物？</p><p>示例 1:</p><p>输入: </p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs inform7"><span class="hljs-comment">[</span><br><span class="hljs-comment">  <span class="hljs-comment">[1,3,1]</span>,</span><br><span class="hljs-comment">  <span class="hljs-comment">[1,5,1]</span>,</span><br><span class="hljs-comment">  <span class="hljs-comment">[4,2,1]</span></span><br><span class="hljs-comment">]</span><br></code></pre></td></tr></table></figure><p>输出: 12<br>解释: 路径 1→3→5→2→1 可以拿到最多价值的礼物</p><p>输出: 12<br>解释: 路径 1→3→5→2→1 可以拿到最多价值的礼物</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxValue</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] grid)</span> &#123;<br>       <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> grid.length, n = grid[<span class="hljs-number">0</span>].length;<br><br>       <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i&lt;m;i++)<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;j&lt;n;j++)&#123;<br>                <span class="hljs-keyword">if</span>(i ==<span class="hljs-number">0</span>&amp;&amp;j==<span class="hljs-number">0</span>) <span class="hljs-keyword">continue</span>;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(i ==<span class="hljs-number">0</span>&amp;&amp;j&gt;<span class="hljs-number">0</span>) grid[i][j] += grid[i][j-<span class="hljs-number">1</span>];<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(i&gt;<span class="hljs-number">0</span>&amp;&amp;j ==<span class="hljs-number">0</span>) grid[i][j] += grid[i-<span class="hljs-number">1</span>][j];<br>                <span class="hljs-keyword">else</span> grid[i][j] += Math.max(grid[i-<span class="hljs-number">1</span>][j],grid[i][j-<span class="hljs-number">1</span>]);   <br>            &#125;    <br>    <span class="hljs-keyword">return</span> grid[m-<span class="hljs-number">1</span>][n-<span class="hljs-number">1</span>];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="解题思路：-1"><a href="#解题思路：-1" class="headerlink" title="解题思路："></a>解题思路：</h4><p>题目说明：从棋盘的左上角开始拿格子里的礼物，并每次 向右 或者 向下 移动一格、直到到达棋盘的右下角。<br>根据题目说明，易得某单元格只可能从上边单元格或左边单元格到达。</p><p>设 f(i, j) 为从棋盘左上角走至单元格 (i ,j)的礼物最大累计价值，易得到以下递推关系：f(i,j) 等于f(i,j−1) 和 f(i-1,j)中的较大值加上当前单元格礼物价值 grid(i,j)</p><p>f(i,j)&#x3D;max[f(i,j−1),f(i−1,j)]+grid(i,j)</p><p>因此，可用动态规划解决此问题，以上公式便为转移方程。<br><a href="https://leetcode.cn/problems/li-wu-de-zui-da-jie-zhi-lcof/solution/mian-shi-ti-47-li-wu-de-zui-da-jie-zhi-dong-tai-gu/">参考链接</a></p><h1 id="剑指-Offer-63-股票的最大利润"><a href="#剑指-Offer-63-股票的最大利润" class="headerlink" title="剑指 Offer 63. 股票的最大利润"></a><a href="https://leetcode.cn/problems/gu-piao-de-zui-da-li-run-lcof/">剑指 Offer 63. 股票的最大利润</a></h1><p>昨天的题目,和今天的属于一类,所以复制过来了</p><p>假设把某股票的价格按照时间先后顺序存储在数组中，请问买卖该股票一次可能获得的最大利润是多少？</p><p> 示例 1:</p><p>输入: [7,1,5,3,6,4]<br>输出: 5<br>解释: 在第 2 天（股票价格 &#x3D; 1）的时候买入，在第 5 天（股票价格 &#x3D; 6）的时候卖出，最大利润 &#x3D; 6-1 &#x3D; 5 。<br>     注意利润不能是 7-1 &#x3D; 6, 因为卖出价格需要大于买入价格。</p><p>示例 2:</p><p>输入: [7,6,4,3,1]<br>输出: 0<br>解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxProfit</span><span class="hljs-params">(<span class="hljs-type">int</span>[] prices)</span> &#123;<br>        <span class="hljs-keyword">if</span>(prices.length == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, min = prices[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; prices.length; i ++)&#123;<br>            min = Math.min(min, prices[i-<span class="hljs-number">1</span>]);<br>            res = Math.max(res, prices[i] - min);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="解题思路：-2"><a href="#解题思路：-2" class="headerlink" title="解题思路："></a>解题思路：</h4><p>设共有 n 天，第 a 天买，第 b 天卖，则需保证 a&lt;b ；可推出交易方案数共有：<br>(n−1)+(n−2)+⋯+2+1&#x3D;n(n−1)&#x2F;2</p><p>因此，暴力法的时间复杂度为 O(n^2)。考虑使用动态规划降低时间复杂度，以下按照流程解题。</p><h4 id="动态规划解析："><a href="#动态规划解析：" class="headerlink" title="动态规划解析："></a>动态规划解析：</h4><p>状态定义： 设动态规划列表 dp ，dp[i] 代表以prices[i] 为结尾的子数组的最大利润（以下简称为 前 i日的最大利润 ）。<br>转移方程： 由于题目限定 “买卖该股票一次” ，因此前 i 日最大利润 dp[i] 等于前 i−1 日最大利润 dp[i−1] 和第 i 日卖出的最大利润中的最大值。</p><p>前i日最大利润&#x3D;max(前(i−1)日最大利润,第i日价格−前i日最低价格)</p><p>dp[i]&#x3D;max(dp[i−1],prices[i]−min(prices[0:i]))</p><p>初始状态： dp[0]&#x3D;0 ，即首日利润为 0 ；<br>返回值： dp[n−1] ，其中 n 为 dp 列表长度。</p><p><a href="https://leetcode.cn/problems/gu-piao-de-zui-da-li-run-lcof/solution/mian-shi-ti-63-gu-piao-de-zui-da-li-run-dong-tai-2/">参考链接</a></p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>每日一练</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>每日一练</tag>
      
      <tag>剑指offer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>每日一烤:HashMap和Hashtable的区别</title>
    <link href="/2022/07/28/HashMap%E5%92%8CHashtable%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <url>/2022/07/28/HashMap%E5%92%8CHashtable%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<h1 id="HashMap和Hashtable有什么区别？"><a href="#HashMap和Hashtable有什么区别？" class="headerlink" title="HashMap和Hashtable有什么区别？"></a>HashMap和Hashtable有什么区别？</h1><p>1.HashMap是Hashtable的轻量级实现，HashMap允许key和value为null，但最多允许一条记录的key 为null.而HashTable不允许。<br>2.HashTable中的方法是线程安全的，而HashMap不是。在多线程访问HashMap需要提供额外的同步 机制。<br>3.Hashtable使用Enumeration进行遍历，HashMap使用Iterator进行遍历。</p><h1 id="为何HashMap线程不安全"><a href="#为何HashMap线程不安全" class="headerlink" title="为何HashMap线程不安全"></a>为何HashMap线程不安全</h1><p>在JDK1.7中，HashMap采用头插法插入元素，因此并发情况下会导致环形链表，产生死循环。 </p><p>虽然JDK1.8采用了尾插法解决了这个问题，但是并发下的put操作也会使前一个key被后一个key覆盖。 由于HashMap有扩容机制存在，也存在A线程进行扩容后，B线程执行get方法出现失误的情况。</p>]]></content>
    
    
    <categories>
      
      <category>每日一烤</category>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>每日一烤</tag>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>每日一烤:ArrayList、Vector和LinkedList有什么共同点与区别？</title>
    <link href="/2022/07/27/ArrayList%E5%92%8CVector%E5%92%8CLinkedList%E6%9C%89%E4%BB%80%E4%B9%88%E5%85%B1%E5%90%8C%E7%82%B9%E4%B8%8E%E5%8C%BA%E5%88%AB/"/>
    <url>/2022/07/27/ArrayList%E5%92%8CVector%E5%92%8CLinkedList%E6%9C%89%E4%BB%80%E4%B9%88%E5%85%B1%E5%90%8C%E7%82%B9%E4%B8%8E%E5%8C%BA%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<h1 id="ArrayList、Vector和LinkedList有什么共同点与区别？"><a href="#ArrayList、Vector和LinkedList有什么共同点与区别？" class="headerlink" title="ArrayList、Vector和LinkedList有什么共同点与区别？"></a>ArrayList、Vector和LinkedList有什么共同点与区别？</h1><ol><li>ArrayList、Vector和LinkedList都是可伸缩的数组，即可以动态改变长度的数组。 </li><li>ArrayList和Vector都是基于存储元素的Object[] array来实现的，它们会在内存中开辟一块连续的空间来存储，支持下标、索引访问。但在涉及插入元素时可能需要移动容器中的元素，插入效率较 低。当存储元素超过容器的初始化容量大小，ArrayList与Vector均会进行扩容。 </li><li>Vector是线程安全的，其大部分方法是直接或间接同步的。ArrayList不是线程安全的，其方法不具 有同步性质。LinkedList也不是线程安全的。 </li><li>LinkedList采用双向列表实现，对数据索引需要从头开始遍历，因此随机访问效率较低，但在插入 元素的时候不需要对数据进行移动，插入效率较高。</li></ol>]]></content>
    
    
    <categories>
      
      <category>每日一烤</category>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>每日一烤</tag>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指 Offer 10- I. 斐波那契数列</title>
    <link href="/2022/07/27/%E5%89%91%E6%8C%87Offer10-I.%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97/"/>
    <url>/2022/07/27/%E5%89%91%E6%8C%87Offer10-I.%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97/</url>
    
    <content type="html"><![CDATA[<h1 id="剑指-Offer-10-I-斐波那契数列"><a href="#剑指-Offer-10-I-斐波那契数列" class="headerlink" title="剑指 Offer 10- I. 斐波那契数列"></a><a href="https://leetcode.cn/problems/fei-bo-na-qi-shu-lie-lcof/">剑指 Offer 10- I. 斐波那契数列</a></h1><p>写一个函数，输入 <code>n</code> ，求斐波那契（Fibonacci）数列的第 <code>n</code> 项（即 <code>F(N)</code>）。斐波那契数列的定义如下：</p><figure class="highlight stylus"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">F</span><span class="hljs-params">(<span class="hljs-number">0</span>)</span></span> = <span class="hljs-number">0</span>,   <span class="hljs-built_in">F</span>(<span class="hljs-number">1</span>) = <span class="hljs-number">1</span><br><span class="hljs-function"><span class="hljs-title">F</span><span class="hljs-params">(N)</span></span> = <span class="hljs-built_in">F</span>(N - <span class="hljs-number">1</span>) + <span class="hljs-built_in">F</span>(N - <span class="hljs-number">2</span>), 其中 N &gt; <span class="hljs-number">1</span>.<br></code></pre></td></tr></table></figure><p><strong>示例 1：</strong></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">输入：n <span class="hljs-operator">=</span> <span class="hljs-number">2</span><br>输出：<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">输入：n <span class="hljs-operator">=</span> <span class="hljs-number">5</span><br>输出：<span class="hljs-number">5</span><br></code></pre></td></tr></table></figure><h4 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a>解题思路：</h4><p>斐波那契数列的定义是 f(n + 1) &#x3D; f(n) + f(n - 1) ，生成第 n 项的做法有以下几种：</p><p>递归法：<br>原理： 把 f(n) 问题的计算拆分成 f(n-1) 和f(n−2) 两个子问题的计算，并递归，以f(0) 和 f(1)为终止条件。<br>缺点： 大量重复的递归计算，例如f(n) 和f(n−1) 两者向下递归需要 各自计算 f(n - 2)的值。<br>记忆化递归法：<br>原理： 在递归法的基础上，新建一个长度为 n 的数组，用于在递归时存储 f(0) 至 f(n) 的数字值，重复遇到某数字则直接从数组取用，避免了重复的递归计算。<br>缺点： 记忆化存储需要使用 O(N) 的额外空间。<br>动态规划：<br>原理： 以斐波那契数列性质 f(n + 1) &#x3D; f(n) + f(n - 1)为转移方程。<br>从计算效率、空间复杂度上看，动态规划是本题的最佳解法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">fib</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[Math.max(n + <span class="hljs-number">1</span>, <span class="hljs-number">3</span>)];<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>        dp[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>; i &lt;= n; i++) &#123;<br>            dp[i] = (dp[i-<span class="hljs-number">1</span>] + dp[i-<span class="hljs-number">2</span>])%<span class="hljs-number">1000000007</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/fei-bo-na-qi-shu-lie-lcof/solution/mian-shi-ti-10-i-fei-bo-na-qi-shu-lie-dong-tai-gui/">参考链接</a></p><h1 id="剑指-Offer-10-II-青蛙跳台阶问题"><a href="#剑指-Offer-10-II-青蛙跳台阶问题" class="headerlink" title="剑指 Offer 10- II. 青蛙跳台阶问题"></a><a href="https://leetcode.cn/problems/qing-wa-tiao-tai-jie-wen-ti-lcof/">剑指 Offer 10- II. 青蛙跳台阶问题</a></h1><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级台阶。求该青蛙跳上一个 n 级的台阶总共有多少种跳法。</p><p>答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。</p><p>示例 1：输入：n &#x3D; 2<br>输出：2<br>示例 2：</p><p>输入：n &#x3D; 7<br>输出：21<br>示例 3：</p><p>输入：n &#x3D; 0<br>输出：1</p><p>代码几乎和上一题一样</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">numWays</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[Math.max(n + <span class="hljs-number">1</span>, <span class="hljs-number">3</span>)];<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        dp[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>        dp[<span class="hljs-number">2</span>] = <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">3</span>; i &lt;= n; i++) &#123;<br>            dp[i] = (dp[i-<span class="hljs-number">1</span>] + dp[i-<span class="hljs-number">2</span>])%<span class="hljs-number">1000000007</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="解题思路：-1"><a href="#解题思路：-1" class="headerlink" title="解题思路："></a>解题思路：</h4><p>此类求 多少种可能性 的题目一般都有 递推性质 ，即 f(n) 和 f(n−1)…f(1) 之间是有联系的。</p><p>设跳上 n级台阶有 f(n) 种跳法。在所有跳法中，青蛙的最后一步只有两种情况： 跳上 1 级或 2 级台阶。<br>当为 1 级台阶： 剩 n−1 个台阶，此情况共有 f(n−1) 种跳法；<br>当为 2 级台阶： 剩 n−2 个台阶，此情况共有 f(n−2) 种跳法。<br>f(n) 为以上两种情况之和，即 f(n)&#x3D;f(n−1)+f(n−2) ，以上递推性质为斐波那契数列。本题可转化为 求斐波那契数列第 n 项的值 ，与 面试题10- I. 斐波那契数列 等价，唯一的不同在于起始数字不同。<br>青蛙跳台阶问题： f(0)&#x3D;1 , f(1)&#x3D;1 , f(2)&#x3D;2 ；<br>斐波那契数列问题： f(0)&#x3D;0 , f(1)&#x3D;1 , f(2)&#x3D;1 。</p><h4 id="动态规划解析："><a href="#动态规划解析：" class="headerlink" title="动态规划解析："></a>动态规划解析：</h4><p>状态定义： 设 dp 为一维数组，其中 dp[i] 的值代表 斐波那契数列第 $i$ 个数字 。<br>转移方程： dp[i + 1] &#x3D; dp[i] + dp[i - 1] ，即对应数列定义 f(n + 1) &#x3D; f(n) + f(n - 1) ；<br>初始状态： dp[0] &#x3D; 1, dp[1] &#x3D; 1 ，即初始化前两个数字；<br>返回值： dp[n] ，即斐波那契数列的第 n 个数字。</p><p><a href="https://leetcode.cn/problems/qing-wa-tiao-tai-jie-wen-ti-lcof/solution/mian-shi-ti-10-ii-qing-wa-tiao-tai-jie-wen-ti-dong/">参考链接</a></p><h1 id="剑指-Offer-63-股票的最大利润"><a href="#剑指-Offer-63-股票的最大利润" class="headerlink" title="剑指 Offer 63. 股票的最大利润"></a><a href="https://leetcode.cn/problems/gu-piao-de-zui-da-li-run-lcof/">剑指 Offer 63. 股票的最大利润</a></h1><p>假设把某股票的价格按照时间先后顺序存储在数组中，请问买卖该股票一次可能获得的最大利润是多少？</p><p> 示例 1:</p><p>输入: [7,1,5,3,6,4]<br>输出: 5<br>解释: 在第 2 天（股票价格 &#x3D; 1）的时候买入，在第 5 天（股票价格 &#x3D; 6）的时候卖出，最大利润 &#x3D; 6-1 &#x3D; 5 。<br>     注意利润不能是 7-1 &#x3D; 6, 因为卖出价格需要大于买入价格。</p><p>示例 2:</p><p>输入: [7,6,4,3,1]<br>输出: 0<br>解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxProfit</span><span class="hljs-params">(<span class="hljs-type">int</span>[] prices)</span> &#123;<br>        <span class="hljs-keyword">if</span>(prices.length == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, min = prices[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; prices.length; i ++)&#123;<br>            min = Math.min(min, prices[i-<span class="hljs-number">1</span>]);<br>            res = Math.max(res, prices[i] - min);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="解题思路：-2"><a href="#解题思路：-2" class="headerlink" title="解题思路："></a>解题思路：</h4><p>设共有 n 天，第 a 天买，第 b 天卖，则需保证 a&lt;b ；可推出交易方案数共有：<br>(n−1)+(n−2)+⋯+2+1&#x3D;n(n−1)&#x2F;2</p><p>因此，暴力法的时间复杂度为 O(n^2)。考虑使用动态规划降低时间复杂度，以下按照流程解题。</p><h4 id="动态规划解析：-1"><a href="#动态规划解析：-1" class="headerlink" title="动态规划解析："></a>动态规划解析：</h4><p>状态定义： 设动态规划列表 dp ，dp[i] 代表以prices[i] 为结尾的子数组的最大利润（以下简称为 前 i日的最大利润 ）。<br>转移方程： 由于题目限定 “买卖该股票一次” ，因此前 i 日最大利润 dp[i] 等于前 i−1 日最大利润 dp[i−1] 和第 i 日卖出的最大利润中的最大值。</p><p>前i日最大利润&#x3D;max(前(i−1)日最大利润,第i日价格−前i日最低价格)</p><p>dp[i]&#x3D;max(dp[i−1],prices[i]−min(prices[0:i]))</p><p>初始状态： dp[0]&#x3D;0 ，即首日利润为 0 ；<br>返回值： dp[n−1] ，其中 n 为 dp 列表长度。</p><p><a href="https://leetcode.cn/problems/gu-piao-de-zui-da-li-run-lcof/solution/mian-shi-ti-63-gu-piao-de-zui-da-li-run-dong-tai-2/">参考链接</a></p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>每日一练</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>每日一练</tag>
      
      <tag>剑指offer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>每日一练:剑指 Offer 26. 树的子结构</title>
    <link href="/2022/07/26/%E5%89%91%E6%8C%87%20Offer%2026.%20%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <url>/2022/07/26/%E5%89%91%E6%8C%87%20Offer%2026.%20%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h1 id="剑指-Offer-26-树的子结构"><a href="#剑指-Offer-26-树的子结构" class="headerlink" title="剑指 Offer 26. 树的子结构"></a><a href="https://leetcode.cn/problems/shu-de-zi-jie-gou-lcof/">剑指 Offer 26. 树的子结构</a></h1><p>输入两棵二叉树A和B，判断B是不是A的子结构。(约定空树不是任意一个树的子结构)</p><p>B是A的子结构， 即 A中有出现和B相同的结构和节点值。</p><p>例如:<br>给定的树 A:</p><figure class="highlight livescript"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><pre><code class="hljs livescript">     <span class="hljs-number">3</span><br>   /   <span class="hljs-string">\</span><br>  <span class="hljs-number">4</span>     <span class="hljs-number">5</span><br> / <span class="hljs-string">\</span><br><span class="hljs-number">1</span>   <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p>给定的树 B：</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tap"> <span class="hljs-number"> 4 </span><br> /<br>1<br></code></pre></td></tr></table></figure><p>返回 true，因为 B 与 A 的一个子树拥有相同的结构和节点值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    参考:数据结构与算法的题解比较好懂</span><br><span class="hljs-comment">    死死记住isSubStructure()的定义:判断B是否为A的子结构</span><br><span class="hljs-comment">    */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isSubStructure</span><span class="hljs-params">(TreeNode A, TreeNode B)</span> &#123;<br>        <span class="hljs-comment">//这个函数对这棵树进行前序遍历：即处理根节点，再递归左子节点，再递归处理右子节点</span><br>        <span class="hljs-comment">//特殊情况是：当A或B是空树的时候 返回false</span><br>        <span class="hljs-comment">//用||关系可以达到 不同顺序遍历的作用</span><br>        <br>        <span class="hljs-comment">// 若A与B其中一个为空,立即返回false</span><br>        <span class="hljs-keyword">if</span>(A == <span class="hljs-literal">null</span> || B == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-comment">// B为A的子结构有3种情况,满足任意一种即可:</span><br>        <span class="hljs-comment">// 1.B的子结构起点为A的根节点,此时结果为recur(A,B)</span><br>        <span class="hljs-comment">// 2.B的子结构起点隐藏在A的左子树中,而不是直接为A的根节点,此时结果为isSubStructure(A.left, B)</span><br>        <span class="hljs-comment">// 3.B的子结构起点隐藏在A的右子树中,此时结果为isSubStructure(A.right, B)</span><br>        <span class="hljs-keyword">return</span> recur(A, B) || isSubStructure(A.left, B) || isSubStructure(A.right, B);<br>    &#125;<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    判断B是否为A的子结构,其中B子结构的起点为A的根节点</span><br><span class="hljs-comment">    */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">recur</span><span class="hljs-params">(TreeNode A, TreeNode B)</span> &#123;<br>        <span class="hljs-comment">// 若B走完了,说明查找完毕,B为A的子结构</span><br>        <span class="hljs-keyword">if</span>(B == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-comment">// 若B不为空并且A为空或者A与B的值不相等,直接可以判断B不是A的子结构</span><br>        <span class="hljs-keyword">if</span>(A == <span class="hljs-literal">null</span> || A.val != B.val) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-comment">// 当A与B当前节点值相等,若要判断B为A的子结构</span><br>        <span class="hljs-comment">// 还需要判断B的左子树是否为A左子树的子结构 &amp;&amp; B的右子树是否为A右子树的子结构</span><br>        <span class="hljs-comment">// 若两者都满足就说明B是A的子结构,并且该子结构以A根节点为起点</span><br>        <span class="hljs-keyword">return</span> recur(A.left, B.left) &amp;&amp; recur(A.right, B.right);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>[参考链接:面试题26. 树的子结构（先序遍历 + 包含判断，清晰图解）](<a href="https://leetcode.cn/problems/shu-de-zi-jie-gou-lcof/solution/mian-shi-ti-26-shu-de-zi-jie-gou-xian-xu-bian-li-p/">面试题26. 树的子结构（先序遍历 + 包含判断，清晰图解） - 树的子结构 - 力扣（LeetCode）</a>)</p><h1 id="剑指-Offer-27-二叉树的镜像"><a href="#剑指-Offer-27-二叉树的镜像" class="headerlink" title="剑指 Offer 27. 二叉树的镜像"></a><a href="https://leetcode.cn/problems/er-cha-shu-de-jing-xiang-lcof/">剑指 Offer 27. 二叉树的镜像</a></h1><p>请完成一个函数，输入一个二叉树，该函数输出它的镜像。</p><p>例如输入：</p><p>   4<br>  &#x2F;  <br> 2   7<br> &#x2F; \  &#x2F; <br>1  3 6  9</p><p>镜像输出:</p><p>   4<br>  &#x2F;  <br> 7   2<br> &#x2F; \  &#x2F; <br>9  6 3  1</p><p>示例:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">输入：root = [<span class="hljs-number">4</span>,<span class="hljs-number">2</span>,<span class="hljs-number">7</span>,<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">6</span>,<span class="hljs-number">9</span>]<br>输出：[<span class="hljs-number">4</span>,<span class="hljs-number">7</span>,<span class="hljs-number">2</span>,<span class="hljs-number">9</span>,<span class="hljs-number">6</span>,<span class="hljs-number">3</span>,<span class="hljs-number">1</span>]<br></code></pre></td></tr></table></figure><p>其实解法和上面的差不多,也是递归,而且代码更为简便,要考虑的更少</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">mirrorTree</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">leftRoot</span> <span class="hljs-operator">=</span> mirrorTree(root.right);<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">rightRoot</span> <span class="hljs-operator">=</span> mirrorTree(root.left);<br>        root.left = leftRoot;<br>        root.right = rightRoot;<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="剑指-Offer-28-对称的二叉树"><a href="#剑指-Offer-28-对称的二叉树" class="headerlink" title="剑指 Offer 28. 对称的二叉树"></a><a href="https://leetcode.cn/problems/dui-cheng-de-er-cha-shu-lcof/">剑指 Offer 28. 对称的二叉树</a></h1><p><strong>请实现一个函数，用来判断一棵二叉树是不是对称的。如果一棵二叉树和它的镜像一样，那么它是对称的。</strong></p><p><strong>例如，二叉树 [1,2,2,3,4,4,3] 是对称的。</strong></p><p>  1<br>  &#x2F; <br> 2  2<br> &#x2F; \ &#x2F; <br>3  4 4  3</p><p>但是下面这个 [1,2,2,null,3,null,3] 则不是镜像对称的:</p><p>  1<br>  &#x2F; <br> 2  2<br>   \    <br>   3     3</p><p>示例 1：</p><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xquery">输入<span class="hljs-built_in">：root</span> = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">4</span>,<span class="hljs-number">3</span>]<br>输出<span class="hljs-built_in">：true</span><br></code></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">root</span> = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">3</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">3</span>]<br>输出：<span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><p><strong>做递归思考三步：</strong></p><ol><li><strong>递归的函数要干什么？</strong></li></ol><ul><li><strong>函数的作用是判断传入的两个树是否镜像。</strong></li><li><strong>输入：TreeNode left, TreeNode right</strong></li><li><strong>输出：是：true，不是：false</strong></li></ul><ol><li><strong>递归停止的条件是什么？</strong></li></ol><ul><li><strong>左节点和右节点都为空 -&gt; 倒底了都长得一样 -&gt;true</strong></li><li><strong>左节点为空的时候右节点不为空，或反之 -&gt; 长得不一样-&gt; false</strong></li><li><strong>左右节点值不相等 -&gt; 长得不一样 -&gt; false</strong></li></ul><ol><li><strong>从某层到下一层的关系是什么？</strong></li></ol><ul><li><strong>要想两棵树镜像，那么一棵树左边的左边要和二棵树右边的右边镜像，一棵树左边的右边要和二棵树右边的左边镜像</strong></li><li><strong>调用递归函数传入左左和右右</strong></li><li><strong>调用递归函数传入左右和右左</strong></li><li><strong>只有左左和右右镜像且左右和右左镜像的时候，我们才能说这两棵树是镜像的</strong></li></ul><ol><li><strong>调用递归函数，我们想知道它的左右孩子是否镜像，传入的值是root的左孩子和右孩子。这之前记得判个root&#x3D;&#x3D;null。</strong></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isSymmetric</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-type">return</span> <span class="hljs-variable">root</span> <span class="hljs-operator">=</span>= <span class="hljs-literal">null</span> ? <span class="hljs-literal">true</span> : recur(root.left, root.right);<br>    &#125;<br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">recur</span><span class="hljs-params">(TreeNode L, TreeNode R)</span> &#123;<br>        <span class="hljs-keyword">if</span>(L == <span class="hljs-literal">null</span> &amp;&amp; R == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">if</span>(L == <span class="hljs-literal">null</span> || R == <span class="hljs-literal">null</span> || L.val != R.val) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">return</span> recur(L.left, R.right) &amp;&amp; recur(L.right, R.left);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="%E9%93%BE%E6%8E%A5%EF%BC%9Ahttps://leetcode.cn/problems/dui-cheng-de-er-cha-shu-lcof/solution/mian-shi-ti-28-dui-cheng-de-er-cha-shu-di-gui-qing/">参考链接剑指 Offer 28. 对称的二叉树</a></p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>每日一练</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>每日一练</tag>
      
      <tag>剑指offer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>出现在Java程序中的finally代码块是否一定会执行</title>
    <link href="/2022/07/26/%E5%87%BA%E7%8E%B0%E5%9C%A8Java%E7%A8%8B%E5%BA%8F%E4%B8%AD%E7%9A%84finally%E4%BB%A3%E7%A0%81%E5%9D%97%E6%98%AF%E5%90%A6%E4%B8%80%E5%AE%9A%E4%BC%9A%E6%89%A7%E8%A1%8C/"/>
    <url>/2022/07/26/%E5%87%BA%E7%8E%B0%E5%9C%A8Java%E7%A8%8B%E5%BA%8F%E4%B8%AD%E7%9A%84finally%E4%BB%A3%E7%A0%81%E5%9D%97%E6%98%AF%E5%90%A6%E4%B8%80%E5%AE%9A%E4%BC%9A%E6%89%A7%E8%A1%8C/</url>
    
    <content type="html"><![CDATA[<h2 id="出现在Java程序中的finally代码块是否一定会执行？"><a href="#出现在Java程序中的finally代码块是否一定会执行？" class="headerlink" title="出现在Java程序中的finally代码块是否一定会执行？"></a>出现在Java程序中的finally代码块是否一定会执行？</h2><h5 id="当遇到下面情况不会执行。"><a href="#当遇到下面情况不会执行。" class="headerlink" title="当遇到下面情况不会执行。"></a>当遇到下面情况不会执行。</h5><ol><li><p>当程序在进入try语句块之前就出现异常时会直接结束。 </p></li><li><p>当程序在try块中强制退出时，如使用System.exit(0)，也不会执行finally块中的代码。</p></li></ol><p>其它情况下，在try&#x2F;catch&#x2F;finally语句执行的时候，try块先执行，当有异常发生，catch和finally进行处理后程序就结束了，当没有异常发生，在执行完finally中的代码后，后面代码会继续执行。<strong>值得注意的 是，当try&#x2F;catch语句块中有return时，finally语句块中的代码会在return之前执行。</strong>如果try&#x2F;catch&#x2F;finally块 中都有return语句，finally块中的return语句会覆盖try&#x2F;catch模块中的return语句。</p>]]></content>
    
    
    <categories>
      
      <category>每日一烤</category>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>每日一烤</tag>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>每日一练:剑指 Offer 32从上到下打印二叉树</title>
    <link href="/2022/07/25/%E5%89%91%E6%8C%87%20Offer%2032%E4%BB%8E%E4%B8%8A%E5%88%B0%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <url>/2022/07/25/%E5%89%91%E6%8C%87%20Offer%2032%E4%BB%8E%E4%B8%8A%E5%88%B0%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h1 id="剑指-Offer-32-I-从上到下打印二叉树"><a href="#剑指-Offer-32-I-从上到下打印二叉树" class="headerlink" title="剑指 Offer 32 - I. 从上到下打印二叉树"></a><a href="https://leetcode.cn/problems/cong-shang-dao-xia-da-yin-er-cha-shu-lcof/">剑指 Offer 32 - I. 从上到下打印二叉树</a></h1><p>从上到下打印出二叉树的每个节点，同一层的节点按照从左到右的顺序打印。</p><p>例如:<br>给定二叉树: <code>[3,9,20,null,null,15,7]</code>,</p><figure class="highlight livescript"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><pre><code class="hljs livescript">  <span class="hljs-number">3</span><br> / <span class="hljs-string">\</span><br><span class="hljs-number">9</span>  <span class="hljs-number">20</span><br>  /  <span class="hljs-string">\</span><br> <span class="hljs-number">15</span>   <span class="hljs-number">7</span><br></code></pre></td></tr></table></figure><p>返回：</p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs accesslog"><span class="hljs-string">[3,9,20,15,7]</span><br></code></pre></td></tr></table></figure><h4 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a>解题思路：</h4><ul><li><p>题目要求的二叉树的 <strong>从上至下</strong> 打印（即按层打印），又称为二叉树的 <strong>广度优先搜索</strong>（BFS）。</p></li><li><p>BFS 通常借助 <strong>队列</strong> 的先入先出特性来实现。</p><p>算法流程：<br>特例处理： 当树的根节点为空，则直接返回空列表 [] ；<br>初始化： 打印结果列表 res &#x3D; [] ，包含根节点的队列 queue &#x3D; [root] ；<br>BFS 循环： 当队列 queue 为空时跳出；<br>出队： 队首元素出队，记为 node；<br>打印： 将 node.val 添加至列表 tmp 尾部；<br>添加子节点： 若 node 的左（右）子节点不为空，则将左（右）子节点加入队列 queue ；<br>返回值： 返回打印结果列表 res 即可。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] levelOrder(TreeNode root) &#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">0</span>];<br>        Queue&lt;TreeNode&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;()&#123;&#123; add(root); &#125;&#125;;<span class="hljs-comment">//只有LinkedList,别写成LinkList</span><br>        ArrayList&lt;Integer&gt; ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">while</span>(!queue.isEmpty()) &#123;<br>            <span class="hljs-type">TreeNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> queue.poll();<br>            ans.add(node.val);<br>            <span class="hljs-keyword">if</span>(node.left != <span class="hljs-literal">null</span>) queue.add(node.left);<br>            <span class="hljs-keyword">if</span>(node.right != <span class="hljs-literal">null</span>) queue.add(node.right);<br>        &#125;<br>        <span class="hljs-type">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[ans.size()];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; ans.size(); i++)<br>            res[i] = ans.get(i);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/cong-shang-dao-xia-da-yin-er-cha-shu-lcof/solution/mian-shi-ti-32-i-cong-shang-dao-xia-da-yin-er-ch-4/">https://leetcode.cn/problems/cong-shang-dao-xia-da-yin-er-cha-shu-lcof/solution/mian-shi-ti-32-i-cong-shang-dao-xia-da-yin-er-ch-4/</a></p><h1 id="剑指-Offer-32-II-从上到下打印二叉树-II"><a href="#剑指-Offer-32-II-从上到下打印二叉树-II" class="headerlink" title="剑指 Offer 32 - II. 从上到下打印二叉树 II"></a><a href="https://leetcode.cn/problems/cong-shang-dao-xia-da-yin-er-cha-shu-ii-lcof/">剑指 Offer 32 - II. 从上到下打印二叉树 II</a></h1><p>从上到下按层打印二叉树，同一层的节点按从左到右的顺序打印，每一层打印到一行。</p><p>例如:<br>给定二叉树: [3,9,20,null,null,15,7],</p><div class="code-wrapper"><pre><code class="hljs">    3   / \  9  20    /  \   15   7</code></pre></div><p>返回其层次遍历结果：</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs inform7"><span class="hljs-comment">[</span><br><span class="hljs-comment">  <span class="hljs-comment">[3]</span>,</span><br><span class="hljs-comment">  <span class="hljs-comment">[9,20]</span>,</span><br><span class="hljs-comment">  <span class="hljs-comment">[15,7]</span></span><br><span class="hljs-comment">]</span><br></code></pre></td></tr></table></figure><h3 id="解题思路：-1"><a href="#解题思路：-1" class="headerlink" title="解题思路："></a>解题思路：</h3><p>和 上面的面试题32 - I. 从上到下打印二叉树差不多 两题仅有微小区别，即本题需将 每一层打印到一行 。</p><p>I. 按层打印： 题目要求的二叉树的 从上至下 打印（即按层打印），又称为二叉树的 广度优先搜索（BFS）。BFS 通常借助 队列 的先入先出特性来实现。</p><p>II. 每层打印到一行： 将本层全部节点打印到一行，并将下一层全部节点加入队列，以此类推，即可分为多行打印。</p><h4 id="算法流程："><a href="#算法流程：" class="headerlink" title="算法流程："></a>算法流程：</h4><p>特例处理： 当根节点为空，则返回空列表 [] ；<br>初始化： 打印结果列表 res &#x3D; [] ，包含根节点的队列 queue &#x3D; [root] ；<br>BFS 循环： 当队列 queue 为空时跳出；<br>新建一个临时列表 tmp ，用于存储当前层打印结果；<br>当前层打印循环： 循环次数为当前层节点数（即队列 queue 长度）；<br>出队： 队首元素出队，记为 node；<br>打印： 将 node.val 添加至 tmp 尾部；<br>添加子节点： 若 node 的左（右）子节点不为空，则将左（右）子节点加入队列 queue ；<br>将当前层结果 tmp 添加入 res 。<br>返回值： 返回打印结果列表 res 即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">levelOrder</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        Queue&lt;TreeNode&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<span class="hljs-comment">// List&lt;List&lt;Integer&gt;&gt;</span><br>        <span class="hljs-keyword">if</span>(root != <span class="hljs-literal">null</span>) queue.add(root);<br>        <span class="hljs-keyword">while</span>(!queue.isEmpty()) &#123;<br>            List&lt;Integer&gt; tmp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> queue.size(); i &gt; <span class="hljs-number">0</span>; i--) &#123;<br>                <span class="hljs-type">TreeNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> queue.poll();<br>                tmp.add(node.val);<br>                <span class="hljs-keyword">if</span>(node.left != <span class="hljs-literal">null</span>) queue.add(node.left);<br>                <span class="hljs-keyword">if</span>(node.right != <span class="hljs-literal">null</span>) queue.add(node.right);<br>            &#125;<br>            res.add(tmp);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/cong-shang-dao-xia-da-yin-er-cha-shu-ii-lcof/solution/mian-shi-ti-32-ii-cong-shang-dao-xia-da-yin-er-c-5/">参考链接:剑指 Offer 32 - II. 从上到下打印二叉树 II</a></p><h1 id="剑指-Offer-32-III-从上到下打印二叉树-III"><a href="#剑指-Offer-32-III-从上到下打印二叉树-III" class="headerlink" title="剑指 Offer 32 - III. 从上到下打印二叉树 III"></a><a href="https://leetcode.cn/problems/cong-shang-dao-xia-da-yin-er-cha-shu-iii-lcof/">剑指 Offer 32 - III. 从上到下打印二叉树 III</a></h1><p>请实现一个函数按照之字形顺序打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右到左的顺序打印，第三行再按照从左到右的顺序打印，其他行以此类推。</p><p>例如:<br>给定二叉树: [3,9,20,null,null,15,7],</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs livescript">  <span class="hljs-number">3</span><br> / <span class="hljs-string">\</span><br><span class="hljs-number">9</span>  <span class="hljs-number">20</span><br>  /  <span class="hljs-string">\</span><br> <span class="hljs-number">15</span>   <span class="hljs-number">7</span><br></code></pre></td></tr></table></figure><p>返回其层次遍历结果：</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs inform7"><span class="hljs-comment">[</span><br><span class="hljs-comment">  <span class="hljs-comment">[3]</span>,</span><br><span class="hljs-comment">  <span class="hljs-comment">[20,9]</span>,</span><br><span class="hljs-comment">  <span class="hljs-comment">[15,7]</span></span><br><span class="hljs-comment">]</span><br></code></pre></td></tr></table></figure><p>本题额外要求 <strong>打印顺序交替变化</strong></p><p>方法一：层序遍历 + 双端队列<br>利用双端队列的两端皆可添加元素的特性，设打印列表（双端队列） tmp ，并规定：<br>奇数层 则添加至 tmp 尾部 ，<br>偶数层 则添加至 tmp 头部 。<br>算法流程：<br>特例处理： 当树的根节点为空，则直接返回空列表 [] ；<br>初始化： 打印结果空列表 res ，包含根节点的双端队列 deque ；<br>BFS 循环： 当 deque 为空时跳出；<br>新建列表 tmp ，用于临时存储当前层打印结果；<br>当前层打印循环： 循环次数为当前层节点数（即 deque 长度）；<br>出队： 队首元素出队，记为 node；<br>打印： 若为奇数层，将 node.val 添加至 tmp 尾部；否则，添加至 tmp 头部；<br>添加子节点： 若 node 的左（右）子节点不为空，则加入 deque ；<br>将当前层结果 tmp 转化为 list 并添加入 res ；<br>返回值： 返回打印结果列表 res 即可；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">levelOrder</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        Queue&lt;TreeNode&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">if</span>(root != <span class="hljs-literal">null</span>) queue.add(root);<br>        <span class="hljs-keyword">while</span>(!queue.isEmpty()) &#123;<br>            LinkedList&lt;Integer&gt; tmp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<span class="hljs-comment">//改成LinkedList,既可以头插法也可以尾插法</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> queue.size(); i &gt; <span class="hljs-number">0</span>; i--) &#123;<br>                <span class="hljs-type">TreeNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> queue.poll();<br>                <span class="hljs-keyword">if</span>(res.size() % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>) tmp.addLast(node.val); <span class="hljs-comment">// 偶数层 -&gt; 队列头部</span><br>                <span class="hljs-keyword">else</span> tmp.addFirst(node.val); <span class="hljs-comment">// 奇数层 -&gt; 队列尾部</span><br>                <span class="hljs-keyword">if</span>(node.left != <span class="hljs-literal">null</span>) queue.add(node.left);<br>                <span class="hljs-keyword">if</span>(node.right != <span class="hljs-literal">null</span>) queue.add(node.right);<br>            &#125;<br>            res.add(tmp);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>方法二：层序遍历 + 双端队列（奇偶层逻辑分离）<br>方法一代码简短、容易实现；但需要判断每个节点的所在层奇偶性，即冗余了 NN 次判断。<br>通过将奇偶层逻辑拆分，可以消除冗余的判断。<br>算法流程：<br>与方法一对比，仅 BFS 循环不同。</p><p>BFS 循环： 循环打印奇 &#x2F; 偶数层，当 deque 为空时跳出；<br>打印奇数层： 从左向右 打印，先左后右 加入下层节点；<br>若 deque 为空，说明向下无偶数层，则跳出；<br>打印偶数层： 从右向左 打印，先右后左 加入下层节点；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">levelOrder</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        Deque&lt;TreeNode&gt; deque = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">if</span>(root != <span class="hljs-literal">null</span>) deque.add(root);<br>        <span class="hljs-keyword">while</span>(!deque.isEmpty()) &#123;<br>            <span class="hljs-comment">// 打印奇数层</span><br>            List&lt;Integer&gt; tmp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> deque.size(); i &gt; <span class="hljs-number">0</span>; i--) &#123;<br>                <span class="hljs-comment">// 从左向右打印</span><br>                <span class="hljs-type">TreeNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> deque.removeFirst();<br>                tmp.add(node.val);<br>                <span class="hljs-comment">// 先左后右加入下层节点</span><br>                <span class="hljs-keyword">if</span>(node.left != <span class="hljs-literal">null</span>) deque.addLast(node.left);<br>                <span class="hljs-keyword">if</span>(node.right != <span class="hljs-literal">null</span>) deque.addLast(node.right);<br>            &#125;<br>            res.add(tmp);<br>            <span class="hljs-keyword">if</span>(deque.isEmpty()) <span class="hljs-keyword">break</span>; <span class="hljs-comment">// 若为空则提前跳出</span><br>            <span class="hljs-comment">// 打印偶数层</span><br>            tmp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> deque.size(); i &gt; <span class="hljs-number">0</span>; i--) &#123;<br>                <span class="hljs-comment">// 从右向左打印</span><br>                <span class="hljs-type">TreeNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> deque.removeLast();<br>                tmp.add(node.val);<br>                <span class="hljs-comment">// 先右后左加入下层节点</span><br>                <span class="hljs-keyword">if</span>(node.right != <span class="hljs-literal">null</span>) deque.addFirst(node.right);<br>                <span class="hljs-keyword">if</span>(node.left != <span class="hljs-literal">null</span>) deque.addFirst(node.left);<br>            &#125;<br>            res.add(tmp);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>方法三：层序遍历 + 倒序<br>此方法的优点是只用列表即可，无需其他数据结构。<br>偶数层倒序： 若 res 的长度为 奇数 ，说明当前是偶数层，则对 tmp 执行 倒序 操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">levelOrder</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        Queue&lt;TreeNode&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">if</span>(root != <span class="hljs-literal">null</span>) queue.add(root);<br>        <span class="hljs-keyword">while</span>(!queue.isEmpty()) &#123;<br>            List&lt;Integer&gt; tmp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> queue.size(); i &gt; <span class="hljs-number">0</span>; i--) &#123;<br>                <span class="hljs-type">TreeNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> queue.poll();<br>                tmp.add(node.val);<br>                <span class="hljs-keyword">if</span>(node.left != <span class="hljs-literal">null</span>) queue.add(node.left);<br>                <span class="hljs-keyword">if</span>(node.right != <span class="hljs-literal">null</span>) queue.add(node.right);<br>            &#125;<br>            <span class="hljs-keyword">if</span>(res.size() % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>) Collections.reverse(tmp);<br>            res.add(tmp);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><a href="%E9%93%BE%E6%8E%A5%EF%BC%9Ahttps://leetcode.cn/problems/cong-shang-dao-xia-da-yin-er-cha-shu-iii-lcof/solution/mian-shi-ti-32-iii-cong-shang-dao-xia-da-yin-er--3/">参考链接剑指 Offer 32 - III. 从上到下打印二叉树 III</a></p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>每日一练</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>每日一练</tag>
      
      <tag>剑指offer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>每日一烤:构造方法、成员变量初始化以及静态成员变量三者的初始化顺序</title>
    <link href="/2022/07/25/%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E5%88%9D%E5%A7%8B%E5%8C%96%E4%BB%A5%E5%8F%8A%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E4%B8%89%E8%80%85%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E9%A1%BA%E5%BA%8F/"/>
    <url>/2022/07/25/%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E5%88%9D%E5%A7%8B%E5%8C%96%E4%BB%A5%E5%8F%8A%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E4%B8%89%E8%80%85%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E9%A1%BA%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="构造方法、成员变量初始化以及静态成员变量三者的初始化顺序？"><a href="#构造方法、成员变量初始化以及静态成员变量三者的初始化顺序？" class="headerlink" title="构造方法、成员变量初始化以及静态成员变量三者的初始化顺序？"></a>构造方法、成员变量初始化以及静态成员变量三者的初始化顺序？</h1><h3 id="先后顺序：静态成员变量、成员变量、构造方法。"><a href="#先后顺序：静态成员变量、成员变量、构造方法。" class="headerlink" title="先后顺序：静态成员变量、成员变量、构造方法。"></a>先后顺序：静态成员变量、成员变量、构造方法。</h3><h4 id="详细的先后顺序：父类静态变量、父类静态代码块、子类静态变量、子类静态代码块、父类非静态变-量、父类非静态代码块、父类构造函数、子类非静态变量、子类非静态代码块、子类构造函数。-x3D-x3D-还是有点晕-总之静态优先-其次父优先-最后变量-gt-代码块-gt-构造器-x3D-x3D"><a href="#详细的先后顺序：父类静态变量、父类静态代码块、子类静态变量、子类静态代码块、父类非静态变-量、父类非静态代码块、父类构造函数、子类非静态变量、子类非静态代码块、子类构造函数。-x3D-x3D-还是有点晕-总之静态优先-其次父优先-最后变量-gt-代码块-gt-构造器-x3D-x3D" class="headerlink" title="详细的先后顺序：父类静态变量、父类静态代码块、子类静态变量、子类静态代码块、父类非静态变 量、父类非静态代码块、父类构造函数、子类非静态变量、子类非静态代码块、子类构造函数。 &#x3D;&#x3D;(还是有点晕,总之静态优先,其次父优先,最后变量-&gt;代码块-&gt;构造器)&#x3D;&#x3D;"></a>详细的先后顺序：父类静态变量、父类静态代码块、子类静态变量、子类静态代码块、父类非静态变 量、父类非静态代码块、父类构造函数、子类非静态变量、子类非静态代码块、子类构造函数。 &#x3D;&#x3D;<strong>(还是有点晕,总之静态优先,其次父优先,最后变量-&gt;代码块-&gt;构造器)</strong>&#x3D;&#x3D;</h4><h1 id="为什么Java语言不支持多重继承？"><a href="#为什么Java语言不支持多重继承？" class="headerlink" title="为什么Java语言不支持多重继承？"></a><strong>为什么Java语言不支持多重继承？</strong></h1><ol><li><h3 id="为了程序的结构能够更加清晰从而便于维护。假设Java语言支持多重继承，类C继承自类A和类B-如果类A和B都有自定义的成员方法f-那么当代码中调用类C的f-会产生二义性。-x3D-x3D-Java语言通过实现-多个接口间接支持多重继承-x3D-x3D-，-x3D-x3D-接口由于只包含方法定义，不能有方法的实现，类C继承接口A与接-口B时即使它们都有方法f-也不能直接调用方法，需实现具体的f-方法才能调用，不会产生二义-性。-x3D-x3D-所以接口里不能有方法的实现现在懂了吧"><a href="#为了程序的结构能够更加清晰从而便于维护。假设Java语言支持多重继承，类C继承自类A和类B-如果类A和B都有自定义的成员方法f-那么当代码中调用类C的f-会产生二义性。-x3D-x3D-Java语言通过实现-多个接口间接支持多重继承-x3D-x3D-，-x3D-x3D-接口由于只包含方法定义，不能有方法的实现，类C继承接口A与接-口B时即使它们都有方法f-也不能直接调用方法，需实现具体的f-方法才能调用，不会产生二义-性。-x3D-x3D-所以接口里不能有方法的实现现在懂了吧" class="headerlink" title="为了程序的结构能够更加清晰从而便于维护。假设Java语言支持多重继承，类C继承自类A和类B, 如果类A和B都有自定义的成员方法f(),那么当代码中调用类C的f()会产生二义性。&#x3D;&#x3D;Java语言通过实现 多个接口间接支持多重继承&#x3D;&#x3D;，**&#x3D;&#x3D;接口由于只包含方法定义，不能有方法的实现，类C继承接口A与接 口B时即使它们都有方法f(),也不能直接调用方法，需实现具体的f()方法才能调用，不会产生二义 性。&#x3D;&#x3D;** (所以接口里不能有方法的实现现在懂了吧)"></a>为了程序的结构能够更加清晰从而便于维护。假设Java语言支持多重继承，类C继承自类A和类B, 如果类A和B都有自定义的成员方法f(),那么当代码中调用类C的f()会产生二义性。&#x3D;&#x3D;<strong>Java语言通过实现 多个接口间接支持多重继承</strong>&#x3D;&#x3D;，**&#x3D;&#x3D;接口由于只包含方法定义，不能有方法的实现，类C继承接口A与接 口B时即使它们都有方法f(),也不能直接调用方法，需实现具体的f()方法才能调用，不会产生二义 性。&#x3D;&#x3D;** (所以接口里不能有方法的实现现在懂了吧)</h3></li><li><h3 id="多重继承会使类型转换、构造方法的调用顺序变得复杂，会影响到性能。"><a href="#多重继承会使类型转换、构造方法的调用顺序变得复杂，会影响到性能。" class="headerlink" title="多重继承会使类型转换、构造方法的调用顺序变得复杂，会影响到性能。"></a>多重继承会使类型转换、构造方法的调用顺序变得复杂，会影响到性能。</h3></li></ol><h1 id="复习-接口和抽象类的相同点和区别？"><a href="#复习-接口和抽象类的相同点和区别？" class="headerlink" title="(复习)接口和抽象类的相同点和区别？"></a>(复习)接口和抽象类的相同点和区别？</h1><p>相同点: </p><ol><li><p>都不能被实例化。&#x3D;&#x3D;<strong>(但抽象类可以有构造器,但不可以实例化,也要留给继承的子类去使用这个构造器,实现接口没有构造器)</strong>&#x3D;&#x3D; </p></li><li><p>接口的实现类或抽象类的子类需实现接口或抽象类中相应的方法才能被实例化。</p></li></ol><p>不同点： </p><ol start="3"><li>接口只能有方法定义，不能有方法的实现，而抽象类可以有方法的定义与实现&#x3D;&#x3D;。**(抽象类方法不可以有方法体,要留给继承的子类去具体实现,抽象类里的非抽象方法有方法体,接口只有定义，不能有方法的实现)**&#x3D;&#x3D; </li><li>实现接口的关键字为implements,继承抽象类的关键字为extends。一个类可以实现多个接口，只能继承一个抽象类。 </li><li>当子类和父类之间存在&#x3D;&#x3D;<strong>逻辑上的层次结构</strong>&#x3D;&#x3D;，推荐使用抽象类，&#x3D;&#x3D;<strong>有利于功能的累积</strong>。<strong>当功能不需要， 希望支持差别较大的两个或更多对象间的特定交互行为</strong>&#x3D;&#x3D;，推荐使用接口。使用&#x3D;&#x3D;<strong>接口能降低软件系统 的耦合度</strong>&#x3D;&#x3D;，便于日后维护或添加删除方法。</li></ol>]]></content>
    
    
    <categories>
      
      <category>每日一烤</category>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>每日一烤</tag>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指 Offer 50. 第一个只出现一次的字符</title>
    <link href="/2022/07/24/%E5%89%91%E6%8C%87%20Offer%2050.%20%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E5%AD%97%E7%AC%A6/"/>
    <url>/2022/07/24/%E5%89%91%E6%8C%87%20Offer%2050.%20%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E5%AD%97%E7%AC%A6/</url>
    
    <content type="html"><![CDATA[<h1 id="剑指-Offer-50-第一个只出现一次的字符"><a href="#剑指-Offer-50-第一个只出现一次的字符" class="headerlink" title="剑指 Offer 50. 第一个只出现一次的字符"></a><a href="https://leetcode.cn/problems/di-yi-ge-zhi-chu-xian-yi-ci-de-zi-fu-lcof/">剑指 Offer 50. 第一个只出现一次的字符</a></h1><p>在字符串 s 中找出第一个只出现一次的字符。如果没有，返回一个单空格。 s 只包含小写字母。</p><p>示例 1:</p><figure class="highlight 1c"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><pre><code class="hljs 1c">输入：s = <span class="hljs-string">&quot;abaccdeff&quot;</span><br>输出：&#x27;b&#x27;<br>示例 <span class="hljs-number">2</span>:<br><br>输入：s = <span class="hljs-string">&quot;&quot;</span> <br>输出：&#x27; &#x27;<br></code></pre></td></tr></table></figure><p>三个解答,思想相同,和前几天输出出现2次的数组元素差不多,不写算法过程了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">char</span> <span class="hljs-title function_">firstUniqChar</span><span class="hljs-params">(String s)</span> &#123;<br>        Map&lt;Character, Integer&gt; frequency = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;Character, Integer&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; s.length(); ++i) &#123;<br>            <span class="hljs-type">char</span> <span class="hljs-variable">ch</span> <span class="hljs-operator">=</span> s.charAt(i);<br>            frequency.put(ch, frequency.getOrDefault(ch, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; s.length(); ++i) &#123;<br>            <span class="hljs-keyword">if</span> (frequency.get(s.charAt(i)) == <span class="hljs-number">1</span>) &#123;<br>                <span class="hljs-keyword">return</span> s.charAt(i);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27; &#x27;</span>;<br>    &#125;<br>&#125;<br><br><br><br><br>Map&lt;Character, Boolean&gt; dic = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br><br><span class="hljs-type">char</span>[] array = s.toCharArray();<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> c : array) &#123;<br>    dic.put(c, !dic.containsKey(c));<span class="hljs-comment">//第一次,containsKey返回1,!containsKey返回0,下一次重复的c放进去,containsKey返回0,!containsKey返回1</span><br>&#125;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> c : array) &#123;<br>    <span class="hljs-keyword">if</span> (dic.get(c)) <span class="hljs-keyword">return</span> c;<span class="hljs-comment">//dic.get(c)获取key为c的value,正常时0,不会执行c,但如果没重复,flag被置为1,执行return c</span><br>&#125;<br><br><span class="hljs-keyword">return</span> <span class="hljs-string">&#x27; &#x27;</span>;<br><br><br><br><span class="hljs-keyword">public</span> <span class="hljs-type">char</span> <span class="hljs-title function_">firstUniqChar</span><span class="hljs-params">(String s)</span> &#123;<br>    <span class="hljs-comment">//注重边界情况的处理！特别是s为空字符串，以及在处理之后判断s是否为空字符串！思路严谨。</span><br>    <span class="hljs-keyword">if</span>(s.isEmpty()) <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27; &#x27;</span>;<br>    HashSet&lt;Character&gt; counter = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">char</span> c:s.toCharArray())&#123;<br>        <span class="hljs-keyword">if</span>(counter.contains(c))<br>            s = s.replace(String.valueOf(c),<span class="hljs-string">&quot;&quot;</span>);<br>        <span class="hljs-keyword">else</span><br>            counter.add(c);<br>    &#125;<br>    <span class="hljs-keyword">return</span> s.isEmpty()?<span class="hljs-string">&#x27; &#x27;</span>:s.charAt(<span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>每日一练</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>每日一练</tag>
      
      <tag>剑指offer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指 Offer 11. 旋转数组的最小数字</title>
    <link href="/2022/07/23/%E5%89%91%E6%8C%87%20Offer%2011.%20%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97/"/>
    <url>/2022/07/23/%E5%89%91%E6%8C%87%20Offer%2011.%20%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97/</url>
    
    <content type="html"><![CDATA[<h1 id="剑指-Offer-11-旋转数组的最小数字"><a href="#剑指-Offer-11-旋转数组的最小数字" class="headerlink" title="剑指 Offer 11. 旋转数组的最小数字"></a><a href="https://leetcode.cn/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof/">剑指 Offer 11. 旋转数组的最小数字</a></h1><p>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。</p><p>给你一个可能存在 重复 元素值的数组 numbers ，它原来是一个升序排列的数组，并按上述情形进行了一次旋转。请返回旋转数组的最小元素。例如，数组 [3,4,5,1,2] 为 [1,2,3,4,5] 的一次旋转，该数组的最小值为 1。  </p><p>注意，数组 [a[0], a[1], a[2], …, a[n-1]] 旋转一次 的结果为数组 [a[n-1], a[0], a[1], a[2], …, a[n-2]] 。</p><figure class="highlight accesslog"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><pre><code class="hljs accesslog">示例 <span class="hljs-number">1</span>：<br><br>输入：numbers = <span class="hljs-string">[3,4,5,1,2]</span><br>输出：<span class="hljs-number">1</span><br>示例 <span class="hljs-number">2</span>：<br><br>输入：numbers = <span class="hljs-string">[2,2,2,0,1]</span><br>输出：<span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><h4 id="用不解决要face的方式"><a href="#用不解决要face的方式" class="headerlink" title="用不解决要face的方式"></a>用不解决要face的方式</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minArray</span><span class="hljs-params">(<span class="hljs-type">int</span>[] numbers)</span> &#123;<br>        Arrays.sort(numbers);<br>        <span class="hljs-keyword">return</span> numbers[<span class="hljs-number">0</span>];<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>说这么多,其实只要输出一维数组中的最小值,就会运行成功,但题目之所以说那么啰嗦,就是不希望你用这种方法,会被别人鄙视,你需要会更高级的方法</p><p>算法流程：<br>初始化： 声明 i, j 双指针分别指向 nums 数组左右两端；<br>循环二分： 设 m &#x3D; (i + j) &#x2F; 2 为每次二分的中点（ “&#x2F;“ 代表向下取整除法，因此恒有 i \leq m &lt; ji≤m&lt;j ），可分为以下三种情况：<br>当 ]nums[m]&gt;nums[j] 时： mm 一定在 左排序数组 中，即旋转点 xx 一定在 [m + 1, j][m+1,j] 闭区间内，因此执行 i &#x3D; m + 1；<br>当 nums[m] &lt; nums[j]时： m 一定在 右排序数组 中，即旋转点 x一定在[i, m][i,m] 闭区间内，因此执行 j &#x3D; m；<br>当 nums[m] &#x3D; nums[j] 时： 无法判断 m 在哪个排序数组中，即无法判断旋转点 x 在 [i, m][i,m] 还是 [m + 1, j][m+1,j] 区间中。解决方案： 执行 j &#x3D; j - 1缩小判断范围，分析见下文。<br>返回值： 当 i &#x3D; j时跳出二分循环，并返回 旋转点的值 nums[i] 即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minArray</span><span class="hljs-params">(<span class="hljs-type">int</span>[] numbers)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, j = numbers.length - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (i &lt; j) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> (i + j) / <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span> (numbers[m] &gt; numbers[j]) i = m + <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (numbers[m] &lt; numbers[j]) j = m;<br>            <span class="hljs-keyword">else</span> j--;<br>        &#125;<br>        <span class="hljs-keyword">return</span> numbers[i];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>实际上，当出现 nums[m] &#x3D; nums[j]时，一定有区间 [i, m][i,m] 内所有元素相等 或 区间 [m, j][m,j] 内所有元素相等（或两者皆满足）。对于寻找此类数组的最小值问题，可直接放弃二分查找，而使用线性查找替代</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minArray</span><span class="hljs-params">(<span class="hljs-type">int</span>[] numbers)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, j = numbers.length - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (i &lt; j) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> (i + j) / <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span> (numbers[m] &gt; numbers[j]) i = m + <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (numbers[m] &lt; numbers[j]) j = m;<br>            <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> i;<br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> i + <span class="hljs-number">1</span>; k &lt; j; k++) &#123;<br>                    <span class="hljs-keyword">if</span>(numbers[k] &lt; numbers[x]) x = k;<br>                &#125;<br>                <span class="hljs-keyword">return</span> numbers[x];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> numbers[i];<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>每日一练</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>每日一练</tag>
      
      <tag>剑指offer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指 Offer 04. 二维数组中的查找</title>
    <link href="/2022/07/23/%E5%89%91%E6%8C%87%20Offer%2004.%20%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE/"/>
    <url>/2022/07/23/%E5%89%91%E6%8C%87%20Offer%2004.%20%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE/</url>
    
    <content type="html"><![CDATA[<h1 id="剑指-Offer-04-二维数组中的查找"><a href="#剑指-Offer-04-二维数组中的查找" class="headerlink" title="剑指 Offer 04. 二维数组中的查找"></a><a href="https://leetcode.cn/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof/">剑指 Offer 04. 二维数组中的查找</a></h1><p>在一个 n * m 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个高效的函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p><p> 示例:</p><figure class="highlight inform7"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><pre><code class="hljs inform7">现有矩阵 matrix 如下：<br><br><span class="hljs-comment">[</span><br><span class="hljs-comment">  <span class="hljs-comment">[1,   4,  7, 11, 15]</span>,</span><br><span class="hljs-comment">  <span class="hljs-comment">[2,   5,  8, 12, 19]</span>,</span><br><span class="hljs-comment">  <span class="hljs-comment">[3,   6,  9, 16, 22]</span>,</span><br><span class="hljs-comment">  <span class="hljs-comment">[10, 13, 14, 17, 24]</span>,</span><br><span class="hljs-comment">  <span class="hljs-comment">[18, 21, 23, 26, 30]</span></span><br><span class="hljs-comment">]</span><br></code></pre></td></tr></table></figure><p>给定 target &#x3D; 5，返回 true。</p><p>给定 target &#x3D; 20，返回 false。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">findNumberIn2DArray</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] matrix, <span class="hljs-type">int</span> target)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> matrix.length - <span class="hljs-number">1</span>, j = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(i &gt;= <span class="hljs-number">0</span> &amp;&amp; j &lt; matrix[<span class="hljs-number">0</span>].length)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(matrix[i][j] &gt; target) i--;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(matrix[i][j] &lt; target) j++;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="算法流程："><a href="#算法流程：" class="headerlink" title="算法流程："></a><strong>算法流程：</strong></h5><ol><li>从矩阵matrix左下角元素（索引设为(i, j)）开始遍历，并与目标值对比：<ul><li>当 <code>matrix[i][j] &gt; target</code> 时，执行 <code>i--</code> ，即消去第 <code>i</code> 行元素；</li><li>当 <code>matrix[i][j] &lt; target</code> 时，执行 <code>j++</code> ，即消去第 <code>j</code> 列元素；</li><li>当 <code>matrix[i][j] = target</code> 时，返回 true，代表找到目标值。</li></ul></li><li>若行索引或列索引越界，则代表矩阵中无目标值，返回 false。</li></ol><blockquote><p>每轮 <code>i</code> 或 <code>j</code> 移动后，相当于生成了“消去一行（列）的新矩阵”， 索引<code>(i,j)</code> 指向新矩阵的左下角元素（标志数），因此可重复使用以上性质消去行（列）。</p></blockquote><h5 id="复杂度分析："><a href="#复杂度分析：" class="headerlink" title="复杂度分析："></a>复杂度分析：</h5><ul><li>时间复杂度 O(M+N) ：其中，N 和 M 分别为矩阵行数和列数，此算法最多循环M+N 次。</li><li>空间复杂度 O(1) : <code>i</code>, <code>j</code> 指针使用常数大小额外空间。</li></ul><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode.cn/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof">https://leetcode.cn/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof</a></p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>每日一练</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>每日一练</tag>
      
      <tag>剑指offer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>每日一烤:接口与抽象类</title>
    <link href="/2022/07/23/%E6%8E%A5%E5%8F%A3%E4%B8%8E%E6%8A%BD%E8%B1%A1%E7%B1%BB/"/>
    <url>/2022/07/23/%E6%8E%A5%E5%8F%A3%E4%B8%8E%E6%8A%BD%E8%B1%A1%E7%B1%BB/</url>
    
    <content type="html"><![CDATA[<h1 id="接口与抽象类"><a href="#接口与抽象类" class="headerlink" title="接口与抽象类"></a>接口与抽象类</h1><p><strong>抽象类有构造器,但不可以实例化,也要留给继承的子类去使用这个构造器,实现接口没有构造器</strong><br><strong>抽象类方法不可以有方法体,要留给继承的子类去具体实现,抽象类里的非抽象方法有方法体,接口只有定义，不能有方法的实现</strong></p><p><strong>“Java中，一个类实现了某接口，则必须实现该接口中的所有方法么？”这句话其实是不准确的，因为我们还没有考虑到抽象类。</strong><br><strong>抽象类实现某个接口，可以不实现所有接口的方法，可以由它的子类实现。而普通类即非抽象类则必须实现接口里的全部方法。</strong><br><strong>同样地，再来讲述一下接口：</strong><br><strong>1 接口的设计解决了java只能单继承的缺点，可以实现多个接口来实现java的多继承。</strong><br><strong>2 实现某个接口必须覆写其中的所有方法，当然也可以是一个空的实现（方法体为空没有任何作用），但是这个类必须是非抽象类，抽象类如上文。</strong></p><h3 id="1、基本语法区别"><a href="#1、基本语法区别" class="headerlink" title="1、基本语法区别"></a>1、基本语法区别</h3><p>Java中接口和抽象类的定义语法分别为interface与abstract关键字。</p><p><strong>抽象类</strong>：在Java中被abstract关键字修饰的类称为抽象类，被abstract关键字修饰的方法称为抽象方法，抽象方法只有方法的声明，没有方法体。抽象类的特点：</p><p>a、抽象类不能被实例化只能被继承；</p><p>b、包含抽象方法的一定是抽象类，但是抽象类不一定含有抽象方法；</p><p>c、抽象类中的抽象方法的修饰符只能为public或者protected，默认为public；</p><p>&#x3D;&#x3D;d、一个子类继承一个抽象类，则子类必须实现父类抽象方法，否则子类也必须定义为抽象类；&#x3D;&#x3D;</p><p>&#x3D;&#x3D;e、抽象类可以包含属性、方法、构造方法，但是构造方法不能用于实例化，主要用途是被子类调用。&#x3D;&#x3D;</p><p>*<strong>接口*：</strong>Java中接口使用interface关键字修饰，特点为:</p><p>a、接口可以包含变量、方法；变量被隐士指定为public static final，方法被隐士指定为public abstract（JDK1.8之前）；</p><p>b、接口支持多继承，即一个接口可以extends多个接口，间接的解决了Java中类的单继承问题；</p><p>c、一个类可以实现多个接口；</p><p>d、JDK1.8中对接口增加了新的特性：（1）、默认方法（default method）：JDK 1.8允许给接口添加非抽象的方法实现，但必须使用default关键字修饰；定义了default的方法可以不被实现子类所实现，但只能被实现子类的对象调用；如果子类实现了多个接口，并且这些接口包含一样的默认方法，则子类必须重写默认方法；（2）、静态方法（static method）：JDK 1.8中允许使用static关键字修饰一个方法，并提供实现，称为接口静态方法。接口静态方法只能通过接口调用（接口名.静态方法名）。</p><figure class="highlight java"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Person</span>&#123;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> a=<span class="hljs-number">10</span>;<br>  <span class="hljs-comment">//JDK 1.8 以后，接口允许包含具体实现的方法，该方法称为&quot;默认方法&quot;，默认方法使用 default 关键字修饰。更多内容可参考</span><br>    <span class="hljs-keyword">default</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sayHello</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;Hello World&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">say</span><span class="hljs-params">()</span>;<br>&#125;<br><br><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>&#123;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">say</span><span class="hljs-params">()</span>;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">eat</span><span class="hljs-params">()</span>&#123;&#125;;<br>&#125;<br></code></pre></td></tr></table></figure><p>接口只能是功能的定义，而抽象类既可以为功能的定义也可以为功能的实现。</p><p><strong>相同点</strong></p><p>（1）都不能被实例化 （2）接口的实现类或抽象类的子类都只有实现了接口或抽象类中的方法后才能实例化。</p><p><strong>不同点</strong></p><p>（1）接口只有定义，不能有方法的实现，java 1.8中可以定义default方法体，而抽象类可以有定义与实现，方法可在抽象类中实现。</p><p>（2）实现接口的关键字为implements，继承抽象类的关键字为extends。一个类可以实现多个接口，但一个类只能继承一个抽象类。所以，使用接口可以间接地实现多重继承。</p><p>（3）接口强调特定功能的实现，而抽象类强调所属关系。</p><p>（4）接口成员变量默认为public static final，必须赋初值，不能被修改；其所有的成员方法都是public、abstract的。抽象类中成员变量默认default，可在子类中被重新定义，也可被重新赋值；抽象方法被abstract修饰，不能被private、static、synchronized和native等修饰，必须以分号结尾，不带花括号。</p><p>URL:[深入理解 Java 的接口和抽象类 | 菜鸟教程 (runoob.com)</p><p><a href="https://www.runoob.com/w3cnote/java-abstract-interface-different.html">抽象类方法不可以有方法体,抽象类里的非抽象方法有方法体</a></p>]]></content>
    
    
    <categories>
      
      <category>每日一烤</category>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>每日一烤</tag>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>每日一练:剑指 Offer 03. 数组中重复的数字</title>
    <link href="/2022/07/22/%E5%89%91%E6%8C%87%20Offer%2003.%20%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97/"/>
    <url>/2022/07/22/%E5%89%91%E6%8C%87%20Offer%2003.%20%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97/</url>
    
    <content type="html"><![CDATA[<h1 id="剑指-Offer-03-数组中重复的数字"><a href="#剑指-Offer-03-数组中重复的数字" class="headerlink" title="剑指 Offer 03. 数组中重复的数字"></a><a href="https://leetcode.cn/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof/">剑指 Offer 03. 数组中重复的数字</a></h1><p>找出数组中重复的数字。</p><p>在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。</p><p>示例 1：</p><figure class="highlight accesslog"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><pre><code class="hljs accesslog">输入：<br><span class="hljs-string">[2, 3, 1, 0, 2, 5, 3]</span><br>输出：<span class="hljs-number">2</span> 或 <span class="hljs-number">3</span> <br></code></pre></td></tr></table></figure><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode.cn/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof">https://leetcode.cn/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof</a></p><p>&#x3D;&#x3D;了解到了哈希Set的数据结构&#x3D;&#x3D;</p><p>&#x3D;&#x3D;定义:Set<T> dic &#x3D; new HashSet&lt;&gt;();&#x3D;&#x3D;</p><p>&#x3D;&#x3D;方法:dic.contains(),dic.add()&#x3D;&#x3D;</p><h4 id="方法一：哈希表-x2F-Set"><a href="#方法一：哈希表-x2F-Set" class="headerlink" title="方法一：哈希表 &#x2F; Set"></a>方法一：哈希表 &#x2F; Set</h4><p>利用数据结构特点，容易想到使用哈希表（Set）记录数组的各个数字，当查找到重复数字则直接返回。</p><p>算法流程：<br>初始化： 新建 HashSet ，记为 dicdic ；<br>遍历数组 nums 中的每个数字 num ：<br>当 num 在 dic中，说明重复，直接返回 num ；<br>将 num添加至 dic 中；<br>返回 -1−1 。本题中一定有重复数字，因此这里返回多少都可以。<br>复杂度分析：<br>时间复杂度 O(N)： 遍历数组使用 O(N) ，HashSet 添加与查找元素皆为 O(1) 。<br>空间复杂度 O(N) ： HashSet 占用 O(N) 大小的额外空间。</p><p>作者：jyd<br>链接：<a href="https://leetcode.cn/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof/solution/mian-shi-ti-03-shu-zu-zhong-zhong-fu-de-shu-zi-yua/">https://leetcode.cn/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof/solution/mian-shi-ti-03-shu-zu-zhong-zhong-fu-de-shu-zi-yua/</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findRepeatNumber</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        Set&lt;Integer&gt; dic = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> num : nums)&#123;<br>            <span class="hljs-keyword">if</span>(dic.contains(num)) <span class="hljs-keyword">return</span> num;<br>            dic.add(num);<br>        &#125;<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="方法二：原地交换-未理解透彻"><a href="#方法二：原地交换-未理解透彻" class="headerlink" title="方法二：原地交换(未理解透彻)"></a>方法二：原地交换(未理解透彻)</h4><p>&#x3D;&#x3D;方法二的解法有一个关键点是只有 nums[i] &#x3D;&#x3D; i 的时候i才递增，这样保证找到相同元素前不会漏掉某些元素的处理&#x3D;&#x3D;</p><p>&#x3D;&#x3D;没有任何重复的情况下，数组的每个下标i处存放的就是i值，这是“正确 ”的位置；&#x3D;&#x3D;</p><p>&#x3D;&#x3D;有重复，遍历时，前面的重复元素会放到它“正确”的位置上，后面一个重复元素在想要也放到该位置时，发现该位置已有“正确”元素了，即判断重复。&#x3D;&#x3D;</p><p>&#x3D;&#x3D;写的时候注意：要交换i，j元素的时候，i的值更新了还需要在下一次遍历中判断，此时i指针不动，只有当值在“正确”位置时，才将i右移一位&#x3D;&#x3D;</p><p>&#x3D;&#x3D;证明一下原地交换的核心算法。swap(nums, nums[i], nums[nums[i]]); 记 int b &#x3D; nums[nums[i]]; 这句话过后，第b个元素num[b] 一定等于b。。说明第b个元素已经放对位置。 证明： 记 int a &#x3D; nums[i]; 记 int b &#x3D; nums[nums[i]] &#x3D; nums[a]; 交换前 nums[a] &#x3D;&#x3D; b, nums[b] &#x3D;&#x3D; c； 交换后 nums[a] &#x3D;&#x3D; c, nums[b] &#x3D;&#x3D; b； 故 第b个元素num[b] 一定等于b。。说明第b个元素已经放对位置。 证毕&#x3D;&#x3D;</p><p>题目说明尚未被充分使用，即 在一个长度为 n 的数组 nums 里的所有数字都在 0 ~ n-1 的范围内 。 此说明含义：数组元素的 索引 和 值 是 一对多 的关系。<br>因此，可遍历数组并通过交换操作，使元素的 索引 与 值 一一对应（即 nums[i] &#x3D; i）。因而，就能通过索引映射对应的值，起到与字典等价的作用。</p><p>遍历中，第一次遇到数字 x 时，将其交换至索引 x 处；而当第二次遇到数字 x 时，一定有 nums[x] &#x3D; x ，此时即可得到一组重复数字。</p><p>算法流程：<br>遍历数组nums ，设索引初始值为 i &#x3D; 0 :</p><p>若 nums[i] &#x3D; i ： 说明此数字已在对应索引位置，无需交换，因此跳过；<br>若 nums[nums[i]] &#x3D; nums[i]： 代表索引 nums[i] 处和索引 i 处的元素值都为 nums[i] ，即找到一组重复值，返回此值 nums[i] ；<br>否则： 交换索引为 i和 nums[i] 的元素值，将此数字交换至对应索引位置。<br>若遍历完毕尚未返回，则返回 −1 。</p><p>复杂度分析：<br>时间复杂度 O(N) ： 遍历数组使用 O(N) ，每轮遍历的判断和交换操作使用 O(1) 。<br>空间复杂度 O(1) ： 使用常数复杂度的额外空间。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findRepeatNumber</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(i &lt; nums.length) &#123;<br>            <span class="hljs-keyword">if</span>(nums[i] == i) &#123;<br>                i++;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(nums[nums[i]] == nums[i]) <span class="hljs-keyword">return</span> nums[i];<br>            <span class="hljs-type">int</span> <span class="hljs-variable">tmp</span> <span class="hljs-operator">=</span> nums[i];<br>            nums[i] = nums[tmp];<br>            nums[tmp] = tmp;<br>        &#125;<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>每日一练</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>每日一练</tag>
      
      <tag>剑指offer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>每日一烤:简述Java中的异常</title>
    <link href="/2022/07/22/%E7%AE%80%E8%BF%B0Java%E5%BC%82%E5%B8%B8(%E4%BA%8C)/"/>
    <url>/2022/07/22/%E7%AE%80%E8%BF%B0Java%E5%BC%82%E5%B8%B8(%E4%BA%8C)/</url>
    
    <content type="html"><![CDATA[<h1 id="简述Java中的异常"><a href="#简述Java中的异常" class="headerlink" title="简述Java中的异常"></a>简述Java中的异常</h1><p>Java从Throwable直接派生出Exception和Error。</p><p>Exception又分为检查异常和运行时异常。</p><p>**典型的RuntimeException(运行时异常)**包括NullPointerException, ClassCastException(类型转换异常)，IndexOutOfBoundsException(越界异常), IllegalArgumentException(非法参数异常),ArrayStoreException(数组存储异常),AruthmeticException(算术异常),BufferOverflowException(缓冲区溢出异常)等；</p><p>**非RuntimeException(检查异常)**包括IOException, SQLException,InterruptedException(中断异常-调用线程睡眠时候),NumberFormatException(数字格式化异常)等。</p><h2 id="除此以外-还可以用另一种划分方式"><a href="#除此以外-还可以用另一种划分方式" class="headerlink" title="除此以外,还可以用另一种划分方式"></a>除此以外,还可以用另一种划分方式</h2><p>按照编译器检查方式划分，异常又可以分为检查型异常（CheckedException）和非检查型异常 （UncheckedException）。Error和RuntimeException合起来称为UncheckedException，之所以这么 称呼，是因为编译器不检查方法是否处理或者抛出这两种类型的异常，因此编译期间出现这种类型的异常也不会报错，默认由虚拟机提供处理方式。除了Error 和RuntimeException这两种类型的异常外，其它的异常都称为Checked异常。</p><h3 id="理解了检查型异常和非检查型异常的区别"><a href="#理解了检查型异常和非检查型异常的区别" class="headerlink" title="理解了检查型异常和非检查型异常的区别"></a>理解了检查型异常和非检查型异常的区别</h3><p>非检查型异常也就是运行时异常，对于运行时异常即使我们在一个方法上throws声明可能抛出异常，编译器也会检测到是运行时异常而不要求我们在主方法中必须处理；对于检查型异常我们throws声明之后也必须处理才可以编译通过。</p><p>*<em>对于SQLException之类的检查异常必须处理，否则会报错:</em></p><h2 id="Java如何处理异常"><a href="#Java如何处理异常" class="headerlink" title="Java如何处理异常"></a>Java如何处理异常</h2><h3 id="try-catch-try-finally-try-catch-finally"><a href="#try-catch-try-finally-try-catch-finally" class="headerlink" title="try-catch, try-finally, try-catch-finally"></a>try-catch, try-finally, try-catch-finally</h3><p>对于checked类型异常，我们要么对它进行处理，要么在方法头使用throws抛出。</p><p>关于catch需要注意的几点：</p><p>1)、参数的异常类型必须是Throwable类或者其子类。</p><p>2)、从上往下的catch语句，其参数类型必须按照从子类到父类顺序，因为一旦匹配到一个类型，就会忽略往后的catch。比如IOException必须放到Exception前面，否则编译器会报错。</p><p>3)、可以有一个或者多个catch语句，甚至如果有finally语句的情况下，可以没有catch语句，如try-finally。</p><p>想要捕获多个异常，可以使用多个catch语句，JDK7以后提供了另外一种方式：多重捕获（multi-catch)。</p><figure class="highlight java"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span>&#123;<br>    <span class="hljs-comment">// other code</span><br>&#125; <span class="hljs-keyword">catch</span> (IOException | SQLException ex) &#123;<br>    <span class="hljs-keyword">throw</span> ex;  <br>&#125;  <br></code></pre></td></tr></table></figure><p>4)、不要忽略异常。空的catch块会使异常达不到应有的目的，除非诸如关闭FileInputStream的时候，因为你还没有改变文件的状态，因此不必执行任何恢复动作，并且已经从文件中读取到所需要的信息，因此不用终止正在进行的操作。</p><p>关于finally需要注意的几点：</p><p>1)、finally中的代码总是会被执行，除非在执行try或者catch语句时虚拟机退出（System.exit(1))。</p><p>2)、finally块可以做一些资源清理工作，如关闭文件、关闭游标等操作。</p><p>3)、finally块不是必须的。</p><p>另外，如果在try和finally块中都执行了return语句，最终返回的将是finally中的return值。</p>]]></content>
    
    
    <categories>
      
      <category>每日一烤</category>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>每日一烤</tag>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>每日一练:剑指 Offer 05. 替换空格</title>
    <link href="/2022/07/21/%E5%89%91%E6%8C%87%20Offer%2005.%20%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC/"/>
    <url>/2022/07/21/%E5%89%91%E6%8C%87%20Offer%2005.%20%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC/</url>
    
    <content type="html"><![CDATA[<h1 id="剑指-Offer-05-替换空格"><a href="#剑指-Offer-05-替换空格" class="headerlink" title="剑指 Offer 05. 替换空格"></a><a href="https://leetcode.cn/problems/ti-huan-kong-ge-lcof/">剑指 Offer 05. 替换空格</a></h1><p>请实现一个函数，把字符串 s 中的每个空格替换成”%20”。</p><p>示例 1：</p><figure class="highlight perl"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><pre><code class="hljs perl">输入：s = <span class="hljs-string">&quot;We are happy.&quot;</span><br>输出：<span class="hljs-string">&quot;We%20are%20happy.&quot;</span><br></code></pre></td></tr></table></figure><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode.cn/problems/ti-huan-kong-ge-lcof">https://leetcode.cn/problems/ti-huan-kong-ge-lcof</a><br>方法一：遍历添加<br>在 Python 和 Java 等语言中，字符串都被设计成「不可变」的类型，即无法直接修改字符串的某一位字符，需要新建一个字符串实现。</p><p>算法流程：<br>初始化一个 list (Python) &#x2F; StringBuilder (Java) ，记为 res ；<br>遍历列表 s 中的每个字符 c ：<br>当 c 为空格时：向 res 后添加字符串 “%20” ；<br>当 c 不为空格时：向 res 后添加字符 c ；<br>将列表 res 转化为字符串并返回。<br>复杂度分析：<br>时间复杂度O(N) ： 遍历使用O(N) ，每轮添加（修改）字符操作使用O(1) ；<br>空间复杂度O(N) ： Python 新建的 list 和 Java 新建的 StringBuilder 都使用了线性大小的额外空间。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">replaceSpace</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>        <span class="hljs-keyword">for</span>(Character c : s.toCharArray())<br>        &#123;<br>            <span class="hljs-keyword">if</span>(c == <span class="hljs-string">&#x27; &#x27;</span>) res.append(<span class="hljs-string">&quot;%20&quot;</span>);<br>            <span class="hljs-keyword">else</span> res.append(c);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res.toString();<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>每日一练</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>每日一练</tag>
      
      <tag>剑指offer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>每日一烤:简述Java异常的分类</title>
    <link href="/2022/07/21/%E7%AE%80%E8%BF%B0Java%E5%BC%82%E5%B8%B8%E7%9A%84%E5%88%86%E7%B1%BB/"/>
    <url>/2022/07/21/%E7%AE%80%E8%BF%B0Java%E5%BC%82%E5%B8%B8%E7%9A%84%E5%88%86%E7%B1%BB/</url>
    
    <content type="html"><![CDATA[<h1 id="简述Java异常的分类"><a href="#简述Java异常的分类" class="headerlink" title="简述Java异常的分类"></a>简述Java异常的分类</h1><p><strong>Java异常分为Error（程序无法处理的错误），和Exception（程序本身可以处理的异常）。这两个类均 继承Throwable。</strong> </p><p><strong>Error常见的有StackOverFlowError,OutOfMemoryError等等。</strong> </p><p><strong>Exception可分为运行时异常和非运行时异常。对于运行时异常，可以利用try catch的方式进行处理，也 可以不处理。对于非运行时异常，必须处理，不处理的话程序无法通过编译。</strong></p><hr><p>更新于2022.7.26</p><h1 id="记录别人博客的提出的一个小问题-写出五个常见的运行时异常-RuntimeException"><a href="#记录别人博客的提出的一个小问题-写出五个常见的运行时异常-RuntimeException" class="headerlink" title="记录别人博客的提出的一个小问题:写出五个常见的运行时异常(RuntimeException)"></a>记录别人博客的提出的一个小问题:写出五个常见的运行时异常(RuntimeException)</h1><p>首先我们想到与之相对的一类异常:检查式异常(CheckedException)</p><p>检查式异常:顾名思义,就是让我们来检查(处理)异常,需要我们对代码块进行try catch去捕捉这些异常</p><p>运行时异常:顾名思义,运行时可以联想到Java虚拟机,毕竟当这种异常出现时,我们会把他交给Java虚拟机接管,比如：我们从来没有人去处理过NullPointerException异常，它就是运行时异常，并且这种异常还是最常见的异常之一。</p><p>答案:</p><ul><li>NullPointereException</li><li>ClassCastException</li><li>IndexOutBoundsException</li><li>BuffetOverflowException</li><li>ArrayStoreException</li></ul><p>既然写出来运行时异常,那就顺便写几个CheckedException</p><ul><li>SQLException</li><li>IOException</li><li>中断异常InterruptException</li><li>数字格式异常NumberFormatException</li></ul>]]></content>
    
    
    <categories>
      
      <category>每日一烤</category>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>每日一烤</tag>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>时间的女神(续)</title>
    <link href="/2022/07/20/%E6%97%B6%E9%97%B4%E7%9A%84%E5%A5%B3%E7%A5%9E(2)/"/>
    <url>/2022/07/20/%E6%97%B6%E9%97%B4%E7%9A%84%E5%A5%B3%E7%A5%9E(2)/</url>
    
    <content type="html"><![CDATA[<h1 id="时间的女神"><a href="#时间的女神" class="headerlink" title="时间的女神"></a>时间的女神</h1><h2 id="为什么有些人明明第一次见面，却总感觉似曾相识？"><a href="#为什么有些人明明第一次见面，却总感觉似曾相识？" class="headerlink" title="为什么有些人明明第一次见面，却总感觉似曾相识？"></a>为什么有些人明明第一次见面，却总感觉似曾相识？</h2><p>故事仍在继续</p><p>男人整理衣装,侧身看见妻子倚靠在窗边,忧郁地望着远方,男人再次望向妻子,妻子已消失在眼帘,只留窗帘在风中摇晃</p><p>男子跑到窗边探出身子望去,不见妻子的身影,一转身,妻子出现在男人的身后,仍是身穿着那一袭素雅的白衣,不同的是,手里握着一朵花,点缀的恰到好处.</p><p>“这是我最喜欢的花,一个很棒的人送给我的”妻子说到.</p><p>“你不在家的时候,一个人会感到难过,这个手指就是我,中指便是你,两根手指轻靠在一起,这样我会有一种被你拥抱着的感觉”</p><p>“我永远不会离开你”男人抱紧妻子,安慰道.</p><p>两个人即使再怎么相爱,也不意味着永远能够不分离,即使有一个幸福的家庭,有一个可爱的女孩.</p><p>妻子生病重病,躺在了病床上.</p><p>在妻子的弥留之际,男人回想往事,向妻子袒露出自己的秘密.</p><p>“我想我以前见过一个和你长得一模一样的一个女人,一次是孩时在学校附近,另一次是大学,她和你穿着一样的白色衣服,肩膀上垂着长发”</p><p>“无论是哪一次,那都是我啊”即使生病了,妻子仍是那样恬静的看着丈夫,笑着说到.</p><p>男人似乎有点震惊,但片刻便又平静,他知道,这或许是妻子的美丽玩笑吧,但他还是配合着妻子的游戏,假装不解的问到</p><p>“那你就不会老吗?”</p><p>妻子深情地对男人说:”当然会变老呀,不过我可以自由的在时空中穿梭,过去和未来都可以去,我可是在你小时候就一直看着你呢.”</p><p>“那你看过我们的未来吗”男人像和幼稚地孩童玩过家家一样,配合着妻子,假装好奇的问到,不愿意破坏此刻美好地氛围.</p><p>“有啊”</p><p>“那我们地未来是什么样的呢?”</p><p>“嘘,这是不能说的秘密”妻子将指尖轻置在嘴边说到.</p><p>下一个镜头是离别的场景,男人哭着望向病床上的妻子.</p><p>在弥留之际,妻子又一次将食指与中指靠在了一起,”无论何时,我都陪在你的身边”,这是妻子对男人说的最后一句话.</p><p>妻子离开后的许多年里,男人总是一个人像曾经的妻子一样,呆呆地站在窗边,犹豫地望着远方,每当男人想念妻子时,便会将食指与中指靠在一起.</p><p>“两根手指轻靠在一起,这样我会有一种被你拥抱着的感觉”对男人而言,妻子的话语仿佛就在昨天,久久不能忘怀.</p><p>“那你看过我们的未来吗””有啊”</p><p>或许是因为妻子的离开,男人反而相信妻子开的玩笑.此后的许多年,男人一直盼望着妻子能够在他的时空与穿梭时间妻子再次相遇.</p><p>他悔恨,自己一定是错过了,也许妻子来了他也未曾发现.</p><p>又是一个乞巧节的傍晚,男人接送女儿放学,路过一家花店,男人决定买一束花,打量了一番,男人选中了一株红色菊花.</p><p>刹那间,男人有点恍惚,这一株菊花似曾相识.</p><p>&lt;&lt;我爱你&gt;&gt;的bgm响起,镜头旋转至男人背后,不远处的街道对面,那一袭白衣,那一个白衣女子,远远的看着自己,亲切的微笑着.</p><p>那难以诉说的神情,恬淡的笑,以及一袭白衣,仿佛把时光又拉回到从前.</p><p>“这是我最喜欢的花,一个很棒的人送给我的”</p><p>“你不在家的时候,一个人会感到难过,这个手指就是我,中指便是你,两根手指轻靠在一起,这样我会有一种被你拥抱着的感觉”</p><p>“我永远不会离开你”</p><p>ps:Ayasa绚沙-我爱你,这首bgm响起了的时候真的是泪目了,可以听一听.</p>]]></content>
    
    
    <categories>
      
      <category>随笔</category>
      
      <category>观后有感</category>
      
    </categories>
    
    
    <tags>
      
      <tag>随笔</tag>
      
      <tag>观后有感</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>每日一烤:接口和抽象类有什么区别？</title>
    <link href="/2022/07/20/%E6%8E%A5%E5%8F%A3%E5%92%8C%E6%8A%BD%E8%B1%A1%E7%B1%BB%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB/"/>
    <url>/2022/07/20/%E6%8E%A5%E5%8F%A3%E5%92%8C%E6%8A%BD%E8%B1%A1%E7%B1%BB%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="02fcfd9cf8cb962c2249b712b16e13f1bbc3edec179edd9d2f8aff81a1102f81">8268f298bea1fc280361734c91dc3b4f8baf77409158563ecf32600f2af35f76683f29e3f545b4b36f405fb81d04688be7e73177f15143c52cfa36c709266b295db67b6a7065afe84f67745142c7f109004de364f871718acaeb7cdc34f924e20005855b47a226e3deb704fd65a5bbe30279092acd6bea643cef79f1d287390a05ad27d6cb5fef8544f77488a3f64913bab65ca856b43b020e696134b94c9124ee62d11e0c794581aca35c92b65a26848c6b34fe433318d2b213f101d3155d592a70c8f9f50759023f544a8683885d65d99d296178fff723e2f541022e048c85c7b2c377bafb6e2defbea5e7f28908d838837f68b145f9890c6f1b3df41be9a7c04f17f5d39e53b173e070839bdf35ac2345c958136a29fad66ec83cee56ea7cfdce10fe17f9abc992d403ad4c9c0af21f836343da8f6512d13d5f62c9af008fe8823ebbfe6c1f0b245fd62d03b92f92cad0b88d33ae5225d13e6b0003612637fdf0a88b54b353ac8b5be8b90ff970b24def97add6b575f392c168d8922fd3d1ef8e53af4384b8c54c6549a06036bbf12b37c74720b2051e03641cabf10546f80c29214ce44a9d1164c408c3658e0b2d66820f12ff3b7f2494432e16dc2bbc2f8b165d7901c3c44e600c1352493becb36703a053ccbc0109061120a85a45b2b147d9a070b73b847f53831c6767c1ed20ba4b44dd9c00e4a8b1588f5a088031247216900f5e716058409f76c98e7e9e9ed661aacee52d4b980adbf2cb2a000dd70a270399f2990c848cd681cb6721c54b3096a707cb5d492d69147ef22f8015475dd705c53d8339ba462aa1d5b267d547d86a598cca5da280cede730007ae57ea94b3ec4bd8924f890a253629a0ce5fcfc765ef41869a3fe6bcb1079acd05b64e0029262aa8927b9b628f02a516ebffe5b31906aa6e132f0fcd1c380789194beb83e148930911d52f6704c6ae687c69e7</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <categories>
      
      <category>每日一烤</category>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>每日一烤</tag>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>每日一练:剑指 Offer 30. 包含min函数的栈</title>
    <link href="/2022/07/20/%E5%89%91%E6%8C%87%20Offer%2030.%20%E5%8C%85%E5%90%ABmin%E5%87%BD%E6%95%B0%E7%9A%84%E6%A0%88/"/>
    <url>/2022/07/20/%E5%89%91%E6%8C%87%20Offer%2030.%20%E5%8C%85%E5%90%ABmin%E5%87%BD%E6%95%B0%E7%9A%84%E6%A0%88/</url>
    
    <content type="html"><![CDATA[<h1 id="剑指-Offer-30-包含min函数的栈"><a href="#剑指-Offer-30-包含min函数的栈" class="headerlink" title="剑指 Offer 30. 包含min函数的栈"></a><a href="https://leetcode.cn/problems/bao-han-minhan-shu-de-zhan-lcof/">剑指 Offer 30. 包含min函数的栈</a></h1><p>定义栈的数据结构，请在该类型中实现一个能够得到栈的最小元素的 min 函数在该栈中，调用 min、push 及 pop 的时间复杂度都是 O(1)。</p><p>示例:</p><figure class="highlight abnf"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><pre><code class="hljs abnf">MinStack minStack <span class="hljs-operator">=</span> new MinStack()<span class="hljs-comment">;</span><br>minStack.push(-<span class="hljs-number">2</span>)<span class="hljs-comment">;</span><br>minStack.push(<span class="hljs-number">0</span>)<span class="hljs-comment">;</span><br>minStack.push(-<span class="hljs-number">3</span>)<span class="hljs-comment">;</span><br>minStack.min()<span class="hljs-comment">;   --&gt; 返回 -3.</span><br>minStack.pop()<span class="hljs-comment">;</span><br>minStack.top()<span class="hljs-comment">;      --&gt; 返回 0.</span><br>minStack.min()<span class="hljs-comment">;   --&gt; 返回 -2.</span><br></code></pre></td></tr></table></figure><p>提示：</p><p>各函数的调用总次数不超过 20000 次</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode.cn/problems/bao-han-minhan-shu-de-zhan-lcof">https://leetcode.cn/problems/bao-han-minhan-shu-de-zhan-lcof</a></p><p>解题思路：</p><h4 id="普通栈的-push-和-pop-函数的复杂度为-O-1-O-1-；而获取栈最小值-min-函数需要遍历整个栈，复杂度为-O-N-O-N-。"><a href="#普通栈的-push-和-pop-函数的复杂度为-O-1-O-1-；而获取栈最小值-min-函数需要遍历整个栈，复杂度为-O-N-O-N-。" class="headerlink" title="普通栈的 push() 和 pop() 函数的复杂度为 O(1)O(1) ；而获取栈最小值 min() 函数需要遍历整个栈，复杂度为 O(N)O(N) 。"></a>普通栈的 push() 和 pop() 函数的复杂度为 O(1)O(1) ；而获取栈最小值 min() 函数需要遍历整个栈，复杂度为 O(N)O(N) 。</h4><p>本题难点： 将 min() 函数复杂度降为 O(1)O(1) ，可通过建立辅助栈实现；<br>数据栈 A ： 栈 A 用于存储所有元素，保证入栈 push() 函数、出栈 pop() 函数、获取栈顶 top() 函数的正常逻辑。<br>&#x3D;&#x3D;辅助栈 B ： 栈 B 中存储栈 A中所有 非严格降序 的元素，则栈 A 中的最小元素始终对应栈 B 的栈顶元素，即 min() 函数只需返回栈 B 的栈顶元素即可。&#x3D;&#x3D;<br>&#x3D;&#x3D;因此，只需设法维护好 栈 B 的元素，使其保持非严格降序，即可实现 min() 函数的 O(1)O(1) 复杂度。&#x3D;&#x3D;</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MinStack</span> &#123;<br>    Stack&lt;Integer&gt; A, B;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MinStack</span><span class="hljs-params">()</span> &#123;<br>        A = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;&gt;();<br>        B = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;&gt;();<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">push</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> &#123;<br>        A.add(x);<br>        <span class="hljs-keyword">if</span>(B.empty() || B.peek() &gt;= x)<br>            B.add(x);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">pop</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span>(A.pop().equals(B.peek()))<span class="hljs-comment">//关键步骤,如果pop是min,记得要把B栈一起pop出,毕竟B是用来存min的</span><br>            B.pop();<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">top</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> A.peek();<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">min</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> B.peek();<br>    &#125;<br>&#125;<br><br>作者：jyd<br>链接：https:<span class="hljs-comment">//leetcode.cn/problems/bao-han-minhan-shu-de-zhan-lcof/solution/mian-shi-ti-30-bao-han-minhan-shu-de-zhan-fu-zhu-z/</span><br>来源：力扣（LeetCode）<br></code></pre></td></tr></table></figure><p>第二种方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MinStack</span> &#123;<br>    <span class="hljs-keyword">public</span> Node node;<br>    <span class="hljs-comment">/** initialize your data structure here. */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MinStack</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">push</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> &#123;<br><br>       <span class="hljs-keyword">if</span> (node == <span class="hljs-literal">null</span>)<br>            node = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(x, x, <span class="hljs-literal">null</span>);<br>        <span class="hljs-keyword">else</span><br>            node = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(x, Math.min(node.min, x), node);<span class="hljs-comment">//关键步骤</span><br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">pop</span><span class="hljs-params">()</span> &#123;<br>        node = node.next;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">top</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> node.value;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">min</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> node.min;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span> &#123;<br>         <span class="hljs-type">int</span> value;<br>         <span class="hljs-type">int</span> min;<br>         Node next;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">Node</span><span class="hljs-params">(<span class="hljs-type">int</span> value,<span class="hljs-type">int</span> min,Node next)</span>&#123;<br>            <span class="hljs-built_in">this</span>.value = value;<br>            <span class="hljs-built_in">this</span>.min = min;<br>            <span class="hljs-built_in">this</span>.next = next;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your MinStack object will be instantiated and called as such:</span><br><span class="hljs-comment"> * MinStack obj = new MinStack();</span><br><span class="hljs-comment"> * obj.push(x);</span><br><span class="hljs-comment"> * obj.pop();</span><br><span class="hljs-comment"> * int param_3 = obj.top();</span><br><span class="hljs-comment"> * int param_4 = obj.min();</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>每日一练</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>每日一练</tag>
      
      <tag>剑指offer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>每日一练:剑指 Offer 09. 用两个栈实现队列</title>
    <link href="/2022/07/19/%E5%89%91%E6%8C%87%20Offer%2009.%20%E7%94%A8%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/"/>
    <url>/2022/07/19/%E5%89%91%E6%8C%87%20Offer%2009.%20%E7%94%A8%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<h1 id="剑指-Offer-09-用两个栈实现队列"><a href="#剑指-Offer-09-用两个栈实现队列" class="headerlink" title="剑指 Offer 09. 用两个栈实现队列"></a><a href="https://leetcode.cn/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof/">剑指 Offer 09. 用两个栈实现队列</a></h1><p>用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 appendTail 和 deleteHead ，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，deleteHead 操作返回 -1 )</p><p>示例 1：</p><p>输入：</p><figure class="highlight prolog"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><pre><code class="hljs prolog">[<span class="hljs-string">&quot;CQueue&quot;</span>,<span class="hljs-string">&quot;appendTail&quot;</span>,<span class="hljs-string">&quot;deleteHead&quot;</span>,<span class="hljs-string">&quot;deleteHead&quot;</span>]<br>[[],[<span class="hljs-number">3</span>],[],[]]<br>输出：[null,null,<span class="hljs-number">3</span>,<span class="hljs-number">-1</span>]<br></code></pre></td></tr></table></figure><p>示例 2：</p><p>示例 2：</p><p>输入：</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs prolog">[<span class="hljs-string">&quot;CQueue&quot;</span>,<span class="hljs-string">&quot;deleteHead&quot;</span>,<span class="hljs-string">&quot;appendTail&quot;</span>,<span class="hljs-string">&quot;appendTail&quot;</span>,<span class="hljs-string">&quot;deleteHead&quot;</span>,<span class="hljs-string">&quot;deleteHead&quot;</span>]<br>[[],[],[<span class="hljs-number">5</span>],[<span class="hljs-number">2</span>],[],[]]<br>输出：[null,<span class="hljs-number">-1</span>,null,null,<span class="hljs-number">5</span>,<span class="hljs-number">2</span>]<br></code></pre></td></tr></table></figure><p>提示：</p><p>提示：</p><p>1 &lt;&#x3D; values &lt;&#x3D; 10000<br>最多会对 appendTail、deleteHead 进行 10000 次调用<br>通过次数445,954提交次数630,208</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode.cn/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof">https://leetcode.cn/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof</a></p><p>解题思路：<br>栈无法实现队列功能： 栈底元素（对应队首元素）无法直接删除，需要将上方所有元素出栈。<br>双栈可实现列表倒序： 设有含三个元素的栈 A &#x3D; [1,2,3]A&#x3D;[1,2,3] 和空栈 B &#x3D; []B&#x3D;[]。若循环执行 AA 元素出栈并添加入栈 BB ，直到栈 AA 为空，则 A &#x3D; []A&#x3D;[] , B &#x3D; [3,2,1]B&#x3D;[3,2,1] ，即 栈 BB 元素实现栈 AA 元素倒序 。<br>利用栈 BB 删除队首元素： 倒序后，BB 执行出栈则相当于删除了 AA 的栈底元素，即对应队首元素。</p><p>函数设计：<br>题目只要求实现 加入队尾appendTail() 和 删除队首deleteHead() 两个函数的正常工作，因此我们可以设计栈 A 用于加入队尾操作，栈 B 用于将元素倒序，从而实现删除队首元素。</p><p>加入队尾 appendTail()函数： 将数字 val 加入栈 A 即可。<br>删除队首deleteHead()函数： 有以下三种情况。<br>当栈 B 不为空： B中仍有已完成倒序的元素，因此直接返回 B 的栈顶元素。<br>否则，当 A 为空： 即两个栈都为空，无元素，因此返回 -1−1 。<br>否则： 将栈 A 元素全部转移至栈 B 中，实现元素倒序，并返回栈 B 的栈顶元素。</p><p>详解链接(<a href="https://leetcode.cn/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof/solution/mian-shi-ti-09-yong-liang-ge-zhan-shi-xian-dui-l-2/">面试题09. 用两个栈实现队列（清晰图解） - 用两个栈实现队列 - 力扣（LeetCode）</a>)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">CQueue</span> &#123;<br>    <span class="hljs-keyword">private</span> Stack&lt;Integer&gt; stack1;<br>    <span class="hljs-keyword">private</span> Stack&lt;Integer&gt; stack2;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">CQueue</span><span class="hljs-params">()</span> &#123;<br>        stack1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;Integer&gt; ();<br>        stack2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;&gt; ();<br><br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">appendTail</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span> &#123;<br>         stack1.push(value);<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">deleteHead</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span>(!stack2.isEmpty())&#123;<br>            <span class="hljs-keyword">return</span> stack2.pop();<br>            <span class="hljs-comment">//已经将栈stack1中数据回压至stack2(stack1倒序),stack2.pop弹出栈2顶元素则输出stack1栈底元素            </span><br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">while</span>(!stack1.isEmpty())&#123;<br>                    stack2.push(stack1.pop());<br>                &#125;<span class="hljs-comment">//未将栈stack1中数据回压至stack2(stack1倒序),所以执行while代码块完成将栈stack1中数据回压至stack2(stack1倒序)</span><br>                <span class="hljs-keyword">return</span> stack2.isEmpty()? -<span class="hljs-number">1</span> : stack2.pop();<br>            &#125;<br>            <span class="hljs-comment">//总归要输出-1或者stack2.pop()</span><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your CQueue object will be instantiated and called as such:</span><br><span class="hljs-comment"> * CQueue obj = new CQueue();</span><br><span class="hljs-comment"> * obj.appendTail(value);</span><br><span class="hljs-comment"> * int param_2 = obj.deleteHead();</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>每日一练</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>每日一练</tag>
      
      <tag>剑指offer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>时间的女神</title>
    <link href="/2022/07/19/%E6%97%B6%E9%97%B4%E7%9A%84%E5%A5%B3%E7%A5%9E/"/>
    <url>/2022/07/19/%E6%97%B6%E9%97%B4%E7%9A%84%E5%A5%B3%E7%A5%9E/</url>
    
    <content type="html"><![CDATA[<h1 id="时间的女神"><a href="#时间的女神" class="headerlink" title="时间的女神"></a>时间的女神</h1><h2 id="为什么有些人明明第一次见面，却总感觉似曾相识？"><a href="#为什么有些人明明第一次见面，却总感觉似曾相识？" class="headerlink" title="为什么有些人明明第一次见面，却总感觉似曾相识？"></a>为什么有些人明明第一次见面，却总感觉似曾相识？</h2><p>第一次看这部短片,觉得画质过于”复古”,实在难以欣赏这上个世纪的老古董,但片尾bgm响起的一刹那,我承认我的眼睛已经湿润了,后来我才了解到这是世界奇妙物语在94年情人节的特供篇,哈哈,年龄竟然比我还大不少.故事讲了柳叶敏郎饰演的男主在童年时放学路上看到了一个白衣女子，远远看着自己，亲切地微笑。</p><p>故事开始在七巧节,放学的路上,小男孩,也就是我们的主人公,走在路上,远处一个白衣女子,远远的看着自己,亲切的微笑着,难以诉说的神情,恬淡的笑,以及那一袭白衣,仿佛是天使,仿佛是古典画中的的女神,可是,在男孩和屏幕前的我们看来,这笑容虽恬淡亲切,但却显得无缘无故.</p><p>男孩回到家,久久难以忘怀,用铅笔在作业本上悄悄画出了女人的模样,在七巧节的许愿牌上，男孩写悄悄许下想再次见到这白衣女郎的心愿.接下来的几年男孩都并未能再见,在男孩心中,白衣女神伴随着男孩慢慢长大.</p><p>中学时,或许是难以忘记白衣女神,他与一位同样穿着白衣服的女孩恋爱了,但或许也是因为难以忘记白衣女神,这一段恋情草草收场.</p><p>大学时的某一天,又是那一袭白衣,又是那恬淡的笑,还像当初那样,女人只是远远的看着自己,亲切的微笑,可他猛然转过身时,女人已经不见,他不敢相信,十多年过去了,女人还是如当初那般美丽,并未有任何容貌的变化,这似乎是幻觉,可即使是这样,在此之后,男孩再也没有恋爱的想法,明明知道这是不可能的事,男孩还是决定等待下一次见面.</p><p>又过了十年,他已不再是个男孩,在此期间,他对身穿白衣的女子总是很在意,但每一次都会失望,直至某一天,雨后的屋檐,和他一起躲雨的白衣女人的身影和他脑海中白衣女神完美重合,男主常感到不可思议,她仿佛就是心中的白衣女神,可是,他也知道,这不太可能,但他唯一可以确定的是,他很爱她,这一次,恋爱,结婚,生子,一切都很自然,一切都那么美好</p>]]></content>
    
    
    <categories>
      
      <category>随笔</category>
      
      <category>观后有感</category>
      
    </categories>
    
    
    <tags>
      
      <tag>随笔</tag>
      
      <tag>观后有感</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>每日一烤:final、finally和finalize的区别是什么？</title>
    <link href="/2022/07/19/final,finally%E5%92%8Cfinalize%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <url>/2022/07/19/final,finally%E5%92%8Cfinalize%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<h1 id="final、finally和finalize的区别是什么？"><a href="#final、finally和finalize的区别是什么？" class="headerlink" title="final、finally和finalize的区别是什么？"></a>final、finally和finalize的区别是什么？</h1><ol><li><h4 id="final用于声明属性、方法和类，分别表示属性不可变、方法不可覆盖、类不可继承。"><a href="#final用于声明属性、方法和类，分别表示属性不可变、方法不可覆盖、类不可继承。" class="headerlink" title="final用于声明属性、方法和类，分别表示属性不可变、方法不可覆盖、类不可继承。"></a>final用于声明属性、方法和类，分别表示属性不可变、方法不可覆盖、类不可继承。</h4></li><li><h4 id="finally作为异常处理的一部分，只能在try-x2F-catch语句中使用，finally附带一个语句块用来表示这个语-句最终一定被执行，经常被用在需要释放资源的情况下。"><a href="#finally作为异常处理的一部分，只能在try-x2F-catch语句中使用，finally附带一个语句块用来表示这个语-句最终一定被执行，经常被用在需要释放资源的情况下。" class="headerlink" title="finally作为异常处理的一部分，只能在try&#x2F;catch语句中使用，finally附带一个语句块用来表示这个语 句最终一定被执行，经常被用在需要释放资源的情况下。"></a>finally作为异常处理的一部分，只能在try&#x2F;catch语句中使用，finally附带一个语句块用来表示这个语 句最终一定被执行，经常被用在需要释放资源的情况下。</h4></li><li><h4 id="finalize是Object类的一个方法，在垃圾收集器执行的时候会调用被回收对象的finalize-方法。当垃-圾回收器准备好释放对象占用空间时，首先会调用finalize-方法，并在下一次垃圾回收动作发生时-真正回收对象占用的内存。"><a href="#finalize是Object类的一个方法，在垃圾收集器执行的时候会调用被回收对象的finalize-方法。当垃-圾回收器准备好释放对象占用空间时，首先会调用finalize-方法，并在下一次垃圾回收动作发生时-真正回收对象占用的内存。" class="headerlink" title="finalize是Object类的一个方法，在垃圾收集器执行的时候会调用被回收对象的finalize()方法。当垃 圾回收器准备好释放对象占用空间时，首先会调用finalize()方法，并在下一次垃圾回收动作发生时 真正回收对象占用的内存。"></a>finalize是Object类的一个方法，在垃圾收集器执行的时候会调用被回收对象的finalize()方法。当垃 圾回收器准备好释放对象占用空间时，首先会调用finalize()方法，并在下一次垃圾回收动作发生时 真正回收对象占用的内存。</h4></li></ol>]]></content>
    
    
    <categories>
      
      <category>每日一烤</category>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>每日一烤</tag>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>每日一烤:简述泛型擦除</title>
    <link href="/2022/07/18/%E7%AE%80%E8%BF%B0%E6%B3%9B%E5%9E%8B%E6%93%A6%E9%99%A4/"/>
    <url>/2022/07/18/%E7%AE%80%E8%BF%B0%E6%B3%9B%E5%9E%8B%E6%93%A6%E9%99%A4/</url>
    
    <content type="html"><![CDATA[<h1 id="简述泛型擦除"><a href="#简述泛型擦除" class="headerlink" title="简述泛型擦除"></a>简述泛型擦除</h1><h3 id="Java编译器生成的字节码是不包涵泛型信息的，泛型类型信息将在编译处理是被擦除，这个过程被称为-泛型擦除。"><a href="#Java编译器生成的字节码是不包涵泛型信息的，泛型类型信息将在编译处理是被擦除，这个过程被称为-泛型擦除。" class="headerlink" title="Java编译器生成的字节码是不包涵泛型信息的，泛型类型信息将在编译处理是被擦除，这个过程被称为 泛型擦除。"></a>Java编译器生成的字节码是不包涵泛型信息的，泛型类型信息将在编译处理是被擦除，这个过程被称为 泛型擦除。</h3>]]></content>
    
    
    <categories>
      
      <category>每日一烤</category>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>每日一烤</tag>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>每日一烤:简述泛型</title>
    <link href="/2022/07/17/%E7%AE%80%E8%BF%B0%E6%B3%9B%E5%9E%8B/"/>
    <url>/2022/07/17/%E7%AE%80%E8%BF%B0%E6%B3%9B%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="简述泛型"><a href="#简述泛型" class="headerlink" title="简述泛型"></a>简述泛型</h1><h3 id="泛型，即“参数化类型”，解决不确定对象具体类型的问题。在编译阶段有效。在泛型使用过程中，操作-的数据类型被指定为一个参数，这种参数类型在类中称为泛型类、接口中称为泛型接口和方法中称为泛-型方法。"><a href="#泛型，即“参数化类型”，解决不确定对象具体类型的问题。在编译阶段有效。在泛型使用过程中，操作-的数据类型被指定为一个参数，这种参数类型在类中称为泛型类、接口中称为泛型接口和方法中称为泛-型方法。" class="headerlink" title="泛型，即“参数化类型”，解决不确定对象具体类型的问题。在编译阶段有效。在泛型使用过程中，操作 的数据类型被指定为一个参数，这种参数类型在类中称为泛型类、接口中称为泛型接口和方法中称为泛 型方法。"></a>泛型，即“参数化类型”，解决不确定对象具体类型的问题。在编译阶段有效。在泛型使用过程中，操作 的数据类型被指定为一个参数，这种参数类型在类中称为泛型类、接口中称为泛型接口和方法中称为泛 型方法。</h3>]]></content>
    
    
    <categories>
      
      <category>每日一烤</category>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>每日一烤</tag>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>每日一烤:简述java的多态</title>
    <link href="/2022/07/16/%E7%AE%80%E8%BF%B0Java%E5%A4%9A%E6%80%81/"/>
    <url>/2022/07/16/%E7%AE%80%E8%BF%B0Java%E5%A4%9A%E6%80%81/</url>
    
    <content type="html"><![CDATA[<h1 id="简述java的多态"><a href="#简述java的多态" class="headerlink" title="简述java的多态"></a>简述java的多态</h1><h3 id="Java多态可以分为编译时多态和运行时多态。"><a href="#Java多态可以分为编译时多态和运行时多态。" class="headerlink" title="Java多态可以分为编译时多态和运行时多态。"></a>Java多态可以分为编译时多态和运行时多态。</h3><h3 id="编译时多态主要指方法的重载，即通过参数列表的不同来区分不同的方法。"><a href="#编译时多态主要指方法的重载，即通过参数列表的不同来区分不同的方法。" class="headerlink" title="编译时多态主要指方法的重载，即通过参数列表的不同来区分不同的方法。"></a>编译时多态主要指方法的重载，即通过参数列表的不同来区分不同的方法。</h3><h3 id="运行时多态主要指继承父类和实现接口时，可使用父类引用指向子类对象。"><a href="#运行时多态主要指继承父类和实现接口时，可使用父类引用指向子类对象。" class="headerlink" title="运行时多态主要指继承父类和实现接口时，可使用父类引用指向子类对象。"></a>运行时多态主要指继承父类和实现接口时，可使用父类引用指向子类对象。</h3><h3 id="运行时多态的实现：主要依靠方法表，方法表中最先存放的是Object类的方法，接下来是该类的父类的-方法，最后是该类本身的方法。如果子类改写了父类的方法，那么子类和父类的那些同名方法共享一个-方法表项，都被认作是父类的方法。因此可以实现运行时多态。"><a href="#运行时多态的实现：主要依靠方法表，方法表中最先存放的是Object类的方法，接下来是该类的父类的-方法，最后是该类本身的方法。如果子类改写了父类的方法，那么子类和父类的那些同名方法共享一个-方法表项，都被认作是父类的方法。因此可以实现运行时多态。" class="headerlink" title="运行时多态的实现：主要依靠方法表，方法表中最先存放的是Object类的方法，接下来是该类的父类的 方法，最后是该类本身的方法。如果子类改写了父类的方法，那么子类和父类的那些同名方法共享一个 方法表项，都被认作是父类的方法。因此可以实现运行时多态。"></a>运行时多态的实现：主要依靠方法表，方法表中最先存放的是Object类的方法，接下来是该类的父类的 方法，最后是该类本身的方法。如果子类改写了父类的方法，那么子类和父类的那些同名方法共享一个 方法表项，都被认作是父类的方法。因此可以实现运行时多态。</h3>]]></content>
    
    
    <categories>
      
      <category>每日一烤</category>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>每日一烤</tag>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>每日一烤:简述重载与重写的区别</title>
    <link href="/2022/07/15/%E7%AE%80%E8%BF%B0%E9%87%8D%E8%BD%BD%E4%B8%8E%E9%87%8D%E5%86%99%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <url>/2022/07/15/%E7%AE%80%E8%BF%B0%E9%87%8D%E8%BD%BD%E4%B8%8E%E9%87%8D%E5%86%99%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<h3 id="简述重载与重写的区别"><a href="#简述重载与重写的区别" class="headerlink" title="简述重载与重写的区别"></a>简述重载与重写的区别</h3><h3 id="重写即子类重写父类的方法，方法对应的形参和返回值类型都不能变。"><a href="#重写即子类重写父类的方法，方法对应的形参和返回值类型都不能变。" class="headerlink" title="重写即子类重写父类的方法，方法对应的形参和返回值类型都不能变。"></a>重写即子类重写父类的方法，方法对应的形参和返回值类型都不能变。</h3><h3 id="重载即在一个类中，方法名相同，参数类型或数量不同。"><a href="#重载即在一个类中，方法名相同，参数类型或数量不同。" class="headerlink" title="重载即在一个类中，方法名相同，参数类型或数量不同。"></a>重载即在一个类中，方法名相同，参数类型或数量不同。</h3>]]></content>
    
    
    <categories>
      
      <category>每日一烤</category>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>每日一烤</tag>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>每日一烤:Java提供的多态机制</title>
    <link href="/2022/07/14/Java%E7%9A%84%E5%A4%9A%E6%80%81%E6%9C%BA%E5%88%B6/"/>
    <url>/2022/07/14/Java%E7%9A%84%E5%A4%9A%E6%80%81%E6%9C%BA%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="Java提供的多态机制？"><a href="#Java提供的多态机制？" class="headerlink" title="Java提供的多态机制？"></a>Java提供的多态机制？</h1><h3 id="Java提供了两种用于多态的机制，分别是重载与覆盖。"><a href="#Java提供了两种用于多态的机制，分别是重载与覆盖。" class="headerlink" title="Java提供了两种用于多态的机制，分别是重载与覆盖。"></a>Java提供了两种用于多态的机制，分别是重载与覆盖。</h3><h3 id="1-重载：重载是指同一个类中有多个同名的方法，但这些方法有不同的参数，在编译期间就可以确定-调用哪个方法。"><a href="#1-重载：重载是指同一个类中有多个同名的方法，但这些方法有不同的参数，在编译期间就可以确定-调用哪个方法。" class="headerlink" title="1. 重载：重载是指同一个类中有多个同名的方法，但这些方法有不同的参数，在编译期间就可以确定 调用哪个方法。"></a>1. 重载：重载是指同一个类中有多个同名的方法，但这些方法有不同的参数，在编译期间就可以确定 调用哪个方法。</h3><h3 id="2-覆盖：覆盖是指派生类重写基类的方法，使用基类指向其子类的实例对象，或接口的引用变量指向-其实现类的实例对象，在程序调用的运行期根据引用变量所指的具体实例对象调用正在运行的那个-对象的方法，即需要到运行期才能确定调用哪个方法。"><a href="#2-覆盖：覆盖是指派生类重写基类的方法，使用基类指向其子类的实例对象，或接口的引用变量指向-其实现类的实例对象，在程序调用的运行期根据引用变量所指的具体实例对象调用正在运行的那个-对象的方法，即需要到运行期才能确定调用哪个方法。" class="headerlink" title="2. 覆盖：覆盖是指派生类重写基类的方法，使用基类指向其子类的实例对象，或接口的引用变量指向 其实现类的实例对象，在程序调用的运行期根据引用变量所指的具体实例对象调用正在运行的那个 对象的方法，即需要到运行期才能确定调用哪个方法。"></a>2. 覆盖：覆盖是指派生类重写基类的方法，使用基类指向其子类的实例对象，或接口的引用变量指向 其实现类的实例对象，在程序调用的运行期根据引用变量所指的具体实例对象调用正在运行的那个 对象的方法，即需要到运行期才能确定调用哪个方法。</h3>]]></content>
    
    
    <categories>
      
      <category>每日一烤</category>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>每日一烤</tag>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>每日一烤:字节序定义以及Java属于哪种字节序</title>
    <link href="/2022/07/13/%E5%AD%97%E8%8A%82%E5%BA%8F%E5%AE%9A%E4%B9%89%E4%BB%A5%E5%8F%8AJava%E5%B1%9E%E4%BA%8E%E5%93%AA%E7%A7%8D%E5%AD%97%E8%8A%82%E5%BA%8F/"/>
    <url>/2022/07/13/%E5%AD%97%E8%8A%82%E5%BA%8F%E5%AE%9A%E4%B9%89%E4%BB%A5%E5%8F%8AJava%E5%B1%9E%E4%BA%8E%E5%93%AA%E7%A7%8D%E5%AD%97%E8%8A%82%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="字节序定义以及Java属于哪种字节序？"><a href="#字节序定义以及Java属于哪种字节序？" class="headerlink" title="字节序定义以及Java属于哪种字节序？"></a>字节序定义以及Java属于哪种字节序？</h1><h3 id="字节序是指多字节数据在计算机内存中存储或网络传输时个字节的存储顺序。通常由小端和大端两组方-式。"><a href="#字节序是指多字节数据在计算机内存中存储或网络传输时个字节的存储顺序。通常由小端和大端两组方-式。" class="headerlink" title="字节序是指多字节数据在计算机内存中存储或网络传输时个字节的存储顺序。通常由小端和大端两组方 式。"></a>字节序是指多字节数据在计算机内存中存储或网络传输时个字节的存储顺序。通常由小端和大端两组方 式。</h3><h3 id="1-小端-低位字节存放在内存的低地址端，高位字节存放在内存的高地址端。"><a href="#1-小端-低位字节存放在内存的低地址端，高位字节存放在内存的高地址端。" class="headerlink" title="1. 小端:低位字节存放在内存的低地址端，高位字节存放在内存的高地址端。"></a>1. 小端:低位字节存放在内存的低地址端，高位字节存放在内存的高地址端。</h3><h3 id="2-大端：高位字节存放在内存的低地址端，低位字节存放在内存的高地址端。"><a href="#2-大端：高位字节存放在内存的低地址端，低位字节存放在内存的高地址端。" class="headerlink" title="2. 大端：高位字节存放在内存的低地址端，低位字节存放在内存的高地址端。"></a>2. 大端：高位字节存放在内存的低地址端，低位字节存放在内存的高地址端。</h3><h3 id="Java语言的字节序是大端。"><a href="#Java语言的字节序是大端。" class="headerlink" title="Java语言的字节序是大端。"></a>Java语言的字节序是大端。</h3>]]></content>
    
    
    <categories>
      
      <category>每日一烤</category>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>每日一烤</tag>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>每日一烤:Java语言具有哪些特点？</title>
    <link href="/2022/07/12/Java%E8%AF%AD%E8%A8%80%E5%85%B7%E6%9C%89%E5%93%AA%E4%BA%9B%E7%89%B9%E7%82%B9/"/>
    <url>/2022/07/12/Java%E8%AF%AD%E8%A8%80%E5%85%B7%E6%9C%89%E5%93%AA%E4%BA%9B%E7%89%B9%E7%82%B9/</url>
    
    <content type="html"><![CDATA[<h1 id="Java语言具有哪些特点？"><a href="#Java语言具有哪些特点？" class="headerlink" title="Java语言具有哪些特点？"></a>Java语言具有哪些特点？</h1><h3 id="1-Java为纯面向对象的语言。它能够直接反应现实生活中的对象。"><a href="#1-Java为纯面向对象的语言。它能够直接反应现实生活中的对象。" class="headerlink" title="1. Java为纯面向对象的语言。它能够直接反应现实生活中的对象。"></a>1. Java为纯面向对象的语言。它能够直接反应现实生活中的对象。</h3><h3 id="2-具有平台无关性。java利用Java虚拟机运行字节码，无论是在Windows、Linux还是MacOS等其它-平台对Java程序进行编译，编译后的程序可在其它平台运行。"><a href="#2-具有平台无关性。java利用Java虚拟机运行字节码，无论是在Windows、Linux还是MacOS等其它-平台对Java程序进行编译，编译后的程序可在其它平台运行。" class="headerlink" title="2. 具有平台无关性。java利用Java虚拟机运行字节码，无论是在Windows、Linux还是MacOS等其它 平台对Java程序进行编译，编译后的程序可在其它平台运行。"></a>2. 具有平台无关性。java利用Java虚拟机运行字节码，无论是在Windows、Linux还是MacOS等其它 平台对Java程序进行编译，编译后的程序可在其它平台运行。</h3><h3 id="3-Java为解释型语言，编译器把Java代码编译成平台无关的中间代码，然后在JVM上解释运行，具有-很好的可移植性。"><a href="#3-Java为解释型语言，编译器把Java代码编译成平台无关的中间代码，然后在JVM上解释运行，具有-很好的可移植性。" class="headerlink" title="3. Java为解释型语言，编译器把Java代码编译成平台无关的中间代码，然后在JVM上解释运行，具有 很好的可移植性。"></a>3. Java为解释型语言，编译器把Java代码编译成平台无关的中间代码，然后在JVM上解释运行，具有 很好的可移植性。</h3><h3 id="4-Java提供了很多内置类库。如对多线程支持，对网络通信支持，最重要的一点是提供了垃圾回收-器。"><a href="#4-Java提供了很多内置类库。如对多线程支持，对网络通信支持，最重要的一点是提供了垃圾回收-器。" class="headerlink" title="4. Java提供了很多内置类库。如对多线程支持，对网络通信支持，最重要的一点是提供了垃圾回收 器。"></a>4. Java提供了很多内置类库。如对多线程支持，对网络通信支持，最重要的一点是提供了垃圾回收 器。</h3><h3 id="5-Java具有较好的安全性和健壮性。Java提供了异常处理和垃圾回收机制，去除了C-中难以理解的-指针特性。-6-Java语言提供了对Web应用开发的支持。"><a href="#5-Java具有较好的安全性和健壮性。Java提供了异常处理和垃圾回收机制，去除了C-中难以理解的-指针特性。-6-Java语言提供了对Web应用开发的支持。" class="headerlink" title="5. Java具有较好的安全性和健壮性。Java提供了异常处理和垃圾回收机制，去除了C++中难以理解的 指针特性。 6. Java语言提供了对Web应用开发的支持。"></a>5. Java具有较好的安全性和健壮性。Java提供了异常处理和垃圾回收机制，去除了C++中难以理解的 指针特性。 6. Java语言提供了对Web应用开发的支持。</h3>]]></content>
    
    
    <categories>
      
      <category>每日一烤</category>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>每日一烤</tag>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>每日一烤:面向对象的三大特性？</title>
    <link href="/2022/07/11/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7/"/>
    <url>/2022/07/11/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7/</url>
    
    <content type="html"><![CDATA[<h1 id="面向对象的三大特性？"><a href="#面向对象的三大特性？" class="headerlink" title="面向对象的三大特性？"></a>面向对象的三大特性？</h1><h3 id="1-继承：对象的一个新类可以从现有的类中派生，派生类可以从它的基类那继承方法和实例变量，且-派生类可以修改或新增新的方法使之更适合特殊的需求。"><a href="#1-继承：对象的一个新类可以从现有的类中派生，派生类可以从它的基类那继承方法和实例变量，且-派生类可以修改或新增新的方法使之更适合特殊的需求。" class="headerlink" title="1. 继承：对象的一个新类可以从现有的类中派生，派生类可以从它的基类那继承方法和实例变量，且 派生类可以修改或新增新的方法使之更适合特殊的需求。"></a>1. 继承：对象的一个新类可以从现有的类中派生，派生类可以从它的基类那继承方法和实例变量，且 派生类可以修改或新增新的方法使之更适合特殊的需求。</h3><h3 id="2-封装：将客观事物抽象成类，每个类可以把自身数据和方法只让可信的类或对象操作，对不可信的-进行信息隐藏。"><a href="#2-封装：将客观事物抽象成类，每个类可以把自身数据和方法只让可信的类或对象操作，对不可信的-进行信息隐藏。" class="headerlink" title="2. 封装：将客观事物抽象成类，每个类可以把自身数据和方法只让可信的类或对象操作，对不可信的 进行信息隐藏。"></a>2. 封装：将客观事物抽象成类，每个类可以把自身数据和方法只让可信的类或对象操作，对不可信的 进行信息隐藏。</h3><h3 id="3-多态：允许不同类的对象对同一消息作出响应。不同对象调用相同方法即使参数也相同，最终表现-行为是不一样的。"><a href="#3-多态：允许不同类的对象对同一消息作出响应。不同对象调用相同方法即使参数也相同，最终表现-行为是不一样的。" class="headerlink" title="3. 多态：允许不同类的对象对同一消息作出响应。不同对象调用相同方法即使参数也相同，最终表现 行为是不一样的。"></a>3. 多态：允许不同类的对象对同一消息作出响应。不同对象调用相同方法即使参数也相同，最终表现 行为是不一样的。</h3>]]></content>
    
    
    <categories>
      
      <category>每日一烤</category>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>每日一烤</tag>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>每日一烤:简述throw与throws的区别</title>
    <link href="/2022/07/10/%E7%AE%80%E8%BF%B0throw%E4%B8%8Ethrows%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <url>/2022/07/10/%E7%AE%80%E8%BF%B0throw%E4%B8%8Ethrows%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<h1 id="简述throw与throws的区别"><a href="#简述throw与throws的区别" class="headerlink" title="简述throw与throws的区别"></a>简述throw与throws的区别</h1><h3 id="throw一般是用在方法体的内部，由开发者定义当程序语句出现问题后主动抛出一个异常。"><a href="#throw一般是用在方法体的内部，由开发者定义当程序语句出现问题后主动抛出一个异常。" class="headerlink" title="throw一般是用在方法体的内部，由开发者定义当程序语句出现问题后主动抛出一个异常。"></a>throw一般是用在方法体的内部，由开发者定义当程序语句出现问题后主动抛出一个异常。</h3><h3 id="throws一般用于方法声明上，代表该方法可能会抛出的异常列表。"><a href="#throws一般用于方法声明上，代表该方法可能会抛出的异常列表。" class="headerlink" title="throws一般用于方法声明上，代表该方法可能会抛出的异常列表。"></a>throws一般用于方法声明上，代表该方法可能会抛出的异常列表。</h3>]]></content>
    
    
    <categories>
      
      <category>每日一烤</category>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>每日一烤</tag>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>每日一烤:Java关键字(static)</title>
    <link href="/2022/07/09/Java%E5%85%B3%E9%94%AE%E5%AD%97(static)/"/>
    <url>/2022/07/09/Java%E5%85%B3%E9%94%AE%E5%AD%97(static)/</url>
    
    <content type="html"><![CDATA[<h1 id="Java语言中关键字static的作用是什么？"><a href="#Java语言中关键字static的作用是什么？" class="headerlink" title="Java语言中关键字static的作用是什么？"></a>Java语言中关键字static的作用是什么？</h1><h3 id="static的主要作用有两个："><a href="#static的主要作用有两个：" class="headerlink" title="static的主要作用有两个："></a>static的主要作用有两个：</h3><ol><li><h5 id="为某种特定数据类型或对象分配与创建对象个数无关的单一的存储空间。"><a href="#为某种特定数据类型或对象分配与创建对象个数无关的单一的存储空间。" class="headerlink" title="为某种特定数据类型或对象分配与创建对象个数无关的单一的存储空间。"></a>为某种特定数据类型或对象分配与创建对象个数无关的单一的存储空间。</h5></li><li><h5 id="使得某个方法或属性与类而不是对象关联在一起，即在不创建对象的情况下可通过类直接调用方法-或使用类的属性。"><a href="#使得某个方法或属性与类而不是对象关联在一起，即在不创建对象的情况下可通过类直接调用方法-或使用类的属性。" class="headerlink" title="使得某个方法或属性与类而不是对象关联在一起，即在不创建对象的情况下可通过类直接调用方法 或使用类的属性。"></a>使得某个方法或属性与类而不是对象关联在一起，即在不创建对象的情况下可通过类直接调用方法 或使用类的属性。</h5></li></ol><h4 id="具体而言static又可分为4种使用方式："><a href="#具体而言static又可分为4种使用方式：" class="headerlink" title="具体而言static又可分为4种使用方式："></a>具体而言static又可分为4种使用方式：</h4><ol><li><h5 id="修饰成员变量。用static关键字修饰的静态变量在内存中只有一个副本。只要静态变量所在的类被加-载，这个静态变量就会被分配空间，可以使用’’类-静态变量’’和’’对象-静态变量’’的方法使用。"><a href="#修饰成员变量。用static关键字修饰的静态变量在内存中只有一个副本。只要静态变量所在的类被加-载，这个静态变量就会被分配空间，可以使用’’类-静态变量’’和’’对象-静态变量’’的方法使用。" class="headerlink" title="修饰成员变量。用static关键字修饰的静态变量在内存中只有一个副本。只要静态变量所在的类被加 载，这个静态变量就会被分配空间，可以使用’’类.静态变量’’和’’对象.静态变量’’的方法使用。"></a>修饰成员变量。用static关键字修饰的静态变量在内存中只有一个副本。只要静态变量所在的类被加 载，这个静态变量就会被分配空间，可以使用’’类.静态变量’’和’’对象.静态变量’’的方法使用。</h5></li><li><h5 id="修饰成员方法。static修饰的方法无需创建对象就可以被调用。static方法中不能使用this和super关-键字，不能调用非static方法，只能访问所属类的静态成员变量和静态成员方法。"><a href="#修饰成员方法。static修饰的方法无需创建对象就可以被调用。static方法中不能使用this和super关-键字，不能调用非static方法，只能访问所属类的静态成员变量和静态成员方法。" class="headerlink" title="修饰成员方法。static修饰的方法无需创建对象就可以被调用。static方法中不能使用this和super关 键字，不能调用非static方法，只能访问所属类的静态成员变量和静态成员方法。"></a>修饰成员方法。static修饰的方法无需创建对象就可以被调用。static方法中不能使用this和super关 键字，不能调用非static方法，只能访问所属类的静态成员变量和静态成员方法。</h5></li><li><h5 id="修饰代码块。JVM在加载类的时候会执行static代码块。static代码块常用于初始化静态变量。static-代码块只会被执行一次。"><a href="#修饰代码块。JVM在加载类的时候会执行static代码块。static代码块常用于初始化静态变量。static-代码块只会被执行一次。" class="headerlink" title="修饰代码块。JVM在加载类的时候会执行static代码块。static代码块常用于初始化静态变量。static 代码块只会被执行一次。"></a>修饰代码块。JVM在加载类的时候会执行static代码块。static代码块常用于初始化静态变量。static 代码块只会被执行一次。</h5></li><li><h5 id="修饰内部类。static内部类可以不依赖外部类实例对象而被实例化。静态内部类不能与外部类有相同-的名字，不能访问普通成员变量，只能访问外部类中的静态成员和静态成员方法"><a href="#修饰内部类。static内部类可以不依赖外部类实例对象而被实例化。静态内部类不能与外部类有相同-的名字，不能访问普通成员变量，只能访问外部类中的静态成员和静态成员方法" class="headerlink" title="修饰内部类。static内部类可以不依赖外部类实例对象而被实例化。静态内部类不能与外部类有相同 的名字，不能访问普通成员变量，只能访问外部类中的静态成员和静态成员方法"></a>修饰内部类。static内部类可以不依赖外部类实例对象而被实例化。静态内部类不能与外部类有相同 的名字，不能访问普通成员变量，只能访问外部类中的静态成员和静态成员方法</h5></li></ol>]]></content>
    
    
    <categories>
      
      <category>每日一烤</category>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>每日一烤</tag>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>每日一烤:Java关键字(访问修饰符)</title>
    <link href="/2022/07/08/Java%E5%85%B3%E9%94%AE%E5%AD%97(%E8%AE%BF%E9%97%AE%E4%BF%AE%E9%A5%B0%E7%AC%A6)/"/>
    <url>/2022/07/08/Java%E5%85%B3%E9%94%AE%E5%AD%97(%E8%AE%BF%E9%97%AE%E4%BF%AE%E9%A5%B0%E7%AC%A6)/</url>
    
    <content type="html"><![CDATA[<h1 id="简述Java访问修饰符"><a href="#简述Java访问修饰符" class="headerlink" title="简述Java访问修饰符"></a>简述Java访问修饰符</h1><h4 id="default-默认访问修饰符，在同一包内可见"><a href="#default-默认访问修饰符，在同一包内可见" class="headerlink" title="default: 默认访问修饰符，在同一包内可见"></a>default: 默认访问修饰符，在同一包内可见</h4><h4 id="private-在同一类内可见，不能修饰类"><a href="#private-在同一类内可见，不能修饰类" class="headerlink" title="private: 在同一类内可见，不能修饰类"></a>private: 在同一类内可见，不能修饰类</h4><h4 id="protected-对同一包内的类和所有子类可见，不能修饰类"><a href="#protected-对同一包内的类和所有子类可见，不能修饰类" class="headerlink" title="protected : 对同一包内的类和所有子类可见，不能修饰类"></a>protected : 对同一包内的类和所有子类可见，不能修饰类</h4><h4 id="public-对所有类可见"><a href="#public-对所有类可见" class="headerlink" title="public: 对所有类可见"></a>public: 对所有类可见</h4><p>Java一共提供了3个访问修饰控制符：private、protected、public，代表了三种访问控制级别，另外还有一个不加任何访问控制符的访问控制级别，一共提供了4中访问控制级别。</p><p>我们在Java编程中「直接访问」一个成员变量或者成员方法，有两个形式</p><figure class="highlight java"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">1</span>、对象.成员变量<br><span class="hljs-number">2</span>、成员变量<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">第二种多见于类内访问本类的成员变量</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><p>我们将访问成员变量或者方法的范围限制在三个方面，分别讨论</p><ul><li>本类中</li><li>子类中</li><li>不同包的类中</li></ul><h2 id="一、private-当前类访问权限"><a href="#一、private-当前类访问权限" class="headerlink" title="一、private(当前类访问权限)"></a>一、private(当前类访问权限)</h2><p>如果类里的一个成员（包括成员变量、方法和构造器等）使用private访问控制符来修饰，则这个成员只能在「当前类的内部」被访问。很显然，个访问控制符用于修饰成员变量最合适，使用它来修饰成员变量就可以把成员变量隐藏在该类的内部。</p><blockquote><p>这里尤其要提一下的是，在子类中我们不能通过第二种方式直接访问父类的private修饰成员变量或者方法，这也就是私有成员不能被继承的由来。</p></blockquote><p>本类中：直接通过成员变量名访问</p><p>子类中：不能直接通过两种方式中的任意一种访问</p><p>不同包的类中：不能直接通过两种方式中的任意一种访问</p><h2 id="二、default（包访问权限）"><a href="#二、default（包访问权限）" class="headerlink" title="二、default（包访问权限）"></a>二、default（包访问权限）</h2><p>如果类里的一个成员（包括成员变量、方法和构造器等）或者一个外部类不使用任何访控制符修饰，就称它是包访问权限的。</p><p>default 访问控制的成员或外部类可以被相同包下的其他类访问。</p><p>本类中：直接通过成员变量名访问</p><p>同包的子类中：直接通过成员变量名访问</p><p>同包的其他类：可以通过第二种方式访问</p><p>不同包的类（包括子类）中：不能直接通过两种方式中的任意一种访问</p><h2 id="三、protected（子类访问权限）"><a href="#三、protected（子类访问权限）" class="headerlink" title="三、protected（子类访问权限）"></a>三、protected（子类访问权限）</h2><p>如果一个成员（包括成员变量、方法和构造器等）使用protected访问控制符修饰，那么这个成员既可以被同一个包中的其他类访问，也可以被不同包中的子类访问。</p><p>在通常情况下，如果使用protected来修饰一个方法，通常是希望其子类来重写这个方法。</p><p>本类中：直接通过成员变量名访问</p><p>同包的子类中：直接通过成员变量名访问</p><p>同包的其他类：可以通过第二种方式访问</p><p>不同包的子类：直接通过成员变量名访问</p><p>不同包的类中：不能直接通过两种方式中的任意一种访问</p><h2 id="四、public（公共访问权限）"><a href="#四、public（公共访问权限）" class="headerlink" title="四、public（公共访问权限）"></a>四、public（公共访问权限）</h2><p>这是一个最宽松的访问控制级别，如果一个成员（包括成员变量、方法和构造器等）或者一个外部类使用public访问控制符修饰，那么这个成员或外部类就可以被所有类访问，不管访问类和被访问类是否处于同一个包中，是否具有父子继承关系。</p><h2 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h2><p>其实没有必要强行去记同一个包中怎么样、不同子类中怎么样，只要记住四种访问权限的名字，然后对于继承中对于访问权限的定义「私有成员不能被继承」就可以很好理解了。</p>]]></content>
    
    
    <categories>
      
      <category>每日一烤</category>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>每日一烤</tag>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>每日一烤:关于null的几种处理方式</title>
    <link href="/2022/07/07/%E5%85%B3%E4%BA%8Enull%E7%9A%84%E5%87%A0%E7%A7%8D%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F/"/>
    <url>/2022/07/07/%E5%85%B3%E4%BA%8Enull%E7%9A%84%E5%87%A0%E7%A7%8D%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="关于null的几种处理方式"><a href="#关于null的几种处理方式" class="headerlink" title="关于null的几种处理方式"></a>关于null的几种处理方式</h1><h4 id="Java开发中-我们常常会遇到NullPointerException-空指针异常-的问题-java的发明者也曾承认这是个巨大的设计错误"><a href="#Java开发中-我们常常会遇到NullPointerException-空指针异常-的问题-java的发明者也曾承认这是个巨大的设计错误" class="headerlink" title="Java开发中,我们常常会遇到NullPointerException(空指针异常)的问题,java的发明者也曾承认这是个巨大的设计错误."></a>Java开发中,我们常常会遇到NullPointerException(空指针异常)的问题,java的发明者也曾承认这是个巨大的设计错误.</h4><p>关于null,我们应该了解到如下几点,从而避免很多由null引起的错误.</p><ul><li>大小写敏感</li><li>null是任何引用类型的初始值</li><li>null既不是对象,也不是类型,你可以将它赋值给任何引用类型</li><li>null不能赋值给基本数据类型</li><li>将null赋值给包装类,自动拆箱会报NPE</li><li>带有null的引用类型变量,instanceof会报false</li><li>静态变量为null调用静态方法不会抛出NPE</li><li>建议使用null值安全的方法</li><li>使用&#x3D;&#x3D;或者!&#x3D;判断null</li></ul><h4 id="大小写敏感"><a href="#大小写敏感" class="headerlink" title="大小写敏感"></a>大小写敏感</h4><p>首先，null是Java中的关键字，像是public、static、final。它是大小写敏感的，你不能将null写 成Null或NULL,编辑器将不能识别它们然后报错。 这个问题已经几乎不会出现，因为eclipse和ldea编译器已经给出了编译器提示，所以你不用考虑这 个问题。</p><h4 id="null是任何引用类型的初始值"><a href="#null是任何引用类型的初始值" class="headerlink" title="null是任何引用类型的初始值"></a>null是任何引用类型的初始值</h4><p>null是所有引用类型的默认值，Java中的任何引用变量都将nul作为默认值，也就是说所有Object类下的引用类型默认值都是null。</p><p>这对所有的引用变量都适用。就像是基本类型的默认值一样，例如int的默认值是0，boolean的默认值是false。 下面是基本数据类型的初始值</p><table><thead><tr><th>类型</th><th>初始值</th></tr></thead><tbody><tr><td>boolean</td><td>false</td></tr><tr><td>char</td><td>&#x2F;u0000</td></tr><tr><td>byte</td><td>(byte)0</td></tr><tr><td>short</td><td>(short)0</td></tr><tr><td>int</td><td>0</td></tr><tr><td>long</td><td>0L</td></tr><tr><td>double</td><td>0.0d</td></tr><tr><td>float</td><td>0.0f</td></tr></tbody></table><h4 id="null只是一种特殊的值"><a href="#null只是一种特殊的值" class="headerlink" title="null只是一种特殊的值"></a>null只是一种特殊的值</h4><p>null既不是对象也不是一种类型，它仅是一种特殊的值，你可以将它赋予任何引用类型，你可以将nuIl转换为任何引用类型</p><figure class="highlight java"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><span class="hljs-type">Integer</span> <span class="hljs-variable">itr</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><span class="hljs-type">Double</span> <span class="hljs-variable">dou</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><span class="hljs-type">Integer</span> <span class="hljs-variable">integer</span> <span class="hljs-operator">=</span> (Integer) <span class="hljs-literal">null</span>;<br><span class="hljs-type">String</span> <span class="hljs-variable">string</span> <span class="hljs-operator">=</span> (String)<span class="hljs-literal">null</span>;<br>System.out.println(<span class="hljs-string">&quot;integer = &quot;</span> + integer);<br>System.out.println(<span class="hljs-string">&quot;string = &quot;</span> + string);<br>&#125;<br><br>[Finished in 567ms]<br>integer = <span class="hljs-type">null</span><br><span class="hljs-variable">string</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span><br></code></pre></td></tr></table></figure><p>你可以看到在编译期和运行期内，将null转换成任何的引用类型都是可行的，并且不会抛出空指针异 常。 </p><h4 id="null只能赋值给引用变量，不能赋值给基本类型变量。"><a href="#null只能赋值给引用变量，不能赋值给基本类型变量。" class="headerlink" title="null只能赋值给引用变量，不能赋值给基本类型变量。"></a>null只能赋值给引用变量，不能赋值给基本类型变量。</h4><h4 id="持有null的包装类在进行自动拆箱的时候，不能完成转换，会抛出空指针异常，并且null也不能和基本数据类型进行对比"><a href="#持有null的包装类在进行自动拆箱的时候，不能完成转换，会抛出空指针异常，并且null也不能和基本数据类型进行对比" class="headerlink" title="持有null的包装类在进行自动拆箱的时候，不能完成转换，会抛出空指针异常，并且null也不能和基本数据类型进行对比"></a>持有null的包装类在进行自动拆箱的时候，不能完成转换，会抛出空指针异常，并且null也不能和基本数据类型进行对比</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span>&#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-type">Integer</span> <span class="hljs-variable">itr</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>System.out.println(itr == i);<br>&#125;<br>&#125;<br><br>[Finished in <span class="hljs-number">1.</span>2s]<br>Exception in thread <span class="hljs-string">&quot;main&quot;</span> java.lang.NullPointerException<br>at Test.main(Test.java:<span class="hljs-number">5</span>)<br><br></code></pre></td></tr></table></figure><h4 id="使用带有null值的引用对象-instanceof操作会返回false"><a href="#使用带有null值的引用对象-instanceof操作会返回false" class="headerlink" title="使用带有null值的引用对象,instanceof操作会返回false"></a>使用带有null值的引用对象,instanceof操作会返回false</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span>&#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><span class="hljs-type">Integer</span> <span class="hljs-variable">isNull</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><span class="hljs-comment">// instanceof = isInstance 方法</span><br><span class="hljs-keyword">if</span>(isNull <span class="hljs-keyword">instanceof</span> Integer)&#123;<br>System.out.println(<span class="hljs-string">&quot;isNull is instanceof Integer&quot;</span>);<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>System.out.println(<span class="hljs-string">&quot;isNull is not instanceof Integer&quot;</span>);<br>&#125;<br>&#125;<br>&#125;<br><br>[Finished in 572ms]<br>isNull is not <span class="hljs-keyword">instanceof</span> Integer<br></code></pre></td></tr></table></figure><p>这是instanceof操作符一个很重要的特性，使得对类型强制转换检查很有用</p><p> 静态变量为null调用静态方法不会抛出NullPointerException。因为静态方法使用了静态绑定。 </p><p>使用Null-Safe方法 你应该使用nul-safe安全的方法，java类库中有很多工具类都提供了静态方法，例如基本数据类型的 包装类，Integer,Double等。例如</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NullSafeMethod</span> &#123;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> String number;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> String.valueOf(number);<br><span class="hljs-type">String</span> <span class="hljs-variable">string</span> <span class="hljs-operator">=</span> number.toString();<br>System.out.println(<span class="hljs-string">&quot;s = &quot;</span> + s);<br>System.out.println(<span class="hljs-string">&quot;string = &quot;</span> + string);<br>&#125;<br>&#125;<br><br>[Finished in 565ms]<br>s = <span class="hljs-literal">null</span><br>计划输出:string = <span class="hljs-literal">null</span>,但因报错无法输出<br>报错原因<span class="hljs-type">String</span> <span class="hljs-variable">string</span> <span class="hljs-operator">=</span> number.toString()此行代码<br></code></pre></td></tr></table></figure><p>number没有赋值，所以默认为null,使用String.value(number)静态方法没有抛出空指针异常， 但是使用toString()却抛出了空指针异常。所以尽量使用对象的静态方法。 </p><h4 id="null判断"><a href="#null判断" class="headerlink" title="null判断"></a>null判断</h4><p>你可以使用&#x3D;或者&#x3D;操作来比较null值，但是不能使用其他算法或者逻辑操作，例如小于或者 大于。跟SQL不一样，在Java中null&#x3D;&#x3D;null将返回true,如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span>&#123;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> String str1;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> String str2;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>System.out.println(<span class="hljs-string">&quot;str1 == str2 ? &quot;</span> + str1 ==str2);<br>System.out.println(<span class="hljs-literal">null</span> == <span class="hljs-literal">null</span>);<br>&#125;<br>&#125;<br><br>[Finished in 567ms]<br><span class="hljs-literal">false</span><br><span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>每日一烤</category>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>每日一烤</tag>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>每日一烤:Java 的一点知识点?</title>
    <link href="/2022/07/06/Java-%E7%9A%84%E4%B8%80%E7%82%B9%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    <url>/2022/07/06/Java-%E7%9A%84%E4%B8%80%E7%82%B9%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
    
    <content type="html"><![CDATA[<h1 id="Java-语言有哪些特点-Write-Once-Run-Anywhere"><a href="#Java-语言有哪些特点-Write-Once-Run-Anywhere" class="headerlink" title="Java 语言有哪些特点(Write Once, Run Anywhere)?"></a>Java 语言有哪些特点(Write Once, Run Anywhere)?</h1><ol><li><h4 id="简单易学；"><a href="#简单易学；" class="headerlink" title="简单易学；"></a>简单易学；</h4></li><li><h4 id="面向对象（封装，继承，多态）；"><a href="#面向对象（封装，继承，多态）；" class="headerlink" title="面向对象（封装，继承，多态）；"></a>面向对象（封装，继承，多态）；</h4></li><li><h4 id="平台无关性（-Java-虚拟机实现平台无关性）；"><a href="#平台无关性（-Java-虚拟机实现平台无关性）；" class="headerlink" title="平台无关性（ Java 虚拟机实现平台无关性）；"></a>平台无关性（ Java 虚拟机实现平台无关性）；</h4></li><li><h4 id="支持多线程（-C-语言没有内置的多线程机制，因此必须调用操作系统的多线程功能来进行多线程程序设计，而-Java-语言却提供了多线程支持）；"><a href="#支持多线程（-C-语言没有内置的多线程机制，因此必须调用操作系统的多线程功能来进行多线程程序设计，而-Java-语言却提供了多线程支持）；" class="headerlink" title="支持多线程（ C++ 语言没有内置的多线程机制，因此必须调用操作系统的多线程功能来进行多线程程序设计，而 Java 语言却提供了多线程支持）；"></a>支持多线程（ C++ 语言没有内置的多线程机制，因此必须调用操作系统的多线程功能来进行多线程程序设计，而 Java 语言却提供了多线程支持）；</h4></li><li><h4 id="可靠性；"><a href="#可靠性；" class="headerlink" title="可靠性；"></a>可靠性；</h4></li><li><h4 id="安全性；"><a href="#安全性；" class="headerlink" title="安全性；"></a>安全性；</h4></li><li><h4 id="支持网络编程并且很方便（-Java-语言诞生本身就是为简化网络编程设计的，因此-Java-语言不仅支持网络编程而且很方便）；"><a href="#支持网络编程并且很方便（-Java-语言诞生本身就是为简化网络编程设计的，因此-Java-语言不仅支持网络编程而且很方便）；" class="headerlink" title="支持网络编程并且很方便（ Java 语言诞生本身就是为简化网络编程设计的，因此 Java 语言不仅支持网络编程而且很方便）；"></a>支持网络编程并且很方便（ Java 语言诞生本身就是为简化网络编程设计的，因此 Java 语言不仅支持网络编程而且很方便）；</h4></li><li><h4 id="编译与解释并存；"><a href="#编译与解释并存；" class="headerlink" title="编译与解释并存；"></a>编译与解释并存；</h4></li></ol><h1 id="Java-和-C-的区别"><a href="#Java-和-C-的区别" class="headerlink" title="Java 和 C++ 的区别?"></a>Java 和 C++ 的区别?</h1><p>   我知道很多人没学过 C++，但是面试官就是没事喜欢拿咱们 Java 和 C++ 比呀！没办法！！！就算没学过 C++，也要记下来。</p><p>   虽然，Java 和 C++ 都是面向对象的语言，都支持封装、继承和多态，但是，它们还是有挺多不相同的地方：</p><ul><li>Java 不提供指针来直接访问内存，程序内存更加安全</li><li>Java 的类是单继承的，C++ 支持多重继承；虽然 Java 的类不可以多继承，但是接口可以多继承。</li><li>Java 有自动内存管理垃圾回收机制(GC)，不需要程序员手动释放无用内存。</li><li>C ++同时支持方法重载和操作符重载，但是 Java 只支持方法重载(例外:String看似对操作符进行进行了重载)（操作符重载增加了复杂性，这与 Java 最初的设计思想不符）。</li><li>……</li></ul><h1 id="简述重载与重写的区别"><a href="#简述重载与重写的区别" class="headerlink" title="简述重载与重写的区别"></a>简述重载与重写的区别</h1><h4 id="重写即子类重写父类的方法，方法对应的形参和返回值类型都不能变。"><a href="#重写即子类重写父类的方法，方法对应的形参和返回值类型都不能变。" class="headerlink" title="重写即子类重写父类的方法，方法对应的形参和返回值类型都不能变。"></a>重写即子类重写父类的方法，方法对应的形参和返回值类型都不能变。</h4><ul><li><p>重写的方法必须与父类保持一致,包括返回值类型,方法名,参数列表</p></li><li><p>重写的方法可以使用@Override注释来标识</p></li><li><p>子类中的重写方法的访问权限不能低于父类中的方法的访问权限</p></li></ul><h4 id="重载即在一个类中，方法名相同，参数类型或数量不同。"><a href="#重载即在一个类中，方法名相同，参数类型或数量不同。" class="headerlink" title="重载即在一个类中，方法名相同，参数类型或数量不同。"></a>重载即在一个类中，方法名相同，参数类型或数量不同。</h4><ul><li>每个重载的方法都有独一无二的参数列表</li></ul>]]></content>
    
    
    <categories>
      
      <category>每日一烤</category>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>每日一烤</tag>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>每日一烤:String的一点知识</title>
    <link href="/2022/07/05/String%E7%9A%84%E4%B8%80%E7%82%B9%E7%9F%A5%E8%AF%86/"/>
    <url>/2022/07/05/String%E7%9A%84%E4%B8%80%E7%82%B9%E7%9F%A5%E8%AF%86/</url>
    
    <content type="html"><![CDATA[<h1 id="String和StringBuffer有什么区别？"><a href="#String和StringBuffer有什么区别？" class="headerlink" title="String和StringBuffer有什么区别？"></a>String和StringBuffer有什么区别？</h1><h4 id="String用于字符串操作，属于不可变类。String对象一旦被创建，其值将不能被改变。而StringBuffer是-可变类，当对象创建后，仍然可以对其值进行修改。"><a href="#String用于字符串操作，属于不可变类。String对象一旦被创建，其值将不能被改变。而StringBuffer是-可变类，当对象创建后，仍然可以对其值进行修改。" class="headerlink" title="String用于字符串操作，属于不可变类。String对象一旦被创建，其值将不能被改变。而StringBuffer是 可变类，当对象创建后，仍然可以对其值进行修改。"></a>String用于字符串操作，属于不可变类。String对象一旦被创建，其值将不能被改变。而StringBuffer是 可变类，当对象创建后，仍然可以对其值进行修改。</h4><h1 id="为什么要把String设计为不变量？"><a href="#为什么要把String设计为不变量？" class="headerlink" title="为什么要把String设计为不变量？"></a>为什么要把String设计为不变量？</h1><ol><li><h4 id="节省空间：字符串常量存储在JVM的字符串池中可以被用户共享。"><a href="#节省空间：字符串常量存储在JVM的字符串池中可以被用户共享。" class="headerlink" title="节省空间：字符串常量存储在JVM的字符串池中可以被用户共享。"></a>节省空间：字符串常量存储在JVM的字符串池中可以被用户共享。</h4></li><li><h4 id="提高效率-String会被不同线程共享，是线程安全的。在涉及多线程操作中不需要同步操作。"><a href="#提高效率-String会被不同线程共享，是线程安全的。在涉及多线程操作中不需要同步操作。" class="headerlink" title="提高效率:String会被不同线程共享，是线程安全的。在涉及多线程操作中不需要同步操作。"></a>提高效率:String会被不同线程共享，是线程安全的。在涉及多线程操作中不需要同步操作。</h4></li><li><h4 id="安全：String常被用于用户名、密码、文件名等使用，由于其不可变，可避免黑客行为对其恶意修-改。"><a href="#安全：String常被用于用户名、密码、文件名等使用，由于其不可变，可避免黑客行为对其恶意修-改。" class="headerlink" title="安全：String常被用于用户名、密码、文件名等使用，由于其不可变，可避免黑客行为对其恶意修 改。"></a>安全：String常被用于用户名、密码、文件名等使用，由于其不可变，可避免黑客行为对其恶意修 改。</h4></li></ol><h1 id="简述String-x2F-StringBuffer与StringBuilder"><a href="#简述String-x2F-StringBuffer与StringBuilder" class="headerlink" title="简述String&#x2F;StringBuffer与StringBuilder"></a>简述String&#x2F;StringBuffer与StringBuilder</h1><h4 id="String类采用利用final修饰的字符数组进行字符串保存，因此不可变。如果对String类型对象修改，需要-新建对象，将老字符和新增加的字符一并存进去。"><a href="#String类采用利用final修饰的字符数组进行字符串保存，因此不可变。如果对String类型对象修改，需要-新建对象，将老字符和新增加的字符一并存进去。" class="headerlink" title="String类采用利用final修饰的字符数组进行字符串保存，因此不可变。如果对String类型对象修改，需要 新建对象，将老字符和新增加的字符一并存进去。"></a>String类采用利用final修饰的字符数组进行字符串保存，因此不可变。如果对String类型对象修改，需要 新建对象，将老字符和新增加的字符一并存进去。</h4><h4 id="StringBuilder，采用无final修饰的字符数组进行保存，因此可变。但线程不安全。"><a href="#StringBuilder，采用无final修饰的字符数组进行保存，因此可变。但线程不安全。" class="headerlink" title="StringBuilder，采用无final修饰的字符数组进行保存，因此可变。但线程不安全。"></a>StringBuilder，采用无final修饰的字符数组进行保存，因此可变。但线程不安全。</h4><h4 id="StringBuffer，采用无final修饰的字符数组进行保存，可理解为实现线程安全的StringBuilder。"><a href="#StringBuffer，采用无final修饰的字符数组进行保存，可理解为实现线程安全的StringBuilder。" class="headerlink" title="StringBuffer，采用无final修饰的字符数组进行保存，可理解为实现线程安全的StringBuilder。"></a>StringBuffer，采用无final修饰的字符数组进行保存，可理解为实现线程安全的StringBuilder。</h4><h1 id="String-属于基础的数据类型吗？"><a href="#String-属于基础的数据类型吗？" class="headerlink" title="String 属于基础的数据类型吗？"></a>String 属于基础的数据类型吗？</h1><h4 id="不属于-属于引用数据类型"><a href="#不属于-属于引用数据类型" class="headerlink" title="不属于,属于引用数据类型"></a>不属于,属于引用数据类型</h4><h4 id="基础数据类型有四类八种"><a href="#基础数据类型有四类八种" class="headerlink" title="基础数据类型有四类八种"></a>基础数据类型有四类八种</h4><ul><li>整数型:byte,short,int,long<ul><li>byte:字节,1byte &#x3D; 8bits,默认值为0</li><li>short:两字节,16位,默认值0</li><li>int:四字节,32位,0</li><li>long:八字节,64位,0</li><li>占用空间long&gt;int&gt;short&gt;byte</li></ul></li><li>浮点型:float,double<ul><li>单精度float,占用四位,1float &#x3D; 32bits,默认值:0.0f;</li><li>双精度double,占用8位,1double &#x3D; 64bits,默认值0.0d;</li></ul></li><li>字符型:char<ul><li>单一的16位Unicode字符</li><li>最小值\u0000</li><li>最大值\uffff</li></ul></li><li>布尔型:boolean</li></ul><h1 id="Java-中操作字符串都有哪些类？它们之间有什么区别？-同上"><a href="#Java-中操作字符串都有哪些类？它们之间有什么区别？-同上" class="headerlink" title="Java 中操作字符串都有哪些类？它们之间有什么区别？(同上)"></a>Java 中操作字符串都有哪些类？它们之间有什么区别？(同上)</h1><h4 id="操作字符串的类有：String、StringBuffer、StringBuilder。"><a href="#操作字符串的类有：String、StringBuffer、StringBuilder。" class="headerlink" title="操作字符串的类有：String、StringBuffer、StringBuilder。"></a>操作字符串的类有：String、StringBuffer、StringBuilder。</h4><h4 id="String-和-StringBuffer、StringBuilder-的区别在于-String-声明的是不可变的对象，-每次操作都会生成新的-String-对象，然后将指针指向新的-String-对象，而-StringBuffer、-StringBuilder-可以在原有对象的基础上进行操作，所以在经常改变字符串内容的情况下-最好不要使用-String。-StringBuffer-和-StringBuilder-最大的区别在于，StringBuffer-是线程安全的，而-StringBuilder-是非线程安全的，但-StringBuilder-的性能却高于-StringBuffer，所以-在单线程环境下推荐使用-StringBuilder，多线程环境下推荐使用-StringBuffer。"><a href="#String-和-StringBuffer、StringBuilder-的区别在于-String-声明的是不可变的对象，-每次操作都会生成新的-String-对象，然后将指针指向新的-String-对象，而-StringBuffer、-StringBuilder-可以在原有对象的基础上进行操作，所以在经常改变字符串内容的情况下-最好不要使用-String。-StringBuffer-和-StringBuilder-最大的区别在于，StringBuffer-是线程安全的，而-StringBuilder-是非线程安全的，但-StringBuilder-的性能却高于-StringBuffer，所以-在单线程环境下推荐使用-StringBuilder，多线程环境下推荐使用-StringBuffer。" class="headerlink" title="String 和 StringBuffer、StringBuilder 的区别在于 String 声明的是不可变的对象， 每次操作都会生成新的 String 对象，然后将指针指向新的 String 对象，而 StringBuffer、 StringBuilder 可以在原有对象的基础上进行操作，所以在经常改变字符串内容的情况下 最好不要使用 String。 StringBuffer 和 StringBuilder 最大的区别在于，StringBuffer 是线程安全的，而 StringBuilder 是非线程安全的，但 StringBuilder 的性能却高于 StringBuffer，所以 在单线程环境下推荐使用 StringBuilder，多线程环境下推荐使用 StringBuffer。"></a>String 和 StringBuffer、StringBuilder 的区别在于 String 声明的是不可变的对象， 每次操作都会生成新的 String 对象，然后将指针指向新的 String 对象，而 StringBuffer、 StringBuilder 可以在原有对象的基础上进行操作，所以在经常改变字符串内容的情况下 最好不要使用 String。 StringBuffer 和 StringBuilder 最大的区别在于，StringBuffer 是线程安全的，而 StringBuilder 是非线程安全的，但 StringBuilder 的性能却高于 StringBuffer，所以 在单线程环境下推荐使用 StringBuilder，多线程环境下推荐使用 StringBuffer。</h4><h1 id="String-str-x3D-”i”与-String-str-x3D-new-String-“i”-一样吗？"><a href="#String-str-x3D-”i”与-String-str-x3D-new-String-“i”-一样吗？" class="headerlink" title="String str&#x3D;”i”与 String str&#x3D;new String(“i”)一样吗？"></a>String str&#x3D;”i”与 String str&#x3D;new String(“i”)一样吗？</h1><h4 id="不一样，因为内存的分配方式不一样。String-str-x3D-”i”的方式，Java-虚拟机会将其分配到-常量池中；而-String-str-x3D-new-String-“i”-则会被分到堆内存中。"><a href="#不一样，因为内存的分配方式不一样。String-str-x3D-”i”的方式，Java-虚拟机会将其分配到-常量池中；而-String-str-x3D-new-String-“i”-则会被分到堆内存中。" class="headerlink" title="不一样，因为内存的分配方式不一样。String str&#x3D;”i”的方式，Java 虚拟机会将其分配到 常量池中；而 String str&#x3D;new String(“i”) 则会被分到堆内存中。"></a>不一样，因为内存的分配方式不一样。String str&#x3D;”i”的方式，Java 虚拟机会将其分配到 常量池中；而 String str&#x3D;new String(“i”) 则会被分到堆内存中。</h4><h1 id="如何将字符串反转？"><a href="#如何将字符串反转？" class="headerlink" title="如何将字符串反转？"></a>如何将字符串反转？</h1><h4 id="使用-StringBuilder-或者-stringBuffer-的-reverse-方法。-示例代码："><a href="#使用-StringBuilder-或者-stringBuffer-的-reverse-方法。-示例代码：" class="headerlink" title="使用 StringBuilder 或者 stringBuffer 的 reverse() 方法。 示例代码："></a>使用 StringBuilder 或者 stringBuffer 的 reverse() 方法。 示例代码：</h4><figure class="highlight java"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// StringBuffer reverse</span><br><span class="hljs-type">StringBuffer</span> <span class="hljs-variable">stringBuffer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuffer</span>();<br>stringBuffer. append(<span class="hljs-string">&quot;abcdefg&quot;</span>);<br>System. out. println(stringBuffer. reverse()); <span class="hljs-comment">// gfedcba</span><br><span class="hljs-comment">// StringBuilder reverse</span><br><span class="hljs-type">StringBuilder</span> <span class="hljs-variable">stringBuilder</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>stringBuilder. append(<span class="hljs-string">&quot;abcdefg&quot;</span>);<br>System. out. println(stringBuilder. reverse()); <span class="hljs-comment">// gfedcba</span><br></code></pre></td></tr></table></figure><h1 id="String-类的常用方法都有那些？"><a href="#String-类的常用方法都有那些？" class="headerlink" title="String 类的常用方法都有那些？"></a>String 类的常用方法都有那些？</h1><p>• indexOf()：返回指定字符的索引。 </p><p>• charAt()：返回指定索引处的字符。 </p><p>• replace()：字符串替换。 </p><p>• trim()：去除字符串两端空白。 </p><p>• split()：分割字符串，返回一个分割后的字符串数组。 </p><p>• getBytes()：返回字符串的 byte 类型数组。 </p><p>• length()：返回字符串长度。 </p><p>• toLowerCase()：将字符串转成小写字母。 </p><p>• toUpperCase()：将字符串转成大写字符。 </p><p>• substring()：截取字符串。</p>]]></content>
    
    
    <categories>
      
      <category>每日一烤</category>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>每日一烤</tag>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>每日一烤:成员变量 类变量 成员方法 类方法</title>
    <link href="/2022/07/04/%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E7%B1%BB%E5%8F%98%E9%87%8F/"/>
    <url>/2022/07/04/%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E7%B1%BB%E5%8F%98%E9%87%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="变量辨析"><a href="#变量辨析" class="headerlink" title="变量辨析"></a>变量辨析</h1><h2 id="成员变量和局部变量区别"><a href="#成员变量和局部变量区别" class="headerlink" title="成员变量和局部变量区别"></a>成员变量和局部变量区别</h2><table><thead><tr><th></th><th>成员变量</th><th>局部变量</th></tr></thead><tbody><tr><td>位置不同</td><td>类中方法之外</td><td>类方法内</td></tr><tr><td>内存位置</td><td>堆(员)</td><td>栈(忽局)</td></tr><tr><td>生命周期</td><td>随对象</td><td>随方法</td></tr><tr><td>初始值</td><td>有默认初始值</td><td>无初始值,使用前需赋值</td></tr></tbody></table><p><strong>1、在类中的位置不同</strong></p><p>成员变量：在类中方法外面</p><p>局部变量：在方法或者代码块中，或者方法的声明上（即在参数列表中）</p><p><strong>2、在内存中的位置不同，可以看看Java程序内存的简单分析</strong></p><p>成员变量：在堆中（方法区中的静态区）</p><p>局部变量：在栈中</p><p><strong>3、生命周期不同</strong></p><p>成员变量：随着对象的创建而存在，随着对象的消失而消失</p><p>局部变量：随着方法的调用或者代码块的执行而存在，随着方法的调用完毕或者代码块的执行完毕而消失</p><p><strong>4、初始值</strong></p><p>成员变量：有默认初始值</p><p>局部变量：没有默认初始值，使用之前需要赋值，否则编译器会报错（The local variable xxx may not have been initialized）</p><figure class="highlight java"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>&#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">variab</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;成员变量&quot;</span>;<span class="hljs-comment">//成员变量</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-type">String</span> <span class="hljs-variable">stcvari</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;类变量属于成员变量的特例&quot;</span><br>    <span class="hljs-keyword">private</span> String name;<span class="hljs-comment">//成员属性不能直接被外部访问或修改，需要get和set方法来访问或修改属性值</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age;<span class="hljs-comment">//成员属性一般用private关键字修改，表明为私有成员，禁止外部直接访问。</span><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">show</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">variab</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;局部变量&quot;</span>;<span class="hljs-comment">//局部变量</span><br>        System.out.println(variab);<br>    &#125;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">stcshow</span><span class="hljs-params">()</span>&#123;<br>        <br>    &#125;<span class="hljs-comment">//类方法</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="成员变量-类变量-成员方法-类方法-static"><a href="#成员变量-类变量-成员方法-类方法-static" class="headerlink" title="成员变量 类变量 成员方法 类方法(static)"></a>成员变量 类变量 成员方法 类方法(<strong>static</strong>)</h2><p><strong>成员变量</strong>：包括实例变量和类变量，用static修饰的是类变量，不用static修饰的是实例变量，所有类的成员变量可以通过this来引用。</p><p><strong>类变量：</strong>静态域，静态字段，或叫静态变量，<strong>它属于该类所有实例共有的属性</strong>。而且所有的实例都可以修改这个类变量的值（这个类变量没有被final修饰的情况,因为final修饰后不能再次更改值），而且访问类变量的时候不用实例，<strong>直接用类名.的方式</strong>就可以。</p><p>成员方法：包括实例方法和类方法，用static的方法就是类方法，不用static修饰的就是实例方法。实例方法必须在创建实例之后才可以调用。</p><p><strong>类方法：</strong>和类变量一样，可以不用实例，直接用类就可以调用类方法。类方法这不是一个名词，只是单纯的类中描述的一个方法。加了static的方法，在程序中只运行一次，比如你两次实例化对象了，但你实际上只调用了一次static标识的方法。</p><p>在定义类时，经常需要抽象出它的属性，并定义在类的主体中。下面就来介绍与属性相关的内容。</p><p><strong>常量属性</strong></p><p>在类中定义的属性有常量属性和成员属性之分。<strong>常量属性用final关键字修饰，常量只能赋值一次，在程序中不能修改它的值。一般来说，在类中定义的常量属性用大写字母命名。</strong></p><p><strong>成员属性</strong></p><p>成员属性是抽象出来的类属性，<strong>成员属性不能直接被外部访问或修改，需要通过get和set方法来访问或修改属性值，成员属性一般用private关键字修改，表明为私有成员，禁止外部直接访问。</strong></p><p>成员属性的作用范围为整个类文件，作用范围就是成员属性的有效工作范围，在整个类文件中，成员属性都可以被访问和使用。</p><p><strong>（1）使用默认值初始化</strong></p><p>Java为声明的成员属性或变量提供了默认初始化机制，当声明成员属性或变量时即使没有显式赋值，Java也会为以下类型的成员属性或变量提供默认值：</p><p><strong>（2）使用显式值初始化</strong></p><p>声明成员属性的同时，进行赋值。</p><p><strong>（3）使用类构造方法初始化</strong></p><p>通过类构造方法来初始化属性（类构造方法后面介绍）</p><p><strong>成员变量</strong></p><p>变量前面已经介绍过了，变量的主要作用是存储程序运行过程中的临时数据，程序退出后，变量存储的内容不再存在。在类体中声明的变量称为成员变量。</p><p>成员变量的作用范围为整个类文件，在整个类文件中，成员变量都可以被访问和使用</p><p>与成员属性不同的是，成员变量无需提供get和set方法。成员变量一般用于类内部存储临时数据使用。</p><p><strong>局部变量</strong></p><p>在类方法体中声明的变量为局部变量。</p><p>局部变量的作用范围为方法体，在方法体中，局部变量可以被访问和使用，局部变量在方法体外无效，不能被访问和使用。</p><p>Java类的成员属性和成员变量有<strong>所区别****，</strong>成员属性是类所表述事物的共同特征，成员属性不能被外部直接访问和修改，必须通过类提供的get和set方法访问和修改成员属性。成员变量一般用于类内部存储临时数据使用，不需要提供get和set方法。</p><p>其实成员变量和成员属性有细微差别,属性要有get,set方法来访问,变量不需要</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br><span class="hljs-keyword">private</span> String name;<span class="hljs-comment">//有get,set方法,视为成员属性</span><br><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age;<br><span class="hljs-keyword">private</span> String gender;<span class="hljs-comment">//未提供get,set方法,视为成员变量</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">return</span> name;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setName</span><span class="hljs-params">(String name)</span> &#123;<br><span class="hljs-built_in">this</span>.name = name;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getAge</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">return</span> age;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setAge</span><span class="hljs-params">(<span class="hljs-type">int</span> age)</span> &#123;<br><span class="hljs-built_in">this</span>.age = age;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-type">float</span> <span class="hljs-title function_">getHeight</span><span class="hljs-params">()</span> &#123;<span class="hljs-comment">//height也是Person的属性</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">1.75f</span>;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setHeight</span><span class="hljs-params">(<span class="hljs-type">float</span> height)</span> &#123;<br>&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>每日一烤</category>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>每日一烤</tag>
      
      <tag>Java</tag>
      
      <tag>Ctrl cv</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>每日一烤:final关键字的作⽤是什么？</title>
    <link href="/2022/07/03/final%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E4%BD%9C%E7%94%A8%E6%98%AF%E4%BB%80%E4%B9%88/"/>
    <url>/2022/07/03/final%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E4%BD%9C%E7%94%A8%E6%98%AF%E4%BB%80%E4%B9%88/</url>
    
    <content type="html"><![CDATA[<h1 id="final关键字的作用是什么？"><a href="#final关键字的作用是什么？" class="headerlink" title="final关键字的作用是什么？"></a>final关键字的作用是什么？</h1><p><strong>修饰类：表示类不可被继承修饰⽅法：表示方法不可被⼦类覆盖，但是可以重载</strong><br><strong>修饰变量：表示变量⼀旦被赋值就不可以更改它的值。</strong><br><strong>修饰成员变量：</strong><br><strong>如果final修饰的是类变量，只能在静态初始化块中指定初始值或者声明该类变量时指定初始值。</strong><br><strong>如果final修饰的是成员变量，可以在非静态初始化块、声明该变量或者构造器中执⾏初始值。</strong><br><strong>修饰局部变量：</strong><br><strong>系统不会为局部变量进行初始化，局部变量必须由程序员显示初始化。因此使⽤final修饰局部变量时，</strong><br><strong>即可以在定义时指定默认值（后⾯的代码不能对变量再赋值），也可以不指定默认值，而在后⾯的代码</strong><br><strong>中对final变量赋初值（仅⼀次）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FinalVar</span> &#123;<br><span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<span class="hljs-comment">//再声明的时候就需要赋值 或者静态代码块赋值</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">static&#123;</span><br><span class="hljs-comment">a = 0;</span><br><span class="hljs-comment">&#125;</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<span class="hljs-comment">//再声明的时候就需要赋值 或者代码块中赋值 或者构造器赋值</span><br><span class="hljs-comment">/*&#123;</span><br><span class="hljs-comment">b = 0;</span><br><span class="hljs-comment">&#125;*/</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><span class="hljs-keyword">final</span> <span class="hljs-type">int</span> localA; <span class="hljs-comment">//局部变量只声明没有初始化，不会报错,与final⽆关。</span><br>localA = <span class="hljs-number">0</span>;<span class="hljs-comment">//在使⽤之前⼀定要赋值</span><br><span class="hljs-comment">//localA = 1; 但是不允许第⼆次赋值</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>修饰类：表示类不可被继承</strong><br><strong>修饰⽅法：表示⽅法不可被⼦类覆盖，但是可以重载</strong><br><strong>修饰变量：表示变量⼀旦被赋值就不可以更改它的值。</strong></p><ul><li><strong>修饰成员变量：</strong></li></ul><p><strong>如果final修饰的是类变量，只能在静态初始化块中指定初始值或者声明该类变量时指定初始值。</strong><br><strong>如果final修饰的是成员变量，可以在非静态初始化块、声明该变量或者构造器中执行初始值。</strong></p><ul><li><strong>修饰局部变量：</strong></li></ul><p><strong>系统不会为局部变量进⾏初始化，局部变量必须由程序员显示初始化。因此使⽤final修饰局部变量时，</strong><br><strong>即可以在定义时指定默认值（后⾯的代码不能对变量再赋值），也可以不指定默认值，而在后⾯的代码</strong><br><strong>中对final变量赋初值（仅⼀次）</strong></p>]]></content>
    
    
    <categories>
      
      <category>每日一烤</category>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>每日一烤</tag>
      
      <tag>Java</tag>
      
      <tag>Ctrl cv</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>每日一烤:==和equals⽅法之间的区别</title>
    <link href="/2022/07/02/==%E5%92%8Cequals%E6%96%B9%E6%B3%95%E4%B9%8B%E9%97%B4%E7%9A%84%E6%AF%94%E8%BE%83/"/>
    <url>/2022/07/02/==%E5%92%8Cequals%E6%96%B9%E6%B3%95%E4%B9%8B%E9%97%B4%E7%9A%84%E6%AF%94%E8%BE%83/</url>
    
    <content type="html"><![CDATA[<h1 id="x3D-x3D-和equals⽅法之前的区别"><a href="#x3D-x3D-和equals⽅法之前的区别" class="headerlink" title="&#x3D;&#x3D;和equals⽅法之前的区别"></a>&#x3D;&#x3D;和equals⽅法之前的区别</h1><h5 id="x3D-x3D-：对⽐的是栈中的值，基本数据类型是变量值，引⽤类型是堆中内存对象的地址"><a href="#x3D-x3D-：对⽐的是栈中的值，基本数据类型是变量值，引⽤类型是堆中内存对象的地址" class="headerlink" title="&#x3D;&#x3D;：对⽐的是栈中的值，基本数据类型是变量值，引⽤类型是堆中内存对象的地址"></a>&#x3D;&#x3D;：对⽐的是栈中的值，基本数据类型是变量值，引⽤类型是堆中内存对象的地址</h5><h5 id="equals：object中默认也是采⽤-x3D-x3D-⽐较，通常会重写"><a href="#equals：object中默认也是采⽤-x3D-x3D-⽐较，通常会重写" class="headerlink" title="equals：object中默认也是采⽤&#x3D;&#x3D;⽐较，通常会重写"></a>equals：object中默认也是采⽤&#x3D;&#x3D;⽐较，通常会重写</h5><h4 id="Object"><a href="#Object" class="headerlink" title="Object:"></a>Object:</h4><figure class="highlight java"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">equals</span><span class="hljs-params">(Object obj)</span>&#123;<br>    <span class="hljs-keyword">return</span> (<span class="hljs-built_in">this</span> == obj)<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="String"><a href="#String" class="headerlink" title="String"></a>String</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">equals</span><span class="hljs-params">(Object anObject)</span> &#123;<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span> == anObject) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-keyword">if</span> (anObject <span class="hljs-keyword">instanceof</span> String) &#123;<br><span class="hljs-type">String</span> <span class="hljs-variable">anotherString</span> <span class="hljs-operator">=</span> (String)anObject;<br><span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> value.length;<br><span class="hljs-keyword">if</span> (n == anotherString.value.length) &#123;<br><span class="hljs-type">char</span> v1[] = value;<br><span class="hljs-type">char</span> v2[] = anotherString.value;<br><span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span> (n-- != <span class="hljs-number">0</span>) &#123;<br><span class="hljs-keyword">if</span> (v1[i] != v2[i])<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>i++;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="上述代码可以看出，String类中被复写的equals-⽅法其实是⽐较两个字符串的内容。"><a href="#上述代码可以看出，String类中被复写的equals-⽅法其实是⽐较两个字符串的内容。" class="headerlink" title="上述代码可以看出，String类中被复写的equals()⽅法其实是⽐较两个字符串的内容。"></a>上述代码可以看出，String类中被复写的equals()⽅法其实是⽐较两个字符串的内容。</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StringDemo</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String args[])</span> &#123;<br><span class="hljs-type">String</span> <span class="hljs-variable">str1</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Hello&quot;</span>;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">str2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;Hello&quot;</span>);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">str3</span> <span class="hljs-operator">=</span> str2; <span class="hljs-comment">// 引⽤传递</span><br>        System.out.println(str1 == str2); <span class="hljs-comment">// false</span><br>        System.out.println(str1 == str3); <span class="hljs-comment">// false</span><br>        System.out.println(str2 == str3); <span class="hljs-comment">// true</span><br>        System.out.println(str1.equals(str2)); <span class="hljs-comment">// true</span><br>        System.out.println(str1.equals(str3)); <span class="hljs-comment">// true</span><br>        System.out.println(str2.equals(str3)); <span class="hljs-comment">// true</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="总结-equals算是特殊的”-x3D-x3D-”-部分类里面重写-有了更细节的毕竟能力-而”-x3D-x3D-”只比较”值或地址”"><a href="#总结-equals算是特殊的”-x3D-x3D-”-部分类里面重写-有了更细节的毕竟能力-而”-x3D-x3D-”只比较”值或地址”" class="headerlink" title="总结:equals算是特殊的”&#x3D;&#x3D;”,部分类里面重写,有了更细节的毕竟能力,而”&#x3D;&#x3D;”只比较”值或地址”"></a>总结:equals算是特殊的”&#x3D;&#x3D;”,部分类里面重写,有了更细节的毕竟能力,而”&#x3D;&#x3D;”只比较”值或地址”</h4>]]></content>
    
    
    <categories>
      
      <category>每日一烤</category>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>每日一烤</tag>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>每日一烤:JDK,JRE,JVM三者之间的关系</title>
    <link href="/2022/07/01/JDKJREJVM/"/>
    <url>/2022/07/01/JDKJREJVM/</url>
    
    <content type="html"><![CDATA[<h1 id="每日一烤"><a href="#每日一烤" class="headerlink" title="每日一烤"></a>每日一烤</h1><h2 id="JDK-JRE-JVM的关系"><a href="#JDK-JRE-JVM的关系" class="headerlink" title="JDK , JRE , JVM的关系"></a>JDK , JRE , JVM的关系</h2><h3 id="关系"><a href="#关系" class="headerlink" title="关系:"></a>关系:</h3><h5 id="JDK-x3D-JRE-Java开发工具包"><a href="#JDK-x3D-JRE-Java开发工具包" class="headerlink" title="JDK &#x3D; JRE + Java开发工具包"></a>JDK &#x3D; JRE + Java开发工具包</h5><h5 id="JRE-x3D-JVM-JAVASE标准类库"><a href="#JRE-x3D-JVM-JAVASE标准类库" class="headerlink" title="JRE &#x3D; JVM + JAVASE标准类库"></a>JRE &#x3D; JVM + JAVASE标准类库</h5><p><img src="https://cdn.jsdelivr.net/gh/fuchajun/Picture/20220501173153.png" alt="关系图"></p><h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><h5 id="JDK（Java-Development-Kit）是针对Java开发员的产品，是整个Java的核心，包括了Java运行环境JRE、Java工具和Java基础类库。-开发"><a href="#JDK（Java-Development-Kit）是针对Java开发员的产品，是整个Java的核心，包括了Java运行环境JRE、Java工具和Java基础类库。-开发" class="headerlink" title="JDK（Java Development Kit）是针对Java开发员的产品，是整个Java的核心，包括了Java运行环境JRE、Java工具和Java基础类库。(开发)"></a>JDK（Java Development Kit）是针对Java开发员的产品，是整个Java的核心，包括了Java运行环境JRE、Java工具和Java基础类库。(开发)</h5><h5 id="Java-Runtime-Environment（JRE）是运行JAVA程序所必须的环境的集合，包含JVM标准实现及Java核心类库。-运行"><a href="#Java-Runtime-Environment（JRE）是运行JAVA程序所必须的环境的集合，包含JVM标准实现及Java核心类库。-运行" class="headerlink" title="Java Runtime Environment（JRE）是运行JAVA程序所必须的环境的集合，包含JVM标准实现及Java核心类库。(运行)"></a>Java Runtime Environment（JRE）是运行JAVA程序所必须的环境的集合，包含JVM标准实现及Java核心类库。(运行)</h5><h5 id="JVM是Java-Virtual-Machine（Java虚拟机）的缩写，是整个java实现跨平台的最核心的部分，能够运行以Java语言写作的软件程序。-虚拟机"><a href="#JVM是Java-Virtual-Machine（Java虚拟机）的缩写，是整个java实现跨平台的最核心的部分，能够运行以Java语言写作的软件程序。-虚拟机" class="headerlink" title="JVM是Java Virtual Machine（Java虚拟机）的缩写，是整个java实现跨平台的最核心的部分，能够运行以Java语言写作的软件程序。(虚拟机)"></a>JVM是Java Virtual Machine（Java虚拟机）的缩写，是整个java实现跨平台的最核心的部分，能够运行以Java语言写作的软件程序。(虚拟机)</h5>]]></content>
    
    
    <categories>
      
      <category>每日一烤</category>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>每日一烤</tag>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Android 简易 音乐播放器</title>
    <link href="/2022/06/17/Android%E7%AE%80%E6%98%93%E9%9F%B3%E4%B9%90%E6%92%AD%E6%94%BE%E5%99%A8/"/>
    <url>/2022/06/17/Android%E7%AE%80%E6%98%93%E9%9F%B3%E4%B9%90%E6%92%AD%E6%94%BE%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="Android-简易-音乐播放器"><a href="#Android-简易-音乐播放器" class="headerlink" title="Android 简易 音乐播放器"></a>Android 简易 音乐播放器</h1><h2 id="Mediaplayer简介"><a href="#Mediaplayer简介" class="headerlink" title="Mediaplayer简介"></a>Mediaplayer简介</h2><h5 id="Android多媒体中的——MediaPlayer，我们可以通过这个API来播放音频和视频-该类是Androd多媒体框架中的一个重要组件，通过该类，我们可以以最小的步骤来获取，解码-和播放音视频。它支持三种不同的媒体来源"><a href="#Android多媒体中的——MediaPlayer，我们可以通过这个API来播放音频和视频-该类是Androd多媒体框架中的一个重要组件，通过该类，我们可以以最小的步骤来获取，解码-和播放音视频。它支持三种不同的媒体来源" class="headerlink" title="Android多媒体中的——MediaPlayer，我们可以通过这个API来播放音频和视频 该类是Androd多媒体框架中的一个重要组件，通过该类，我们可以以最小的步骤来获取，解码 和播放音视频。它支持三种不同的媒体来源:"></a>Android多媒体中的——MediaPlayer，我们可以通过这个API来播放音频和视频 该类是Androd多媒体框架中的一个重要组件，通过该类，我们可以以最小的步骤来获取，解码 和播放音视频。它支持三种不同的媒体来源:</h5><ul><li><p>本地资源</p></li><li><p>内部url,如ContentResolver来获取</p></li><li><p>外部url(流) 对于Android所支持的的媒体格式表</p></li></ul><h4 id="实例化"><a href="#实例化" class="headerlink" title="实例化"></a>实例化</h4><figure class="highlight java"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> MediaPlayer mediaPlayer;<br>mediaPlayer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MediaPlayer</span>();<span class="hljs-comment">//可以放在onCreate()方法里</span><br>mediaPlayer = MediaPlayer.create(getApplicationContext(),R.raw.zebrazebra);<span class="hljs-comment">//   可以放在class MusicControl extends Binder中</span><br></code></pre></td></tr></table></figure><h4 id="设置播放文件"><a href="#设置播放文件" class="headerlink" title="设置播放文件"></a>设置播放文件</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//①raw下的资源：</span><br>MediaPlayer.create(<span class="hljs-built_in">this</span>, R.raw.test);<br><br><span class="hljs-comment">//②本地文件路径：</span><br>mp.setDataSource(<span class="hljs-string">&quot;/sdcard/test.mp3&quot;</span>);<br><br><span class="hljs-comment">//③网络URL文件：</span><br>mp.setDataSource(<span class="hljs-string">&quot;http://www.xxx.com/music/test.mp3&quot;</span>);<br><span class="hljs-comment">//关于setDataSource,下一篇博文会做更加详细的介绍</span><br></code></pre></td></tr></table></figure><h3 id="Mediaplayer中的常用方法"><a href="#Mediaplayer中的常用方法" class="headerlink" title="Mediaplayer中的常用方法"></a>Mediaplayer中的常用方法</h3><ul><li><p><strong>void reset() 重置MediaPlayer至未初始化状态</strong></p></li><li><p><strong>void start () 开始</strong></p></li><li><p><strong>void stop () 停止</strong></p></li><li><p><strong>void pause () 暂停</strong></p></li><li><p><strong>int getCurrentPosition() 获取当前播放的位置</strong></p></li><li><p><strong>int getDuration() 得到文件的时间</strong></p></li><li><p><strong>void release () 回收流媒体资源。</strong></p></li><li><p><strong>void seekTo(int msec) 指定播放的位置（以毫秒为单位的时间）</strong></p></li><li><p><strong>void setLooping(boolean looping) 设置是否单曲循环</strong></p></li><li><p><strong>boolean isLooping () 是否循环播放</strong></p></li><li><p><strong>boolean isPlaying() 是否正在播放</strong></p></li></ul><h3 id="音乐播放器的一般步骤"><a href="#音乐播放器的一般步骤" class="headerlink" title="音乐播放器的一般步骤"></a>音乐播放器的一般步骤</h3><ul><li><p>reset();  &#x2F;&#x2F;重置</p></li><li><p>setDataSource(song_path);</p></li><li><p>prepare(); &#x2F;&#x2F;准备</p></li><li><p>start();  &#x2F;&#x2F;播放</p></li><li><p>pause();  &#x2F;&#x2F;暂停</p></li><li><p>start(); &#x2F;&#x2F;继续播放</p></li><li><p>stop(); &#x2F;&#x2F;停止</p></li><li><p>release(); &#x2F;&#x2F;释放音乐播放器</p></li></ul><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="布局文件"><a href="#布局文件" class="headerlink" title="布局文件"></a>布局文件</h3><h4 id="activity-music-xml"><a href="#activity-music-xml" class="headerlink" title="activity_music.xml"></a>activity_music.xml</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;utf-8&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">LinearLayout</span> <span class="hljs-attr">xmlns:android</span>=<span class="hljs-string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">xmlns:app</span>=<span class="hljs-string">&quot;http://schemas.android.com/apk/res-auto&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">xmlns:tools</span>=<span class="hljs-string">&quot;http://schemas.android.com/tools&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">tools:context</span>=<span class="hljs-string">&quot;.MediaPlayer.MusicActivity&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:gravity</span>=<span class="hljs-string">&quot;center&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:orientation</span>=<span class="hljs-string">&quot;vertical&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:background</span>=<span class="hljs-string">&quot;@drawable/image14&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">ImageView</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@+id/iv_disk&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:background</span>=<span class="hljs-string">&quot;@drawable/disk&quot;</span></span><br><span class="hljs-tag"></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_marginTop</span>=<span class="hljs-string">&quot;120dp&quot;</span>/&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">SeekBar</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@+id/sb_pg&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:progressBackgroundTint</span>=<span class="hljs-string">&quot;#000000&quot;</span></span><br><span class="hljs-tag">        /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">RelativeLayout</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><br><span class="hljs-tag"></span><br><span class="hljs-tag">        &gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">TextView</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@+id/tv_pg&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:text</span>=<span class="hljs-string">&quot;00:00&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:layout_marginLeft</span>=<span class="hljs-string">&quot;20dp&quot;</span>/&gt;</span><br><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">TextView</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@+id/tv_tt&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:layout_marginLeft</span>=<span class="hljs-string">&quot;300dp&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:text</span>=<span class="hljs-string">&quot;00:00&quot;</span> /&gt;</span><br><br><br><span class="hljs-tag">&lt;<span class="hljs-name">LinearLayout</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:layout_marginTop</span>=<span class="hljs-string">&quot;30dp&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">Button</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@+id/btn_pm&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:layout_weight</span>=<span class="hljs-string">&quot;1&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:text</span>=<span class="hljs-string">&quot;播放音乐&quot;</span> /&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">Button</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@+id/btn_sp&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:layout_toEndOf</span>=<span class="hljs-string">&quot;@+id/btn_pm&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:layout_weight</span>=<span class="hljs-string">&quot;1&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:text</span>=<span class="hljs-string">&quot;暂停播放&quot;</span></span><br><span class="hljs-tag">            /&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">Button</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@+id/btn_cp&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:text</span>=<span class="hljs-string">&quot;继续播放&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:layout_weight</span>=<span class="hljs-string">&quot;1&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:layout_toEndOf</span>=<span class="hljs-string">&quot;@+id/btn_sp&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">Button</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@+id/btn_ep&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:text</span>=<span class="hljs-string">&quot;退出播放&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:layout_weight</span>=<span class="hljs-string">&quot;1&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:layout_toEndOf</span>=<span class="hljs-string">&quot;@id/btn_cp&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">LinearLayout</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">RelativeLayout</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">LinearLayout</span>&gt;</span><br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/fuchajun/Picture/20220418102858.png" alt="布局效果"></p><h3 id="Mediaplayer实现类"><a href="#Mediaplayer实现类" class="headerlink" title="Mediaplayer实现类"></a>Mediaplayer实现类</h3><h4 id="public-class-MediaPlayerService-extends-Service"><a href="#public-class-MediaPlayerService-extends-Service" class="headerlink" title="public class MediaPlayerService extends Service"></a>public class MediaPlayerService extends Service</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.qst.helloworld.MediaPlayer;<br><br><span class="hljs-keyword">import</span> android.app.Service;<br><span class="hljs-keyword">import</span> android.content.Intent;<br><span class="hljs-keyword">import</span> android.media.MediaPlayer;<br><span class="hljs-keyword">import</span> android.os.Binder;<br><span class="hljs-keyword">import</span> android.os.Bundle;<br><span class="hljs-keyword">import</span> android.os.IBinder;<br><span class="hljs-keyword">import</span> android.os.Message;<br><br><span class="hljs-keyword">import</span> com.qst.helloworld.R;<br><span class="hljs-keyword">import</span> java.util.Timer;<br><span class="hljs-keyword">import</span> java.util.TimerTask;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MediaPlayerService</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Service</span> &#123;<br>    <span class="hljs-keyword">private</span> MediaPlayer mediaPlayer;<br>    <span class="hljs-keyword">private</span> Timer timer;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MediaPlayerService</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> IBinder <span class="hljs-title function_">onBind</span><span class="hljs-params">(Intent intent)</span> &#123;<br>        <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> Return the communication channel to the service.</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MusicControl</span>();<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onCreate</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">super</span>.onCreate();<br>            mediaPlayer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MediaPlayer</span>();<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">onStartCommand</span><span class="hljs-params">(Intent intent, <span class="hljs-type">int</span> flags, <span class="hljs-type">int</span> startId)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>.onStartCommand(intent, flags, startId);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onDestroy</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">super</span>.onDestroy();<br>    &#125;<br><br>    <span class="hljs-comment">//增加计时器</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addTimer</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">if</span>(timer == <span class="hljs-literal">null</span>)&#123;<br>            timer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Timer</span>();<br>            <span class="hljs-type">TimerTask</span> <span class="hljs-variable">task</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TimerTask</span>() &#123;<br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                    <span class="hljs-type">int</span> <span class="hljs-variable">duration</span> <span class="hljs-operator">=</span> mediaPlayer.getDuration();<br>                    <span class="hljs-type">int</span> <span class="hljs-variable">currentPos</span> <span class="hljs-operator">=</span> mediaPlayer.getCurrentPosition();<br>                    <span class="hljs-type">Message</span> <span class="hljs-variable">msg</span> <span class="hljs-operator">=</span> MusicActivity.handler.obtainMessage();<br>                    <span class="hljs-type">Bundle</span> <span class="hljs-variable">bundle</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Bundle</span>();<br>                    bundle.putInt(<span class="hljs-string">&quot;duration&quot;</span>,duration);<br>                    bundle.putInt(<span class="hljs-string">&quot;currentPosition&quot;</span>,currentPos);<br>                    msg.setData(bundle);<br>                    <span class="hljs-comment">//将消息发送到主线程队列</span><br>                    MusicActivity.handler.sendMessage(msg);<br>                &#125;<br>            &#125;;<br>            <span class="hljs-comment">//开始计时任务后的5ms,第一次执行task任务,之后每500ms执行一次</span><br>            timer.schedule(task,<span class="hljs-number">5</span>,<span class="hljs-number">500</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">MusicControl</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Binder</span>&#123;<br>        <span class="hljs-comment">//播放</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">play</span><span class="hljs-params">()</span>&#123;<br>            mediaPlayer.reset();<br>            mediaPlayer = MediaPlayer.create(getApplicationContext(),R.raw.zebrazebra);<br>            mediaPlayer.start();<br>            addTimer();<br>        &#125;<br><br><br>        <span class="hljs-comment">//暂停</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">pause</span><span class="hljs-params">()</span>&#123;<br>            mediaPlayer.pause();<br>        &#125;<br><br>        <span class="hljs-comment">//继续</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">resume</span><span class="hljs-params">()</span>&#123;<br>            mediaPlayer.start();<br>        &#125;<br>        <span class="hljs-comment">//退出</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">stop</span><span class="hljs-params">()</span>&#123;<br>            mediaPlayer.stop();<br>            mediaPlayer.release();<br>            <span class="hljs-keyword">try</span> &#123;<br>                timer.cancel();<br>            &#125;<br>            <span class="hljs-keyword">catch</span> (Exception e)&#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">//打带</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">seekTo</span><span class="hljs-params">(<span class="hljs-type">int</span> ms)</span>&#123;<br>            mediaPlayer.seekTo(ms);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="主界面"><a href="#主界面" class="headerlink" title="主界面"></a>主界面</h3><h4 id="MusicActivity-class"><a href="#MusicActivity-class" class="headerlink" title="MusicActivity.class"></a>MusicActivity.class</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.qst.helloworld.MediaPlayer;<br><span class="hljs-keyword">import</span> androidx.annotation.NonNull;<br><span class="hljs-keyword">import</span> androidx.appcompat.app.AppCompatActivity;<br><span class="hljs-keyword">import</span> android.animation.ObjectAnimator;<br><span class="hljs-keyword">import</span> android.content.ComponentName;<br><span class="hljs-keyword">import</span> android.content.Intent;<br><span class="hljs-keyword">import</span> android.content.ServiceConnection;<br><span class="hljs-keyword">import</span> android.os.Bundle;<br><span class="hljs-keyword">import</span> android.os.Handler;<br><span class="hljs-keyword">import</span> android.os.IBinder;<br><span class="hljs-keyword">import</span> android.os.Looper;<br><span class="hljs-keyword">import</span> android.os.Message;<br><span class="hljs-keyword">import</span> android.view.View;<br><span class="hljs-keyword">import</span> android.view.animation.LinearInterpolator;<br><span class="hljs-keyword">import</span> android.widget.Button;<br><span class="hljs-keyword">import</span> android.widget.ImageView;<br><span class="hljs-keyword">import</span> android.widget.SeekBar;<br><span class="hljs-keyword">import</span> android.widget.TextView;<br><br><span class="hljs-keyword">import</span> com.qst.helloworld.R;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MusicActivity</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AppCompatActivity</span> &#123;<br><br>    <span class="hljs-keyword">private</span> Button btnPlay,btnPause,btnContinue,btnExit;<br>    <span class="hljs-keyword">private</span>  <span class="hljs-keyword">static</span> TextView tvCurrentTime;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> TextView tvTotalTime;<br>    <span class="hljs-keyword">private</span> ImageView ivDisk;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> SeekBar sbProgress;<br>    <span class="hljs-keyword">private</span> ObjectAnimator animator;<br><br>    <span class="hljs-keyword">private</span> MediaPlayerService.MusicControl control;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">ServiceConnection</span> <span class="hljs-variable">conn</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServiceConnection</span>() &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onServiceConnected</span><span class="hljs-params">(ComponentName componentName, IBinder iBinder)</span> &#123;<br>            control = (MediaPlayerService.MusicControl)iBinder;<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onServiceDisconnected</span><span class="hljs-params">(ComponentName componentName)</span> &#123;<br>        &#125;<br>    &#125;;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onCreate</span><span class="hljs-params">(Bundle savedInstanceState)</span> &#123;<br>        <span class="hljs-built_in">super</span>.onCreate(savedInstanceState);<br>        setContentView(R.layout.activity_music);<br>        init();<br><br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">()</span>&#123;<br>        btnPlay = findViewById(R.id.btn_pm);<br>        btnPause = findViewById(R.id.btn_sp);<br>        btnContinue = findViewById(R.id.btn_cp);<br>        btnExit = findViewById(R.id.btn_ep);<br><br>        tvCurrentTime = findViewById(R.id.tv_pg);<br>        tvTotalTime = findViewById(R.id.tv_tt);<br>        ivDisk = findViewById(R.id.iv_disk);<br>        sbProgress = findViewById(R.id.sb_pg);<br><br>        <span class="hljs-type">OnClick</span> <span class="hljs-variable">onClick</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">OnClick</span>();<br>        btnPlay.setOnClickListener(onClick);<br>        btnPause.setOnClickListener(onClick);<br>        btnContinue.setOnClickListener(onClick);<br>        btnExit.setOnClickListener(onClick);<br><br>        <span class="hljs-comment">//动画</span><br>        animator = ObjectAnimator.ofFloat(ivDisk,<span class="hljs-string">&quot;rotation&quot;</span>,<span class="hljs-number">0</span>,<span class="hljs-number">360.0F</span>);<br>        animator.setDuration(<span class="hljs-number">10000</span>);<br>        animator.setInterpolator(<span class="hljs-keyword">new</span> <span class="hljs-title class_">LinearInterpolator</span>());<br>        animator.setRepeatCount(-<span class="hljs-number">1</span>);<br><br><br><br>        <span class="hljs-type">Intent</span> <span class="hljs-variable">intent</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Intent</span>(getApplicationContext(),MediaPlayerService.class);<br>        bindService(intent,conn,BIND_AUTO_CREATE);<br><br>        sbProgress.setOnSeekBarChangeListener(<span class="hljs-keyword">new</span> <span class="hljs-title class_">SeekBar</span>.OnSeekBarChangeListener() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onProgressChanged</span><span class="hljs-params">(SeekBar seekBar, <span class="hljs-type">int</span> progress, <span class="hljs-type">boolean</span> fromUser)</span> &#123;<br>                <span class="hljs-keyword">if</span>(fromUser)&#123;<br>                    control.seekTo(progress);<br>                &#125;<br>                <span class="hljs-keyword">if</span>(progress == seekBar.getMax())&#123;<br>                    animator.pause();<br>                &#125;<br>            &#125;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onStartTrackingTouch</span><span class="hljs-params">(SeekBar seekBar)</span> &#123;<br>                control.pause();<br>            &#125;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onStopTrackingTouch</span><span class="hljs-params">(SeekBar seekBar)</span> &#123;<br>                control.resume();<br>            &#125;<br>        &#125;);<br>    &#125;<br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">OnClick</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">View</span>.OnClickListener&#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onClick</span><span class="hljs-params">(View view)</span> &#123;<br>            <span class="hljs-keyword">switch</span> (view.getId())&#123;<br>                <span class="hljs-keyword">case</span> R.id.btn_pm:<br>                    control.play();<br>                    animator.start();<br>                    <span class="hljs-keyword">break</span> ;<br>                <span class="hljs-keyword">case</span> R.id.btn_sp:<br>                    control.pause();<br>                    animator.pause();<br>                    <span class="hljs-keyword">break</span>;<br>                <span class="hljs-keyword">case</span> R.id.btn_cp:<br>                    control.resume();<br>                    animator.resume();<br>                    <span class="hljs-keyword">break</span>;<br>                <span class="hljs-keyword">case</span> R.id.btn_ep:<br>                    finish();<br>                    <span class="hljs-keyword">break</span>;<br><br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onDestroy</span><span class="hljs-params">()</span> &#123;<br>        control.stop();<br>        unbindService(conn);<br>        <span class="hljs-built_in">super</span>.onDestroy();<br>    &#125;<br>    <span class="hljs-comment">//获取从MediaPlayerService传递过来的消息</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">Handler</span> <span class="hljs-variable">handler</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Handler</span>(Looper.myLooper())&#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handleMessage</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> Message msg)</span> &#123;<br>            <span class="hljs-built_in">super</span>.handleMessage(msg);<br>            <span class="hljs-type">Bundle</span> <span class="hljs-variable">bundle</span> <span class="hljs-operator">=</span> msg.getData();<span class="hljs-comment">//获取从子线程发过来的音乐播放进度</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">duration</span> <span class="hljs-operator">=</span> bundle.getInt(<span class="hljs-string">&quot;duration&quot;</span>);<span class="hljs-comment">//歌曲总时长</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">currentPosition</span> <span class="hljs-operator">=</span> bundle.getInt(<span class="hljs-string">&quot;currentPosition&quot;</span>);<br>            sbProgress.setMax(duration);<br>            sbProgress.setProgress(currentPosition);<br>            <span class="hljs-type">String</span> <span class="hljs-variable">totalTime</span> <span class="hljs-operator">=</span> msToMinSec(duration);<br>            <span class="hljs-type">String</span> <span class="hljs-variable">currentTime</span> <span class="hljs-operator">=</span> msToMinSec(currentPosition);<br>            tvTotalTime.setText(totalTime);<br>            tvCurrentTime.setText(currentTime);<br>        &#125;<br>    &#125;;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">msToMinSec</span><span class="hljs-params">(<span class="hljs-type">int</span> ms)</span>&#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">sec</span> <span class="hljs-operator">=</span> ms / <span class="hljs-number">1000</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">min</span> <span class="hljs-operator">=</span> sec /<span class="hljs-number">60</span>;<br>        sec -= min * <span class="hljs-number">60</span>;<br>        <span class="hljs-keyword">return</span> String.format(<span class="hljs-string">&quot;%02d:%02d&quot;</span>,min,sec);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h3><p><img src="https://cdn.jsdelivr.net/gh/fuchajun/Picture/20220418103210.png" alt="运行结果"></p>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
      <category>Service</category>
      
      <category>Mediaplayer</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Android</tag>
      
      <tag>Service</tag>
      
      <tag>Mediaplayer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Android Download Service</title>
    <link href="/2022/06/16/AndroidDownloadService/"/>
    <url>/2022/06/16/AndroidDownloadService/</url>
    
    <content type="html"><![CDATA[<h1 id="Android-Service-DownloadTask"><a href="#Android-Service-DownloadTask" class="headerlink" title="Android Service DownloadTask"></a>Android Service DownloadTask</h1><h2 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h2><h3 id="Service简介"><a href="#Service简介" class="headerlink" title="Service简介"></a>Service简介</h3><h5 id="Service后台服务-与Activity相比-Service运行在后台-Activity运行在前台-一般我们会把在后台长时间运行的代码放在Service中"><a href="#Service后台服务-与Activity相比-Service运行在后台-Activity运行在前台-一般我们会把在后台长时间运行的代码放在Service中" class="headerlink" title="Service后台服务:与Activity相比,Service运行在后台,Activity运行在前台,一般我们会把在后台长时间运行的代码放在Service中"></a>Service后台服务:与Activity相比,Service运行在后台,Activity运行在前台,一般我们会把在后台长时间运行的代码放在Service中</h5><h5 id="后台任务-不需要前台界面或者前台界面关闭仍然能够运行的任务"><a href="#后台任务-不需要前台界面或者前台界面关闭仍然能够运行的任务" class="headerlink" title="后台任务:不需要前台界面或者前台界面关闭仍然能够运行的任务"></a>后台任务:不需要前台界面或者前台界面关闭仍然能够运行的任务</h5><h5 id="Eg-后台下载任务-音乐播放任务-录音服务"><a href="#Eg-后台下载任务-音乐播放任务-录音服务" class="headerlink" title="Eg:后台下载任务,音乐播放任务,录音服务"></a>Eg:后台下载任务,音乐播放任务,录音服务</h5><h3 id="开发Service"><a href="#开发Service" class="headerlink" title="开发Service"></a>开发Service</h3><h4 id="继承Service"><a href="#继承Service" class="headerlink" title="继承Service"></a>继承Service</h4><figure class="highlight stylus"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><pre><code class="hljs stylus">Service是个抽象类，里面有一个抽象方法，自己重写生命周期方法<br><span class="hljs-function"><span class="hljs-title">onCreate</span><span class="hljs-params">()</span></span><br><span class="hljs-function"><span class="hljs-title">onStartCommand</span><span class="hljs-params">()</span></span><br><span class="hljs-function"><span class="hljs-title">onDestory</span><span class="hljs-params">()</span></span><br></code></pre></td></tr></table></figure><h4 id="注册Service"><a href="#注册Service" class="headerlink" title="注册Service"></a>注册Service</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DownloadService</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Service</span> &#123;<br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">DownloadTask</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span>&#123;<br>        <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-variable">totalSize</span> <span class="hljs-operator">=</span> <span class="hljs-number">1024</span>; <span class="hljs-comment">//总大小</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-variable">current</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; <span class="hljs-comment">//当前进度</span><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">while</span>(current&lt;totalSize)&#123;<br>            Log.d(<span class="hljs-string">&quot;download&quot;</span>, <span class="hljs-string">&quot;run: &quot;</span>+current);<br>            <span class="hljs-keyword">try</span> &#123;<br>                Thread.sleep(<span class="hljs-number">100</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>            current++;<br>          &#125;<br>        &#125;<br>    &#125;<br>    DownloadTask task;<br>    <span class="hljs-comment">//第一次创建会启动</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onCreate</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">super</span>.onCreate();<br>        task = <span class="hljs-keyword">new</span> <span class="hljs-title class_">DownloadTask</span>();<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span>  <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(task);<br>        thread.start();<br>    &#125;<br>    <span class="hljs-comment">//每次启动Service都会执行</span><br>    <span class="hljs-comment">//同一个Service可以重复多次启动，只有第一次回创建Service</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">onStartCommand</span><span class="hljs-params">(Intent intent, <span class="hljs-type">int</span> flags, <span class="hljs-type">int</span> startId)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>.onStartCommand(intent, flags, startId);<br>    &#125;<br>    <span class="hljs-comment">//定义DownloadBinder这个IBinder</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DownloadBinder</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Binder</span>&#123;<br>        <span class="hljs-comment">//设置进度总大小</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getTotal</span><span class="hljs-params">()</span>&#123;<br>            <span class="hljs-keyword">return</span> task.totalSize;<br>        &#125;<br>        <span class="hljs-comment">//里面实现与Activity需要交互的方法,拿到子进程中的下载进度</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getCurrent</span><span class="hljs-params">()</span>&#123;<br>            <span class="hljs-keyword">return</span> task.current;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//当Activity绑定Service时，就会调用onBind方法</span><br>    <span class="hljs-comment">//并且返回一个IBinder对象，这个对象最终会返回给Activity，Activity和Service就靠这个IBinder进行交互</span><br>    <span class="hljs-comment">//IBinder是个接口，需要我们自己写这个类，IBinder自己也有实现类Binder，可以直接继承这个实现类</span><br>    <span class="hljs-meta">@Nullable</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> IBinder <span class="hljs-title function_">onBind</span><span class="hljs-params">(Intent intent)</span> &#123;<br>        <span class="hljs-type">IBinder</span> <span class="hljs-variable">binder</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DownloadBinder</span>();<br>        <span class="hljs-keyword">return</span> binder;<br>    &#125;<br>    <span class="hljs-comment">//停止Service就会销毁</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onDestroy</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">super</span>.onDestroy();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="启动Service"><a href="#启动Service" class="headerlink" title="启动Service"></a>启动Service</h4><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">this</span>.startService(<span class="hljs-built_in">int</span>ent)<br></code></pre></td></tr></table></figure><h4 id="停止Service"><a href="#停止Service" class="headerlink" title="停止Service"></a>停止Service</h4><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">this</span>.stopService(<span class="hljs-built_in">int</span>ent);<br>停止Service就是销毁Service<br></code></pre></td></tr></table></figure><h3 id="绑定Service"><a href="#绑定Service" class="headerlink" title="绑定Service"></a>绑定Service</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**Service虽然运行在后台，但是经常也需要跟前台进行交互</span><br><span class="hljs-comment">比如：</span><br><span class="hljs-comment">下载服务：前台界面至少需要知道下载进度</span><br><span class="hljs-comment">音乐播放：前台不仅需要知道音乐播放进度，还能控制播放的开始暂停和进度</span><br><span class="hljs-comment">等等</span><br><span class="hljs-comment">如果要跟Service进行交互，那么必须绑定Service</span><br><span class="hljs-comment">（1）绑定Service</span><br><span class="hljs-comment">this.bindService(intent,conn,flag)</span><br><span class="hljs-comment">绑定时，如果Service没有启动，会自动启动，但是这样启动的Service在解绑时候，会自动销毁</span><br><span class="hljs-comment">（2）解绑Service</span><br><span class="hljs-comment">this.unbindService(conn)</span><br><span class="hljs-comment">Activity绑定Service进行交互的核心</span><br><span class="hljs-comment">Service中的onBind方法返回IBing对象</span><br><span class="hljs-comment">Activity中BindService绑定时，需要定义一个ServiceConnection**/</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DownloadService</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Service</span> &#123;<br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">DownloadTask</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span>&#123;<br>        <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-variable">totalSize</span> <span class="hljs-operator">=</span> <span class="hljs-number">1024</span>; <span class="hljs-comment">//总大小</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-variable">current</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; <span class="hljs-comment">//当前进度</span><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">while</span>(current&lt;totalSize)&#123;<br>            Log.d(<span class="hljs-string">&quot;download&quot;</span>, <span class="hljs-string">&quot;run: &quot;</span>+current);<br>            <span class="hljs-keyword">try</span> &#123;<br>                Thread.sleep(<span class="hljs-number">100</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>            current++;<br>          &#125;<br>        &#125;<br>    &#125;<br>    DownloadTask task;<br>    <span class="hljs-comment">//第一次创建会启动</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onCreate</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">super</span>.onCreate();<br>        task = <span class="hljs-keyword">new</span> <span class="hljs-title class_">DownloadTask</span>();<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span>  <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(task);<br>        thread.start();<br>    &#125;<br>    <span class="hljs-comment">//每次启动Service都会执行</span><br>    <span class="hljs-comment">//同一个Service可以重复多次启动，只有第一次回创建Service</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">onStartCommand</span><span class="hljs-params">(Intent intent, <span class="hljs-type">int</span> flags, <span class="hljs-type">int</span> startId)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>.onStartCommand(intent, flags, startId);<br>    &#125;<br>    <span class="hljs-comment">//定义DownloadBinder这个IBinder</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DownloadBinder</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Binder</span>&#123;<br>        <span class="hljs-comment">//设置进度总大小</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getTotal</span><span class="hljs-params">()</span>&#123;<br>            <span class="hljs-keyword">return</span> task.totalSize;<br>        &#125;<br>        <span class="hljs-comment">//里面实现与Activity需要交互的方法,拿到子进程中的下载进度</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getCurrent</span><span class="hljs-params">()</span>&#123;<br>            <span class="hljs-keyword">return</span> task.current;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//当Activity绑定Service时，就会调用onBind方法</span><br>    <span class="hljs-comment">//并且返回一个IBinder对象，这个对象最终会返回给Activity，Activity和Service就靠这个IBinder进行交互</span><br>    <span class="hljs-comment">//IBinder是个接口，需要我们自己写这个类，IBinder自己也有实现类Binder，可以直接继承这个实现类</span><br>    <span class="hljs-meta">@Nullable</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> IBinder <span class="hljs-title function_">onBind</span><span class="hljs-params">(Intent intent)</span> &#123;<br>        <span class="hljs-type">IBinder</span> <span class="hljs-variable">binder</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DownloadBinder</span>();<br>        <span class="hljs-keyword">return</span> binder;<br>    &#125;<br>    <span class="hljs-comment">//停止Service就会销毁</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onDestroy</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">super</span>.onDestroy();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
      <category>Service</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Android</tag>
      
      <tag>Service</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hexo搭建个人博客教程</title>
    <link href="/2022/06/09/Hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%95%99%E7%A8%8B/"/>
    <url>/2022/06/09/Hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%95%99%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="Hexo搭建个人博客教程"><a href="#Hexo搭建个人博客教程" class="headerlink" title="Hexo搭建个人博客教程"></a>Hexo搭建个人博客教程</h1><h3 id="Hexo简介"><a href="#Hexo简介" class="headerlink" title="Hexo简介"></a>Hexo简介</h3><h4 id="Hexo是一款基于Node-js的静态博客框架，依赖少易于安装使用，可以方便的生成静态网页托管在GitHub和Coding上，是搭建博客的首选框架。Hexo-使用-Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。这是Hexo官网-有关Hexo配置的具体说明可以从上面得到答案"><a href="#Hexo是一款基于Node-js的静态博客框架，依赖少易于安装使用，可以方便的生成静态网页托管在GitHub和Coding上，是搭建博客的首选框架。Hexo-使用-Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。这是Hexo官网-有关Hexo配置的具体说明可以从上面得到答案" class="headerlink" title="Hexo是一款基于Node.js的静态博客框架，依赖少易于安装使用，可以方便的生成静态网页托管在GitHub和Coding上，是搭建博客的首选框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。这是Hexo官网,有关Hexo配置的具体说明可以从上面得到答案."></a>Hexo是一款基于Node.js的静态博客框架，依赖少易于安装使用，可以方便的生成静态网页托管在GitHub和Coding上，是搭建博客的首选框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。这是<a href="https://hexo.io/zh-cn/">Hexo官网</a>,有关Hexo配置的具体说明可以从上面得到答案.</h4><h2 id="Hexo搭建准备工作"><a href="#Hexo搭建准备工作" class="headerlink" title="Hexo搭建准备工作"></a>Hexo搭建准备工作</h2><h3 id="预备安装程序"><a href="#预备安装程序" class="headerlink" title="预备安装程序:"></a>预备安装程序:</h3><ul><li>Node.js</li><li><a href="https://gitforwindows.org/">Git</a></li><li>Hexo</li></ul><h2 id="Github-Pages上搭建博客"><a href="#Github-Pages上搭建博客" class="headerlink" title="Github Pages上搭建博客"></a>Github Pages上搭建博客</h2><h3 id="Github创建仓库"><a href="#Github创建仓库" class="headerlink" title="Github创建仓库"></a>Github创建仓库</h3><h6 id="仓库名与GitHub用户名相同"><a href="#仓库名与GitHub用户名相同" class="headerlink" title="仓库名与GitHub用户名相同"></a>仓库名与GitHub用户名相同</h6><p>eg:fuchajun.github.io</p><h6 id="生成SSH密钥添加到Github"><a href="#生成SSH密钥添加到Github" class="headerlink" title="生成SSH密钥添加到Github"></a>生成SSH密钥添加到Github</h6><figure class="highlight shell"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><pre><code class="hljs shell">git config --global user.name &quot;fuchajun&quot;<br>git config --global user.email &quot;bolanfucha@126.com&quot;<br></code></pre></td></tr></table></figure><h6 id="验证配置是否成功"><a href="#验证配置是否成功" class="headerlink" title="验证配置是否成功"></a>验证配置是否成功</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">git config user.name<br>git config user.email<br></code></pre></td></tr></table></figure><h6 id="创建SSH"><a href="#创建SSH" class="headerlink" title="创建SSH"></a>创建SSH</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ssh-keygen -t rsa -C &quot;bolanfucha@126.com&quot;<br></code></pre></td></tr></table></figure><h6 id="一路回车-Enter-电脑C-x2F-用户名-x2F-ssh中生成密钥"><a href="#一路回车-Enter-电脑C-x2F-用户名-x2F-ssh中生成密钥" class="headerlink" title="一路回车(Enter),电脑C&#x2F;用户名&#x2F;.ssh中生成密钥"></a>一路回车(Enter),电脑C&#x2F;用户名&#x2F;.ssh中生成密钥</h6><p>id_rsa(私钥)</p><p>id_rsa.pub(公钥)</p><h6 id="打开id-rsa-pub文件-复制到Github-gt-gt-Setting-gt-gt-SSH-and-GPG-keys-gt-gt-New-SSH-key-gt-gt-key-gt-gt-title-随意"><a href="#打开id-rsa-pub文件-复制到Github-gt-gt-Setting-gt-gt-SSH-and-GPG-keys-gt-gt-New-SSH-key-gt-gt-key-gt-gt-title-随意" class="headerlink" title="打开id_rsa.pub文件,复制到Github&gt;&gt;Setting&gt;&gt;SSH and GPG keys&gt;&gt;New SSH key&gt;&gt;key&gt;&gt;title 随意"></a>打开id_rsa.pub文件,复制到Github&gt;&gt;Setting&gt;&gt;SSH and GPG keys&gt;&gt;New SSH key&gt;&gt;key&gt;&gt;title 随意</h6><p><img src="https://gcore.jsdelivr.net/gh/fuchajun/Picture/image-20220409180929213.png" alt="Github&gt;&gt;Setting&gt;&gt;SSH and GPG keys&gt;&gt;New SSH key"></p><h6 id="验证SSH"><a href="#验证SSH" class="headerlink" title="验证SSH"></a>验证SSH</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ssh -T git@github.com<br></code></pre></td></tr></table></figure><p><img src="https://gcore.jsdelivr.net/gh/fuchajun/Picture/image-20220409181248830.png" alt="验证ssh"></p><h6 id="but-Github-does-not-provide-shell-access-不是什么重要信息-前半句即可证明验证成功"><a href="#but-Github-does-not-provide-shell-access-不是什么重要信息-前半句即可证明验证成功" class="headerlink" title="but Github does not provide shell access 不是什么重要信息,前半句即可证明验证成功"></a>but Github does not provide shell access 不是什么重要信息,前半句即可证明验证成功</h6><h6 id="如下图-配置Hexo-config-yml文件-将Hexo部署至Github-config-yml所指的是Hexo下的配置文件-注意不要与theme的配置文件相混淆"><a href="#如下图-配置Hexo-config-yml文件-将Hexo部署至Github-config-yml所指的是Hexo下的配置文件-注意不要与theme的配置文件相混淆" class="headerlink" title="如下图 配置Hexo _config.yml文件,将Hexo部署至Github,-config.yml所指的是Hexo下的配置文件,注意不要与theme的配置文件相混淆."></a>如下图 配置Hexo _config.yml文件,将Hexo部署至Github,-config.yml所指的是Hexo下的配置文件,注意不要与theme的配置文件相混淆.</h6><p><img src="https://gcore.jsdelivr.net/gh/fuchajun/Picture/image-20220409191119206.png"></p><h6 id="同理-也可以将Hexo部署到Gittee或者Coding上-类似于国内的Github-一个是阿里的一个是腾讯的-国内访问速度会快一些"><a href="#同理-也可以将Hexo部署到Gittee或者Coding上-类似于国内的Github-一个是阿里的一个是腾讯的-国内访问速度会快一些" class="headerlink" title="同理,也可以将Hexo部署到Gittee或者Coding上(类似于国内的Github,一个是阿里的一个是腾讯的,国内访问速度会快一些)"></a>同理,也可以将Hexo部署到Gittee或者Coding上(类似于国内的Github,一个是阿里的一个是腾讯的,国内访问速度会快一些)</h6><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">deploy:</span><br>  <span class="hljs-attr">type:</span> <span class="hljs-string">git</span> <br>  <span class="hljs-attr">repository:</span> <br>    <span class="hljs-attr">github:</span> <span class="hljs-string">git@github.com:fuchajun/fuchajun.github.io.git</span><br>    <span class="hljs-attr">coding:</span> <span class="hljs-string">git@e.coding.net:fuchajun/fuchajun/fuchajun.git</span><br>    <span class="hljs-string">//gittee:git@...........</span><br>  <span class="hljs-attr">branch:</span> <span class="hljs-string">master</span><br></code></pre></td></tr></table></figure><h6 id="安装deploy-git"><a href="#安装deploy-git" class="headerlink" title="安装deploy-git"></a>安装deploy-git</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">npm install hexo-deployer-git --save<br></code></pre></td></tr></table></figure><h6 id="git三部曲"><a href="#git三部曲" class="headerlink" title="git三部曲"></a>git三部曲</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">hexo clean//清除hexo缓存<br>hexo generate//生成<br>hexo deploy//部署<br></code></pre></td></tr></table></figure><h6 id="得到下图就说明部署成功了，过一会儿就可以在-http-fuchajun-github-io-这个网站看到我的博客了"><a href="#得到下图就说明部署成功了，过一会儿就可以在-http-fuchajun-github-io-这个网站看到我的博客了" class="headerlink" title="得到下图就说明部署成功了，过一会儿就可以在(http://fuchajun.github.io) 这个网站看到我的博客了!!!"></a>得到下图就说明部署成功了，过一会儿就可以在(<a href="http://fuchajun.github.io/">http://fuchajun.github.io</a>) 这个网站看到我的博客了!!!</h6>]]></content>
    
    
    <categories>
      
      <category>Hexo</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2022/06/05/hello-world/"/>
    <url>/2022/06/05/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate(hexo g)<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy(hexo d)<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    <categories>
      
      <category>Hexo</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
